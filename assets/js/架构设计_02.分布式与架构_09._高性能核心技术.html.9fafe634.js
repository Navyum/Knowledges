"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[12019],{36995:(a,e)=>{e.A=(a,e)=>{const i=a.__vccOpts||a;for(const[a,t]of e)i[a]=t;return i}},57776:(a,e,i)=>{i.r(e),i.d(e,{comp:()=>n,data:()=>r});var t=i(6254);const l={},n=(0,i(36995).A)(l,[["render",function(a,e){return(0,t.uX)(),(0,t.CE)("div",null,e[0]||(e[0]=[(0,t.Fv)('<h2 id="零拷贝技术" tabindex="-1"><a class="header-anchor" href="#零拷贝技术"><span>零拷贝技术：</span></a></h2><ul><li>避免从内核态到用户态的数据拷贝</li></ul><h2 id="多路复用技术" tabindex="-1"><a class="header-anchor" href="#多路复用技术"><span>多路复用技术：</span></a></h2><ul><li>避免阻进程/线程阻塞在io上，而是等内核在io准备好(同步)或者io已完成(异步)时通知进程/线程。这样的好处：将进程/线程切换权限交给操作系统，可以让出CPU执行其他事情。</li></ul><h2 id="写时复制-copy-on-write" tabindex="-1"><a class="header-anchor" href="#写时复制-copy-on-write"><span>写时复制（copy on write）：</span></a></h2><h2 id="线程池技术" tabindex="-1"><a class="header-anchor" href="#线程池技术"><span>线程池技术：</span></a></h2><ul><li>因为线程并不会一直占用CPU，所以为了避免线程无限创建和销毁的开销，预先创建一批线程（CPU * 2）。</li></ul><h2 id="无锁编程技术-lock-free" tabindex="-1"><a class="header-anchor" href="#无锁编程技术-lock-free"><span>无锁编程技术（lock-free）：</span></a></h2><h4 id="成为无锁的条件" tabindex="-1"><a class="header-anchor" href="#成为无锁的条件"><span>成为无锁的条件:</span></a></h4><ol><li>是多线程</li><li>多个线程访问共享内存.</li><li>不会令其它线程造成阻塞.</li></ol><ul><li>解释：在访问共享资源时，阻塞型同步和非阻塞型同步。阻塞型同步：常用的互斥锁、信号量、条件变量</li><li>CAS</li></ul><h2 id="进程间通信技术" tabindex="-1"><a class="header-anchor" href="#进程间通信技术"><span>进程间通信技术：</span></a></h2><ul><li>管道</li><li>命名管道</li><li>socket</li><li>消息队列</li><li>信号</li><li>信号量</li><li>共享内存</li></ul><h2 id="rpc-序列化技术" tabindex="-1"><a class="header-anchor" href="#rpc-序列化技术"><span>RPC &amp;&amp; 序列化技术</span></a></h2><h2 id="数据库索引技术" tabindex="-1"><a class="header-anchor" href="#数据库索引技术"><span>数据库索引技术</span></a></h2><h2 id="缓存技术-布隆过滤器" tabindex="-1"><a class="header-anchor" href="#缓存技术-布隆过滤器"><span>缓存技术 &amp;&amp; 布隆过滤器</span></a></h2><h3 id="热点问题" tabindex="-1"><a class="header-anchor" href="#热点问题"><span>热点问题：</span></a></h3><h4 id="缓存穿透-强调不存在" tabindex="-1"><a class="header-anchor" href="#缓存穿透-强调不存在"><span>缓存穿透：强调不存在</span></a></h4><ul><li>定义： <ul><li>是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据</li></ul></li></ul><ol><li>存储数据不存在</li><li>缓存数据生成耗费大量时间或者资源</li></ol><h4 id="缓存雪崩-强调大量过期" tabindex="-1"><a class="header-anchor" href="#缓存雪崩-强调大量过期"><span>缓存雪崩：强调大量过期</span></a></h4><ul><li><p>定义：</p><ul><li>是指当缓存集体(大量) 失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，从而对存储系统造成巨大的性能压力，造成整个系统崩溃。</li></ul></li><li><p>解决方法有两种：</p><ul><li><strong>更新锁机制</strong></li><li><strong>后台更新机制</strong></li></ul></li></ul><h4 id="缓存击穿-强调热点数据过期" tabindex="-1"><a class="header-anchor" href="#缓存击穿-强调热点数据过期"><span>缓存击穿：强调热点数据过期</span></a></h4><ul><li>定义： <ul><li>热点key失效，高并发请求打到数据库，就是缓存击穿，缓存击穿可以理解成是缓存穿透的一种特殊情况</li></ul></li><li>解决方法：</li></ul><h2 id="全文搜索技术" tabindex="-1"><a class="header-anchor" href="#全文搜索技术"><span>全文搜索技术</span></a></h2><h2 id="负载均衡技术" tabindex="-1"><a class="header-anchor" href="#负载均衡技术"><span>负载均衡技术</span></a></h2><ul><li>负载均衡算法： *</li><li>一致性哈希</li></ul>',27)]))}]]),r=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html","title":"09.*高性能核心技术","lang":"zh-CN","frontmatter":{"title":"09.*高性能核心技术","date":"2025-06-17T14:40:24.000Z","author":"Navyum","tags":["架构设计","高性能设计"],"categories":["分布式"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"description":"零拷贝技术： 避免从内核态到用户态的数据拷贝 多路复用技术： 避免阻进程/线程阻塞在io上，而是等内核在io准备好(同步)或者io已完成(异步)时通知进程/线程。这样的好处：将进程/线程切换权限交给操作系统，可以让出CPU执行其他事情。 写时复制（copy on write）： 线程池技术： 因为线程并不会一直占用CPU，所以为了避免线程无限创建和销毁...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"09.*高性能核心技术"}],["meta",{"property":"og:description","content":"零拷贝技术： 避免从内核态到用户态的数据拷贝 多路复用技术： 避免阻进程/线程阻塞在io上，而是等内核在io准备好(同步)或者io已完成(异步)时通知进程/线程。这样的好处：将进程/线程切换权限交给操作系统，可以让出CPU执行其他事情。 写时复制（copy on write）： 线程池技术： 因为线程并不会一直占用CPU，所以为了避免线程无限创建和销毁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"架构设计"}],["meta",{"property":"article:tag","content":"高性能设计"}],["meta",{"property":"article:published_time","content":"2025-06-17T14:40:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"09.*高性能核心技术\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T14:40:24.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.06,"words":619},"filePathRelative":"架构设计/02.分布式与架构/09.*高性能核心技术.md","localizedDate":"2025年6月17日","excerpt":"<h2>零拷贝技术：</h2>\\n<ul>\\n<li>避免从内核态到用户态的数据拷贝</li>\\n</ul>\\n<h2>多路复用技术：</h2>\\n<ul>\\n<li>避免阻进程/线程阻塞在io上，而是等内核在io准备好(同步)或者io已完成(异步)时通知进程/线程。这样的好处：将进程/线程切换权限交给操作系统，可以让出CPU执行其他事情。</li>\\n</ul>\\n<h2>写时复制（copy on write）：</h2>\\n<h2>线程池技术：</h2>\\n<ul>\\n<li>因为线程并不会一直占用CPU，所以为了避免线程无限创建和销毁的开销，预先创建一批线程（CPU * 2）。</li>\\n</ul>\\n<h2>无锁编程技术（lock-free）：</h2>","autoDesc":true}')}}]);
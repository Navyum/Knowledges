"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[30268],{5808:(e,l,i)=>{i.r(l),i.d(l,{comp:()=>c,data:()=>a});var o=i(6254);const t={},c=(0,i(36995).A)(t,[["render",function(e,l){return(0,o.uX)(),(0,o.CE)("div",null,l[0]||(l[0]=[(0,o.Fv)('<h3 id="为什么使用主、从架构" tabindex="-1"><a class="header-anchor" href="#为什么使用主、从架构"><span>为什么使用主、从架构：</span></a></h3><ol><li>单机下如果宕机，通过AOF、RDB恢复需要时间。服务会出现中断，为了<code>高可用性</code></li><li>单机性能存在瓶颈上限，主、从可以提升读操作的瓶颈上限，为了<code>高性能</code></li></ol><h3 id="主、从模式特点" tabindex="-1"><a class="header-anchor" href="#主、从模式特点"><span>主、从模式特点：</span></a></h3><ul><li>主、从之间的数据同步操作是异步进行的，属于弱一致性（最终一致）</li><li>通过冗余解决可用性问题： <ul><li>数据冗余（每个节点都存数据）</li><li>服务冗余（每个节点都可以提供读服务，不支持写）</li></ul></li><li>冗余带来的新问题： <ul><li>主、从数据的一致性问题： <ul><li>Redis提供了主从复制模式，避免数据不一致</li></ul></li><li>多服务的通信问题： <ul><li>主、从心跳监测</li><li>哨兵机制</li></ul></li></ul></li><li>读、写分离： <ul><li>读操作：主、从都可以接收命令</li><li>写操作：仅主库接收命令，执行后同步给从库</li></ul></li></ul><h3 id="主、从首次同步流程" tabindex="-1"><a class="header-anchor" href="#主、从首次同步流程"><span>主、从<code>首次同步</code>流程：</span></a></h3><ol><li>命令：<code>replicaof/slaveof 主库IP PORT</code></li><li>流程： <ul><li>runID: 每个实例唯一id；</li><li>offset：表示首次复制；</li><li>FULLRESYNC：全量复制</li><li>replication buffer： 主库RDB文件生成后，收到的所有写操作存储在该buffer <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/92c2a902061bef55118deb82efda070c.png" alt="图片" loading="lazy"></li><li>过程说明： <ul><li>第一阶段：<code>协商</code><ul><li>从库给主库发送：<code>psync ? -1</code><ul><li>表示要进行数据同步，因为不知道主库的runID所以设置<code>?</code>，且首次offset=-1</li></ul></li><li>主库收到<code>psync</code>命令，发送：<code>FULLRESYNC runID offset</code><ul><li>告诉从库主库的ID、以及主库目前的复制进度offset</li></ul></li></ul></li><li>第二阶段：<code>RDB数据同步</code><ul><li>主库执行<code>bgsave</code>生成RDB文件，将<code>RDB文件</code>同步给从库</li><li>从库收到RDB数据后，清空先前数据并加载收到的RDB数据</li><li>从库完成加载，回复<code>ACK</code>给主库</li></ul></li><li>第三阶段：<code>增量数据同步</code><ul><li>主库把第二阶段执行过程中，新收到的存放在<code>replication buffer</code>中的<code>写命令</code>发送给从库</li><li>从库有序执行这些<code>写命令</code>，首次同步即完成</li></ul></li><li>后续： <ul><li>第一次主、从同步后，主、从TCP连接会一直维持着</li><li>主库后续的增量数据都会通过<code>replication buffer</code>缓冲区，传给从库。</li></ul></li></ul></li></ul></li><li>主节点复制缓冲区 <code>replication buffer</code>： <ul><li>主库会为<code>每个从库</code>创建一个单独的缓冲区</li><li>该缓冲区的默认大小是 <code>32M</code></li><li>设计的目的：<code>确保命令的实时性、有序性、完整性和传输的可靠性</code>(与AOF缓冲区作用相似，一个是磁盘IO、一个是网络IO)</li><li>当<code>replication buffer</code>满了，会导致连接断开，主库删除缓存，从节点重新连接并重新开始全量复制</li></ul></li></ol><h3 id="主、从断联后的增量同步流程" tabindex="-1"><a class="header-anchor" href="#主、从断联后的增量同步流程"><span>主、从断联后的<code>增量同步</code>流程：</span></a></h3><ol><li><p>发生时机：</p><ul><li>当第一次主、从同步的TCP长连接因为网络原因中断，又重新连接时</li></ul></li><li><p>流程： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/db8f752c1b27dd5f8d9a366a6cbd916b.png" alt="Img" loading="lazy"></p><ul><li>过程说明： <ol><li>主、从库的连接恢复</li><li>从库给主库发送 <code>psync 自己runID offset</code> 命令，并把自己当前的 slave_repl_offset作为<code>offset</code>发给主库</li><li>主库会判断自己的<code>master_repl_offset</code> 和 <code>slave_repl_offset</code> 之间的差距，如果有差距发送<code>CONTINUE</code>命令</li><li>主库把 master_repl_offset 和 slave_repl_offset 之间的<code>写命令操作</code>，同步给从库</li></ol></li></ul></li><li><p><code>repl_backlog_buffer</code>：</p></li></ol><ul><li>主库<code>只有一个</code>repl backlog buffer</li><li>该缓冲区的默认大小是 <code>1M</code></li><li>写时机：主、从首次同步完成后，主服务器进行<code>命令传播</code>时，开始将增量写操作写入<code>repl_backlog_buffer</code>，然后通过<code>replication buffer</code>发送</li><li>repl_backlog_buffer 是一个<code>环形缓冲区</code>，写满后会覆盖写</li><li>覆盖写的问题： <ul><li>如果从库的读取速度比较慢，主库写入速度快，会导致从库还未读取的命令被主库写覆盖，这样会导致主、从库间的数据不一致，会再次触发低效的<code>全量同步</code></li></ul></li><li>覆盖写问题的优化： <ul><li>设置合适的repl_backlog_size</li><li><code>所需缓冲空间大小</code> = <code>主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小</code>（生产速度-消费速度）</li><li><code>repl_backlog_size</code> = <code>所需缓冲空间大小</code> * 2（做冗余）</li></ul></li></ul>',9)]))}]]),a=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/08.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5-Slave.html","title":"08.主从同步-Slave","lang":"zh-CN","frontmatter":{"title":"08.主从同步-Slave","date":"2025-06-17T15:38:29.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","主从同步","repl_backlog_buffer"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"为什么使用主、从架构： 单机下如果宕机，通过AOF、RDB恢复需要时间。服务会出现中断，为了高可用性 单机性能存在瓶颈上限，主、从可以提升读操作的瓶颈上限，为了高性能 主、从模式特点： 主、从之间的数据同步操作是异步进行的，属于弱一致性（最终一致） 通过冗余解决可用性问题： 数据冗余（每个节点都存数据） 服务冗余（每个节点都可以提供读服务，不支持写） ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/08.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5-Slave.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"08.主从同步-Slave"}],["meta",{"property":"og:description","content":"为什么使用主、从架构： 单机下如果宕机，通过AOF、RDB恢复需要时间。服务会出现中断，为了高可用性 单机性能存在瓶颈上限，主、从可以提升读操作的瓶颈上限，为了高性能 主、从模式特点： 主、从之间的数据同步操作是异步进行的，属于弱一致性（最终一致） 通过冗余解决可用性问题： 数据冗余（每个节点都存数据） 服务冗余（每个节点都可以提供读服务，不支持写） ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/92c2a902061bef55118deb82efda070c.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"主从同步"}],["meta",{"property":"article:tag","content":"repl_backlog_buffer"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:38:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"08.主从同步-Slave\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/92c2a902061bef55118deb82efda070c.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/db8f752c1b27dd5f8d9a366a6cbd916b.png\\"],\\"datePublished\\":\\"2025-06-17T15:38:29.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":3.54,"words":1063},"filePathRelative":"常用软件/数据库/redis/08.主从同步-Slave.md","localizedDate":"2025年6月17日","excerpt":"<h3>为什么使用主、从架构：</h3>\\n<ol>\\n<li>单机下如果宕机，通过AOF、RDB恢复需要时间。服务会出现中断，为了<code>高可用性</code></li>\\n<li>单机性能存在瓶颈上限，主、从可以提升读操作的瓶颈上限，为了<code>高性能</code></li>\\n</ol>\\n<h3>主、从模式特点：</h3>\\n<ul>\\n<li>主、从之间的数据同步操作是异步进行的，属于弱一致性（最终一致）</li>\\n<li>通过冗余解决可用性问题：\\n<ul>\\n<li>数据冗余（每个节点都存数据）</li>\\n<li>服务冗余（每个节点都可以提供读服务，不支持写）</li>\\n</ul>\\n</li>\\n<li>冗余带来的新问题：\\n<ul>\\n<li>主、从数据的一致性问题：\\n<ul>\\n<li>Redis提供了主从复制模式，避免数据不一致</li>\\n</ul>\\n</li>\\n<li>多服务的通信问题：\\n<ul>\\n<li>主、从心跳监测</li>\\n<li>哨兵机制</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>读、写分离：\\n<ul>\\n<li>读操作：主、从都可以接收命令</li>\\n<li>写操作：仅主库接收命令，执行后同步给从库</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},36995:(e,l)=>{l.A=(e,l)=>{const i=e.__vccOpts||e;for(const[e,o]of l)i[e]=o;return i}}}]);
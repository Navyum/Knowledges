"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[40452],{36995:(a,e)=>{e.A=(a,e)=>{const t=a.__vccOpts||a;for(const[a,l]of e)t[a]=l;return t}},68534:(a,e,t)=>{t.r(e),t.d(e,{comp:()=>i,data:()=>s});var l=t(6254);const n={},i=(0,t(36995).A)(n,[["render",function(a,e){return(0,l.uX)(),(0,l.CE)("div",null,e[0]||(e[0]=[(0,l.Fv)('<h2 id="散列表-哈希表" tabindex="-1"><a class="header-anchor" href="#散列表-哈希表"><span>散列表/哈希表</span></a></h2><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点：</span></a></h3><ul><li>通过建立键 key 与值 value 之间的映射，实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间复杂度的高效的元素查询</li><li></li></ul><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例：</span></a></h3><ul><li>树</li><li>图</li></ul><h3 id="图解" tabindex="-1"><a class="header-anchor" href="#图解"><span>图解：</span></a></h3><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c8a4e67d172ba7fc2845b8b0efde7a41.png" width="60%"><h3 id="常用操作" tabindex="-1"><a class="header-anchor" href="#常用操作"><span>常用操作：</span></a></h3><ul><li>初始化</li><li>查询操作</li><li>添加键值对</li><li>删除键值对</li></ul><h3 id="哈希函数-hash-function" tabindex="-1"><a class="header-anchor" href="#哈希函数-hash-function"><span>哈希函数（hash function）：</span></a></h3><ul><li>作用：作用是将一个较大的输入空间映射到一个较小的输出空间</li><li>索引位置（桶）计算： <code>index = hash(key) % capacity</code></li></ul><h3 id="哈希冲突" tabindex="-1"><a class="header-anchor" href="#哈希冲突"><span>哈希冲突</span></a></h3><ul><li>因为输入空间远大于输出空间，所以理论上一定存在冲突</li><li>解决方式： <ul><li>链式地址 <ul><li>原理：将所有发生冲突的键值对存储在同一个桶的同一链表中（redis hash、go map）</li><li>当链表很长时，可以将链表转换为&#39;AVL 树&#39;或&#39;红黑树&#39;，以提高查询效率</li></ul></li><li>开放寻址 <ul><li>原理：不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突</li><li>具体方法： <ul><li><code>线性探测</code>： <ul><li>采用<code>固定步长</code>的线性搜索： <ul><li>插入时，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为1），直至找到空桶，将元素插入其中</li><li>查询时，若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素。如果遇到空桶，说明目标不在哈希表中</li></ul></li></ul></li><li><code>平方探测</code>： <ul><li>采用<code>探测次数的平方</code>步长的搜索： <ul><li>与线性探测类似</li></ul></li></ul></li><li><code>多次哈希</code>： <ul><li>使用多个哈希函数 <ul><li>插入时，若出现冲突，则尝试更换哈希函数，直到找到空位</li><li>查询时，若出现冲突，则尝试更换哈希函数，直到找到元素或者出现空位</li></ul></li></ul></li></ul></li></ul></li><li>再哈希 <ul><li>原理：新建一个更大的哈希表，使用新的哈希函数将原先键值对重新映射到新的地址</li></ul></li></ul></li></ul>',13)]))}]]),s=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/1.%E6%95%A3%E5%88%97%E8%A1%A8.html","title":"1.散列表","lang":"zh-CN","frontmatter":{"title":"1.散列表","date":"2025-06-17T14:51:35.000Z","author":"Navyum","tags":["散列表"],"categories":["数据结构"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"散列表/哈希表 特点： 通过建立键 key 与值 value 之间的映射，实现O(1)时间复杂度的高效的元素查询 举例： 树 图 图解： 常用操作： 初始化 查询操作 添加键值对 删除键值对 哈希函数（hash function）： 作用：作用是将一个较大的输入空间映射到一个较小的输出空间 索引位置（桶）计算： index = hash(key) % ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/1.%E6%95%A3%E5%88%97%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"1.散列表"}],["meta",{"property":"og:description","content":"散列表/哈希表 特点： 通过建立键 key 与值 value 之间的映射，实现O(1)时间复杂度的高效的元素查询 举例： 树 图 图解： 常用操作： 初始化 查询操作 添加键值对 删除键值对 哈希函数（hash function）： 作用：作用是将一个较大的输入空间映射到一个较小的输出空间 索引位置（桶）计算： index = hash(key) % ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"散列表"}],["meta",{"property":"article:published_time","content":"2025-06-17T14:51:35.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.散列表\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T14:51:35.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":1.71,"words":512},"filePathRelative":"算法数据结构/数据结构/02.哈希表/1.散列表.md","localizedDate":"2025年6月17日","excerpt":"<h2>散列表/哈希表</h2>\\n<h3>特点：</h3>\\n<ul>\\n<li>通过建立键 key 与值 value 之间的映射，实现<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>O</mi><mo stretchy=\\"false\\">(</mo><mn>1</mn><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">O(1)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord\\">1</span><span class=\\"mclose\\">)</span></span></span></span>时间复杂度的高效的元素查询</li>\\n<li></li>\\n</ul>","autoDesc":true}')}}]);
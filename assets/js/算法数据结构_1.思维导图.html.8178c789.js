"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[66740],{3751:(l,i,a)=>{a.r(i),a.d(i,{comp:()=>t,data:()=>r});var e=a(6254);const n={},t=(0,a(36995).A)(n,[["render",function(l,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h2 id="数据结构和算法" tabindex="-1"><a class="header-anchor" href="#数据结构和算法"><span>数据结构和算法</span></a></h2><h3 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h3><ul><li>数组</li><li>链表 <ul><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li><li>静态链表</li></ul></li><li>栈 <ul><li>顺序栈</li><li>链式栈</li></ul></li><li>队列 <ul><li>普通队列</li><li>双端队列</li><li>阻塞队列</li><li>并发队列</li><li>阻塞并发队列</li></ul></li></ul><h3 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h3><ul><li>二叉树 <ul><li>平衡二叉树 <ul><li>AVL树</li></ul></li><li>红黑树</li><li>完全二叉树</li><li>满二叉树</li><li>平衡二叉查找树</li></ul></li><li>多路查找树 <ul><li>B树</li><li>B+树</li><li>2-3树</li><li>2-3-4树</li></ul></li><li>堆 <ul><li>小顶堆</li><li>大顶堆</li><li>优先级队列</li><li>斐波那契堆</li><li>二项堆</li></ul></li><li>线段树</li><li>树状数组</li><li>其它</li></ul><h3 id="散列表" tabindex="-1"><a class="header-anchor" href="#散列表"><span>散列表</span></a></h3><ul><li>散列函数</li><li>链表法</li><li>开放寻址法</li><li>冲突解决</li></ul><h3 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析"><span>复杂度分析</span></a></h3><ul><li>空间复杂度</li><li>时间复杂度 <ul><li>最好</li><li>最坏</li><li>平均</li><li>均摊</li></ul></li></ul><h3 id="基本算法思想" tabindex="-1"><a class="header-anchor" href="#基本算法思想"><span>基本算法思想</span></a></h3><ul><li>贪心算法</li><li>分治算法</li><li>动态规划</li><li>回溯算法</li><li>枚举算法</li></ul><h3 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h3><ul><li>O(n^2) <ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>希尔排序</li></ul></li><li>O(nlogn) <ul><li>归并排序</li><li>快速排序</li><li>堆排序</li></ul></li><li>O(n)</li><li>计数排序</li><li>基数排序</li><li>桶排序</li></ul><h3 id="查找" tabindex="-1"><a class="header-anchor" href="#查找"><span>查找</span></a></h3><ul><li>线性表查找</li><li>树结构查找</li><li>散列表查找</li></ul><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h3><ul><li>图的存储 <ul><li>邻接矩阵</li><li>邻接表</li></ul></li><li>拓扑排序</li><li>最短路径</li><li>关键路径</li><li>最小生成树</li><li>二分图</li><li>最大流</li></ul><h3 id="字符串匹配" tabindex="-1"><a class="header-anchor" href="#字符串匹配"><span>字符串匹配</span></a></h3><ul><li>KMP</li><li>Robin-Karp</li><li>Boyer-Moore</li><li>AC自动机</li><li>Trie</li><li>后缀数组</li></ul><h3 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索"><span>搜索</span></a></h3><ul><li>深度优先搜索</li><li>广度优先搜索</li><li>A*启发式搜索</li></ul><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h3><ul><li>数论</li><li>计算几何</li><li>概率分析</li><li>并查集</li><li>拓扑网络</li><li>矩阵运算</li><li>线性规划</li></ul>',23)]))}]]),r=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html","title":"1.思维导图","lang":"zh-CN","frontmatter":{"title":"1.思维导图","author":"navyum","date":"2025-06-15T00:00:00.000Z","order":-1,"article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法","数据结构"],"tag":["思维导图"],"description":"数据结构和算法 线性表 数组 链表 单链表 双向链表 循环链表 双向循环链表 静态链表 栈 顺序栈 链式栈 队列 普通队列 双端队列 阻塞队列 并发队列 阻塞并发队列 树 二叉树 平衡二叉树 AVL树 红黑树 完全二叉树 满二叉树 平衡二叉查找树 多路查找树 B树 B+树 2-3树 2-3-4树 堆 小顶堆 大顶堆 优先级队列 斐波那契堆 二项堆 线段...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"1.思维导图"}],["meta",{"property":"og:description","content":"数据结构和算法 线性表 数组 链表 单链表 双向链表 循环链表 双向循环链表 静态链表 栈 顺序栈 链式栈 队列 普通队列 双端队列 阻塞队列 并发队列 阻塞并发队列 树 二叉树 平衡二叉树 AVL树 红黑树 完全二叉树 满二叉树 平衡二叉查找树 多路查找树 B树 B+树 2-3树 2-3-4树 堆 小顶堆 大顶堆 优先级队列 斐波那契堆 二项堆 线段..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-18T12:55:44.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"思维导图"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-18T12:55:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.思维导图\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-18T12:55:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750251344000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":1.36,"words":408},"filePathRelative":"算法数据结构/1.思维导图.md","localizedDate":"2025年6月15日","excerpt":"<h2>数据结构和算法</h2>\\n<h3>线性表</h3>\\n<ul>\\n<li>数组</li>\\n<li>链表\\n<ul>\\n<li>单链表</li>\\n<li>双向链表</li>\\n<li>循环链表</li>\\n<li>双向循环链表</li>\\n<li>静态链表</li>\\n</ul>\\n</li>\\n<li>栈\\n<ul>\\n<li>顺序栈</li>\\n<li>链式栈</li>\\n</ul>\\n</li>\\n<li>队列\\n<ul>\\n<li>普通队列</li>\\n<li>双端队列</li>\\n<li>阻塞队列</li>\\n<li>并发队列</li>\\n<li>阻塞并发队列</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>树</h3>","autoDesc":true}')},36995:(l,i)=>{i.A=(l,i)=>{const a=l.__vccOpts||l;for(const[l,e]of i)a[l]=e;return a}}}]);
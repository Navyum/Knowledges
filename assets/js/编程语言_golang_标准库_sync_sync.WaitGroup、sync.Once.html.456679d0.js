"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[19703],{36995:(e,t)=>{t.A=(e,t)=>{const n=e.__vccOpts||e;for(const[e,o]of t)n[e]=o;return n}},57848:(e,t,n)=>{n.r(t),n.d(t,{comp:()=>c,data:()=>r});var o=n(6254);const a={},c=(0,n(36995).A)(a,[["render",function(e,t){return(0,o.uX)(),(0,o.CE)("div",null,t[0]||(t[0]=[(0,o.Lk)("p",null,"Once同时使用了原子操作和互斥锁，原子操作操作done的值，互斥锁用来锁定临界区代码（如果是对代码块进行保护，还需要用锁）",-1),(0,o.Lk)("p",null,"Once过程：",-1),(0,o.Lk)("p",null,"Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的Once值的Do方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为false，而继续执行Do方法中剩余的代码。在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。如果你熟悉 GoF 设计模式中的单例模式的话，那么肯定能看出来，这个Do方法的实现方式，与那个单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为“快路径”，或者叫做“快速失败路径”。如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）“双重检查”。由于进入临界区之前，肯定要锁定保护它的互斥锁m，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为“慢路径”或者“常规路径”",-1),(0,o.Lk)("p",null,"特点：",-1),(0,o.Lk)("ol",null,[(0,o.Lk)("li",null,"如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞。"),(0,o.Lk)("li",null,"不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1。如果你需要为参数函数的执行设定重试机制，那么就要考虑Once值的适时替换问题 waitgroup")],-1),(0,o.Lk)("p",null,"最佳实践：最好用“先统一Add，再并发Done，最后Wait”这种标准方式，来使用WaitGroup值。尤其不要在调用Wait方法的同时，并发地通过调用Add方法去增加其计数器的值",-1)]))}]]),r=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.WaitGroup%E3%80%81sync.Once.html","title":"sync.WaitGroup、sync.Once","lang":"zh-CN","frontmatter":{"title":"sync.WaitGroup、sync.Once","author":"navyum","date":"2025-06-21T22:29:23.000Z","article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"category":["笔记"],"tag":["笔记"],"description":"Once同时使用了原子操作和互斥锁，原子操作操作done的值，互斥锁用来锁定临界区代码（如果是对代码块进行保护，还需要用锁） Once过程： Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.WaitGroup%E3%80%81sync.Once.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"sync.WaitGroup、sync.Once"}],["meta",{"property":"og:description","content":"Once同时使用了原子操作和互斥锁，原子操作操作done的值，互斥锁用来锁定临界区代码（如果是对代码块进行保护，还需要用锁） Once过程： Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T14:30:17.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:published_time","content":"2025-06-21T22:29:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T14:30:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"sync.WaitGroup、sync.Once\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-21T22:29:23.000Z\\",\\"dateModified\\":\\"2025-06-21T14:30:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750516217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":2,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":2.4,"words":721},"filePathRelative":"编程语言/golang/标准库/sync/sync.WaitGroup、sync.Once.md","localizedDate":"2025年6月21日","excerpt":"<p>Once同时使用了原子操作和互斥锁，原子操作操作done的值，互斥锁用来锁定临界区代码（如果是对代码块进行保护，还需要用锁）</p>\\n<p>Once过程：</p>\\n<p>Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的Once值的Do方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为false，而继续执行Do方法中剩余的代码。在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。如果你熟悉 GoF 设计模式中的单例模式的话，那么肯定能看出来，这个Do方法的实现方式，与那个单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为“快路径”，或者叫做“快速失败路径”。如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）“双重检查”。由于进入临界区之前，肯定要锁定保护它的互斥锁m，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为“慢路径”或者“常规路径”</p>","autoDesc":true}')}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[29973],{10758:(i,e,l)=>{l.r(e),l.d(e,{comp:()=>o,data:()=>c});var t=l(6254);const a={},o=(0,l(36995).A)(a,[["render",function(i,e){return(0,t.uX)(),(0,t.CE)("div",null,e[0]||(e[0]=[(0,t.Fv)('<h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务：</span></a></h3><ul><li>事务：就是要保证一组数据库操作，要么全部成功，要么全部失败</li><li>事务的特性：ACID，原子性、一致性、隔离性、持久性</li><li><strong>mysql事务是由引擎提供的支持</strong>，MyISAM 引擎就不支持事务</li><li>多事务同时执行可能会出现的问题：脏写、脏读、不可重复读、幻读 <ul><li>脏读：在一个事务内读到了另一个未提交事务修改过的数据</li><li>不可重复读：在一个事务内多次读取同一个<code>数据</code>，<strong>由于其他事务的提交</strong>，导致出现前后两次读到的<code>数据</code>不一样的情况</li><li>幻读：在一个事务内多次查询某个符合查询条件的<code>记录数量</code>，<strong>由于其他事务的提交</strong>，出现前后两次查询到的<code>记录数量</code>不一样的情况</li></ul></li></ul><h3 id="事务的状态机" tabindex="-1"><a class="header-anchor" href="#事务的状态机"><span>事务的状态机：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0731afc4e43cad83d232b2288fc7f617.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><h3 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别"><span>事务的隔离级别：</span></a></h3><ol><li>读未提交（read uncommitted）：一个事务还没提交时，它做的变更能被别的事务看到</li><li>读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交的变更对其他事务是不可见的。</li><li>串行化（serializable）：对于同一行记录“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li><li>InnoDB引擎的默认隔离级别是可重复读，但无法<code>完全避免</code>幻读 针对幻读的的避免措施 <ol><li>快照读：通过MVCC机制，创建一致性视图，确保其他事务不影响当前事务的记录数量</li><li>当前读：通过next-key lock（记录锁+间隙锁），阻塞插入操作</li></ol></li></ol><h3 id="关于隔离级别的例子" tabindex="-1"><a class="header-anchor" href="#关于隔离级别的例子"><span>关于隔离级别的例子：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e6ecdc4a33cca95933dd3c9297c3d922.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol><li>若隔离级别是“读未提交”，V1=2，V2=V3=2。事务B虽然还没有提交，但是结果已经被事务A看到了。</li><li>若隔离级别是“读提交”，V1=1，V2=V3=2。事务B的更新在提交后才能被A看到。</li><li>若隔离级别是“可重复读”，V1=V2=1，V3=2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住(A先获得锁)。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2=1，V3=2</li></ol><h3 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log"><span>Undo log：</span></a></h3><p>举个例子： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/19ca945285325f47a4f18afff70a1172.png" alt="图片" loading="lazy"> 1. 实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值. 2. 在视图 A、B、C 里面，这一个记录的值分别是 1、2、4。 3. 视图A下，视图C将值修改为4，此时视图A通过视图C添加的回滚操作，逐个回滚即可得到试图A下对应的值1</p><h3 id="事务的启动方式" tabindex="-1"><a class="header-anchor" href="#事务的启动方式"><span>事务的启动方式：</span></a></h3><ol><li>显式启动事务语句： <ul><li>启动事务: <code>begin</code>、<code>start transaction</code></li><li>提交语句: <code>commit</code>；</li><li>回滚语句: <code>rollback</code></li></ul><blockquote><p>[!TIP] <code>begin</code>、<code>start transaction</code>命令并不是一个事务的起点，在执行到它们之后的第一个<code>select</code>语句，事务才真正启动。</p></blockquote></li><li>关闭自动提交：set autocommit = 0 <ul><li>作用：关闭当前线程的自动提交功能</li><li>影响：开启后，select 语句需要手动提交/回退</li><li>周期：该事务持续存在直到主动执行 <code>commit</code>、<code>rollback</code>，或者断开连接</li></ul></li></ol><h3 id="一致性视图" tabindex="-1"><a class="header-anchor" href="#一致性视图"><span>一致性视图：</span></a></h3><ul><li>作用：定义事务执行期间用来定义“我能看到什么数据”</li><li>生效范围： <ul><li>对<code>SELECT</code>语句查询结果产生影响</li><li>RU 没有视图，<code>SELECT</code>直接返回记录最新值</li><li>RC 在每个<code>SELECT</code>语句开始执行的时候创建的</li><li>RR 在事务启动时随后的第一个<code>SELECT</code>语句时创建，整个事务存在期间都用这个视图</li><li>Serial 没有视图,通过锁实现数据访问</li></ul></li><li>一致性视图创建的两个时机： <ul><li><code>begin</code>/<code>start transaction</code>开启的事务： <ol><li>RC下，每个<code>select</code>都会创建</li><li>RR下，执行第一个快照读语句<code>select</code>时创建</li></ol></li><li><code>start transaction with consistent snapshot</code>创建一致性快照： <ol><li>执行该事务语句后立即创建</li><li>忽视当前隔离级别的限制</li></ol></li></ul></li></ul><h3 id="mysql是如何实现的多版本的一致性读mvcc" tabindex="-1"><a class="header-anchor" href="#mysql是如何实现的多版本的一致性读mvcc"><span>mysql是如何实现的多版本的一致性读MVCC：</span></a></h3><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念：</span></a></h2><ol><li>MVCC：通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</li><li><code>transaction id</code>： InnoDB 里面每个事务有一个唯一的事务 ID。<s>在事务开始的时候</s>（实际是在发生增删改时才申请），向InnoDB的事务系统申请的，按申请顺序严格递增的。</li><li><code>row trx_id</code>：每次事务<code>更新数据</code>会生成一个新的数据版本，并且把事务的 <code>transaction id</code>记录到这个数据版本row的事务ID列，记为 <code>row trx_id</code></li><li>多版本：数据表中的一行记录，其实可能有多个版本且每个版本有自己的 <code>row trx_id</code>，多个版本的记录通过roll_pointer连接，形成链式结构，通过undo log可以访问</li><li>在一个事务中，如果事务本身没有修改数据结果，那么不论在什么时候查询，看到这行数据的结果都是一致的。</li></ol><h3 id="如何查找当前事务的可读版本" tabindex="-1"><a class="header-anchor" href="#如何查找当前事务的可读版本"><span>如何查找当前事务的可读版本：</span></a></h3><ol><li><p>思路：一致性视图 + row不同版本之前的顺序关系（undo log），通过undo log，获取row的trx_id，判断对应的row是否可读，不可用则继续执行undo，直到找到当前的可读row trx_id</p></li><li><p>具体规则：</p><ol><li>InnoDB 为每个事务构造了一个数组m_ids，用来保存这个事务启动瞬间，当前<code>活跃状态</code>的<span style="color:rgb(255, 76, 65);">所有事务ID</span>。（“活跃”是指：启动了但还没ids</li><li>活跃事务数组里面事务ID的最小值记为低水位min_trx_id</li><li>当前系统里面已经创建过的事务ID的最大值加1记为高水位max_trx_id</li><li>视图数组和高水位，就组成了当前事务的一致性视图（read-view)如下： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3a41b1249a0dbf94211f925119fd9233.png" alt="Img" loading="lazy"></li></ol></li><li><p>结合undo log 如下： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e366827a5a711a60898c2c1fa7934661.png" alt="Img" loading="lazy"></p></li><li><p>通过一致性视图找可读版本的解读：</p><ol><li>根据版本链/undo log，从当前row的最大的trx_id逐个往前找</li><li>如果trx_id &gt; max_trx_id，则在<code>未提交事务区域</code>，则不可见；根据版本链找到下一个trx_id</li><li>如果 min_trx_id &lt; trx_id &lt; max_trx_id，再额外判断trx_id是否在m_ids内 <ol><li>如果在，则当前找到的trx_id，对应的事务是活跃事务还未提交，不可见。根据版本链找到下一个trx_id</li><li>如果不在，则当前事务的trx_id已经提交，可见</li></ol></li><li>如果 min_trx_id &gt; trx_id，则在<code>已提交事务区域</code>，可见</li></ol></li><li><p>可重复读下(RR)，事务可见版本结论：</p><ol><li>对于未提交的版本，不可见；</li><li>对于已提交的版本，如果是在视图创建后提交的，不可见；是在视图创建前提交的可见。</li><li>对于自己的更新的版本总是可见；</li><li>可见版本是找到上述版本中最大的trx_id的那个</li></ol></li><li><p>读提交下(RC), 事务可见版本结论：</p><ol><li>每一个语句执行前都会重新算出一个新的视图。所有读都是<code>当前读</code>（即读取当前已提交的最新版本）</li></ol></li><li><p>对于更新逻辑：</p><ol><li>一致性读不适用更新逻辑（<code>update语句</code>）。更新逻辑都是先读后写的，读当前的值，称为<code>当前读</code>（current read）。</li><li>在同一个事务内的记录<code>UPDATE</code>更新，使用<code>当前读</code>，会被后续的SELECT查到</li><li>强制<code>select 语句</code>使用当前读的两种方式：</li></ol><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(S锁 共享锁)： select * from t where id=1 lock in share mode </span></span>\n<span class="line"><span>(X锁 排他锁)： select * from t where id=1 for update</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>当前读</code>: 读取当前最新的记录。update、insert、delete语句、加锁的select语句</p></li><li><p><code>快照读</code>: 读取<strong>可见的</strong>快照的记录。仅普通select语句</p></li><li><p><code>一致性读</code>：当一个事务进行一致性读时，它实际上是在读取这个事务的一致性视图</p></li><li><p><code>next-key lock</code>：间隙锁+记录锁，解决<code>RR隔离级别</code>下，使用<code>当前读</code>时的幻读问题</p><ol><li>select * from x where id &gt; 2 for update;</li><li>事务A会加上一个(2,+∞]的next-key lock，阻塞其他事务向此区间写入数据</li><li>事务B会申请一个插入意向锁，等待A提交后再执行 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2915add2219a64344c7c03b7ab465176.png" alt="Img" loading="lazy"></li></ol></li><li><p>插入意向锁：</p></li><li><p>无法避免的幻读：</p><ol><li>事务A先使用快照读，事务B插入/删除记录，事务A使用当前读，则会发生幻读 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d3058b229ca766151727fc4d91b659ef.png" alt="Img" loading="lazy"></li><li>从业务上避免的措施： 尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，对记录加 next-key lock，从而避免其他事务插入一条新记录</li></ol></li></ol>',20)]))}]]),c=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html","title":"03.事务隔离级别","lang":"zh-CN","frontmatter":{"title":"03.事务隔离级别","date":"2025-06-17T15:20:49.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","事务隔离级别"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"事务： 事务：就是要保证一组数据库操作，要么全部成功，要么全部失败 事务的特性：ACID，原子性、一致性、隔离性、持久性 mysql事务是由引擎提供的支持，MyISAM 引擎就不支持事务 多事务同时执行可能会出现的问题：脏写、脏读、不可重复读、幻读 脏读：在一个事务内读到了另一个未提交事务修改过的数据 不可重复读：在一个事务内多次读取同一个数据，由于其...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"03.事务隔离级别"}],["meta",{"property":"og:description","content":"事务： 事务：就是要保证一组数据库操作，要么全部成功，要么全部失败 事务的特性：ACID，原子性、一致性、隔离性、持久性 mysql事务是由引擎提供的支持，MyISAM 引擎就不支持事务 多事务同时执行可能会出现的问题：脏写、脏读、不可重复读、幻读 脏读：在一个事务内读到了另一个未提交事务修改过的数据 不可重复读：在一个事务内多次读取同一个数据，由于其..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0731afc4e43cad83d232b2288fc7f617.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"事务隔离级别"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:20:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03.事务隔离级别\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0731afc4e43cad83d232b2288fc7f617.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e6ecdc4a33cca95933dd3c9297c3d922.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/19ca945285325f47a4f18afff70a1172.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3a41b1249a0dbf94211f925119fd9233.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e366827a5a711a60898c2c1fa7934661.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2915add2219a64344c7c03b7ab465176.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d3058b229ca766151727fc4d91b659ef.png\\"],\\"datePublished\\":\\"2025-06-17T15:20:49.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":8.08,"words":2423},"filePathRelative":"常用软件/数据库/mysql/03.事务隔离级别.md","localizedDate":"2025年6月17日","excerpt":"<h3>事务：</h3>\\n<ul>\\n<li>事务：就是要保证一组数据库操作，要么全部成功，要么全部失败</li>\\n<li>事务的特性：ACID，原子性、一致性、隔离性、持久性</li>\\n<li><strong>mysql事务是由引擎提供的支持</strong>，MyISAM 引擎就不支持事务</li>\\n<li>多事务同时执行可能会出现的问题：脏写、脏读、不可重复读、幻读\\n<ul>\\n<li>脏读：在一个事务内读到了另一个未提交事务修改过的数据</li>\\n<li>不可重复读：在一个事务内多次读取同一个<code>数据</code>，<strong>由于其他事务的提交</strong>，导致出现前后两次读到的<code>数据</code>不一样的情况</li>\\n<li>幻读：在一个事务内多次查询某个符合查询条件的<code>记录数量</code>，<strong>由于其他事务的提交</strong>，出现前后两次查询到的<code>记录数量</code>不一样的情况</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},36995:(i,e)=>{e.A=(i,e)=>{const l=i.__vccOpts||i;for(const[i,t]of e)l[i]=t;return l}}}]);
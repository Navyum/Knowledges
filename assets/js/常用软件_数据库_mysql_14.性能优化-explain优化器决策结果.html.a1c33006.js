"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[11216],{36995:(e,t)=>{t.A=(e,t)=>{const l=e.__vccOpts||e;for(const[e,s]of t)l[e]=s;return l}},97764:(e,t,l)=>{l.r(t),l.d(t,{comp:()=>d,data:()=>a});var s=l(6254);const n={},d=(0,l(36995).A)(n,[["render",function(e,t){return(0,s.uX)(),(0,s.CE)("div",null,t[0]||(t[0]=[(0,s.Fv)('<h3 id="explain结果列说明" tabindex="-1"><a class="header-anchor" href="#explain结果列说明"><span>explain结果列说明：</span></a></h3><table><thead><tr><th style="text-align:left;"><code>explain</code> 列名</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">id</td><td style="text-align:left;">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td></tr><tr><td style="text-align:left;"><code>select_type</code></td><td style="text-align:left;">SELECT关键字对应的那个查询的类型</td></tr><tr><td style="text-align:left;">table</td><td style="text-align:left;">表名</td></tr><tr><td style="text-align:left;">partitions</td><td style="text-align:left;">匹配的分区信息</td></tr><tr><td style="text-align:left;"><code>type</code></td><td style="text-align:left;">针对单表的访问方法</td></tr><tr><td style="text-align:left;">possible_keys</td><td style="text-align:left;">可能用到的索引</td></tr><tr><td style="text-align:left;">key</td><td style="text-align:left;">实际上使用的索引</td></tr><tr><td style="text-align:left;"><code>key_len</code></td><td style="text-align:left;">实际使用到的索引长度</td></tr><tr><td style="text-align:left;">ref</td><td style="text-align:left;">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td style="text-align:left;">rows</td><td style="text-align:left;">预估的需要读取的记录条数</td></tr><tr><td style="text-align:left;">filtered</td><td style="text-align:left;">某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td style="text-align:left;"><code>Extra</code></td><td style="text-align:left;">一些额外的信息</td></tr></tbody></table><h3 id="case" tabindex="-1"><a class="header-anchor" href="#case"><span>case：</span></a></h3><ol><li><code>普通查询</code>中，每出现一个<code>SELECT</code>关键字，就会分配一个唯一的<code>id</code>值</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#39;a&#39;;</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span>\n<span class="line"><span>| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span>\n<span class="line"><span>|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span>\n<span class="line"><span>1 row in set, 1 warning (0.03 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><code>连接查询</code>，一个select关键字后边的from子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span>\n<span class="line"><span>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span>\n<span class="line"><span>|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span></span>\n<span class="line"><span>|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span>\n<span class="line"><span>2 rows in set, 1 warning (0.01 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><code>子查询</code>，可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#39;a&#39;;</span></span>\n<span class="line"><span>+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span>\n<span class="line"><span>| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span>\n<span class="line"><span>|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span></span>\n<span class="line"><span>|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span>\n<span class="line"><span>2 rows in set, 1 warning (0.02 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><code>子查询重写变成连接查询</code>,查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#39;a&#39;);</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span></span>\n<span class="line"><span>| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span></span>\n<span class="line"><span>|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span></span>\n<span class="line"><span>|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span></span>\n<span class="line"><span>2 rows in set, 1 warning (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><code>UNION</code>子句的查询语句, 会多出一个临时表记录用来做去重逻辑</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;</span></span>\n<span class="line"><span>+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span>\n<span class="line"><span>| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span></span>\n<span class="line"><span>+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span>\n<span class="line"><span>|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |</span></span>\n<span class="line"><span>|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |</span></span>\n<span class="line"><span>| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span></span>\n<span class="line"><span>+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span>\n<span class="line"><span>3 rows in set, 1 warning (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li><code>UNION ALL</code>就不需要为最终的结果集进行去重，所以没有临时表</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span>\n<span class="line"><span>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span>\n<span class="line"><span>|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span></span>\n<span class="line"><span>|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL  |</span></span>\n<span class="line"><span>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span>\n<span class="line"><span>2 rows in set, 1 warning (0.01 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="select-type枚举" tabindex="-1"><a class="header-anchor" href="#select-type枚举"><span>select_type枚举:</span></a></h3><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">SIMPLE</td><td style="text-align:left;">查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型</td></tr><tr><td style="text-align:left;">PRIMARY</td><td style="text-align:left;">对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code></td></tr><tr><td style="text-align:left;">UNION</td><td style="text-align:left;">对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询，除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code></td></tr><tr><td style="text-align:left;">UNION RESULT</td><td style="text-align:left;"><code>UNION</code>查询的去重工作中使用到的临时表的查询</td></tr><tr><td style="text-align:left;">SUBQUERY</td><td style="text-align:left;">如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code></td></tr><tr><td style="text-align:left;">DEPENDENT SUBQUERY</td><td style="text-align:left;">如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code></td></tr><tr><td style="text-align:left;">DEPENDENT UNION</td><td style="text-align:left;">在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code></td></tr><tr><td style="text-align:left;">DERIVED</td><td style="text-align:left;">对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code></td></tr><tr><td style="text-align:left;">MATERIALIZED</td><td style="text-align:left;">当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code></td></tr><tr><td style="text-align:left;">UNCACHEABLE SUBQUERY</td><td style="text-align:left;">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td style="text-align:left;">UNCACHEABLE UNION</td><td style="text-align:left;">The second or later select in a UN´ION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><h3 id="type-枚举" tabindex="-1"><a class="header-anchor" href="#type-枚举"><span>type 枚举:</span></a></h3><table><thead><tr><th style="text-align:left;">枚举值</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">system</td><td style="text-align:left;">当表中<code>只有一条记录</code>并且是 <code>MyISAM、Memory</code>引擎</td></tr><tr><td style="text-align:left;"><code>const</code></td><td style="text-align:left;">根据<code>主键索引列</code>或者<code>唯一二级索引列</code>与<code>常量</code>进行<code>等值匹配</code>的方法</td></tr><tr><td style="text-align:left;">eq_ref</td><td style="text-align:left;"><code>在连接查询</code>时，<code>被驱动表</code>通过<code>主键</code>或者<code>唯一二级索引列</code>进行等值匹配的方法</td></tr><tr><td style="text-align:left;"><code>ref</code></td><td style="text-align:left;"><code>普通二级索引列</code>与<code>常量</code>进行<code>等值匹配</code>查询某个表时，<code>可能</code>是ref</td></tr><tr><td style="text-align:left;">fulltext</td><td style="text-align:left;">全文索引</td></tr><tr><td style="text-align:left;">ref_or_null</td><td style="text-align:left;"><code>普通二级索引</code>与<code>常量</code>进行<code>等值匹配</code>查询某个表，且该索引列的值也可以是<code>NULL</code>值</td></tr><tr><td style="text-align:left;">index_merge</td><td style="text-align:left;">使用<code>索引合并</code>的方式来执行查询</td></tr><tr><td style="text-align:left;">unique_subquery</td><td style="text-align:left;">查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，且<code>子查询</code>可以使用到<code>主键</code>进行<code>等值匹配</code></td></tr><tr><td style="text-align:left;">index_subquery</td><td style="text-align:left;">同unique_subquery, 只不过<code>子查询</code>中的表时使用<code>普通的索引</code>进行<code>等值匹配</code></td></tr><tr><td style="text-align:left;"><code>range</code></td><td style="text-align:left;">使用<code>索引</code>获取某些<code>范围区间</code>的记录</td></tr><tr><td style="text-align:left;"><code>index</code></td><td style="text-align:left;">使用<code>覆盖索引</code>, 但需要扫描全部的索引记录的方法</td></tr><tr><td style="text-align:left;"><code>ALL</code></td><td style="text-align:left;"><code>全表扫描</code></td></tr></tbody></table><h3 id="possible-keys和key" tabindex="-1"><a class="header-anchor" href="#possible-keys和key"><span>possible_keys和key:</span></a></h3><p><code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些 注意：<code>possible_keys</code>越多，查询优化器计算查询成本时就得花费更长时间</p><h3 id="key-len" tabindex="-1"><a class="header-anchor" href="#key-len"><span>key_len：</span></a></h3><ul><li><code>key_len</code>: 表示当优化器决定使用某个索引执行查询时，该索引记录的最大字节长度，单位：<code>字节</code></li><li>计算规则： <ol><li>固定长度类型的索引列: <ul><li>实际占用的存储空间的最大长度就是该固定值</li><li>e.g. <code>CAHR(M)</code> <code>ASCII字符集</code></li><li>计算：<code>key_len</code> = M * 1</li></ul></li><li>可变长度字符集、可变长类型的索引列： <ul><li>需要考虑 <code>字符集</code>、<code>索引列字符个数</code>、<code>NUll值列表</code>、<code>变长字段长度列表</code></li><li>e.g. <code>VARCHAR(100)</code> <code>utf8字符集</code><ol><li>该列实际占用的最大存储空间： <code>100 × 3 = 300</code>个字节</li><li>NUll值列表：1字节（一般来说索引为NOT NULL, 则不会有这1字节开销）</li><li>变长字段长度列表：2字节</li><li>计算： <code>key_len</code> = 300 + 1 + 2</li></ol></li></ul></li></ol></li><li>作用： <ul><li>判断当使用了联合索引列的情况下，具体用到了几列</li></ul></li></ul><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>ref：</span></a></h3><table><thead><tr><th style="text-align:left;">枚举值</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>const</code></td><td style="text-align:left;">常量等值匹配； e.g. ... = 1</td></tr><tr><td style="text-align:left;"><code>func</code></td><td style="text-align:left;">函数等值匹配； e.g. ... = UPPER(s1.key1)</td></tr><tr><td style="text-align:left;"><code>某个字段</code></td><td style="text-align:left;">字段等值匹配,会把库名也打印出； e.g. ... = s1.key1</td></tr></tbody></table><p>当使用索引列等值匹配的条件去执行查询时(访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>之一)，<code>ref</code>列展示的就是与索引列作等值匹配具体内容，比如只是一个常数<code>CONST</code>或者是某个列<code>t.id</code></p><h3 id="rows" tabindex="-1"><a class="header-anchor" href="#rows"><span>rows：</span></a></h3><ul><li>作用：查询优化器给出的<code>预计</code>需要扫描的行数，<code>预估值</code>非精确值</li><li>场景： <ol><li>如果查询优化器决定使用全表扫描执行查询时，<code>rows</code>列就代表<code>预计需要扫描的行数</code></li><li>如果查询优化器决定使用索引查询时，<code>rows</code>列就代表<code>预计扫描的索引记录行数</code></li></ol></li></ul><h3 id="filtered" tabindex="-1"><a class="header-anchor" href="#filtered"><span>filtered:</span></a></h3><ul><li>作用：评估连表查询时，<code>驱动表</code>的扇出情况。扇出值表示驱动表符合条件的记录数n，在被驱动表中还需要n次查询</li><li>扇出值 = Rows * filtered</li><li>使用说明： <ol><li>单表查询： <ol><li>全表扫描：<code>filtered</code>列就代表查询优化器预测在这rows条记录中，满足全部搜索条件的比例</li><li>索引：<code>filtered</code>列就代表查询优化器预测在这rows条记录中，满足除使用到对应索引的搜索条件外，满足剩余搜索条件的比例</li></ol></li><li>连表查询： 含义：扇出值：n = rows * filtered。在对驱动表一次访问之后（需要扫描rows条记录），对被驱动表执行大约n次查询</li></ol></li></ul><h3 id="extra" tabindex="-1"><a class="header-anchor" href="#extra"><span>Extra：</span></a></h3><p>|常见的枚举值|描述|是否互斥| |:----|:----| | <code>Using index</code> | 使用索引覆盖的特性，即无需回表 |是| | <code>Using index condition</code> | 使用索引下推的特性，减少回表次数。（使用索引扫描出部分条件的结果，然后将这写临时结果再进行剩余条件匹配，最后再回表） |是| |<code>Using where</code> | 1.全表扫描且条件匹配 2. 使用到索引搜索，且剩余的条件判断无法通过索引覆盖、索引下推进行优化，必须直接回表 |是| |<code>Using filesort</code> | 使用了文件排序。无法通过索引排序得到结果集，必须通过内存排序、磁盘排序才能得到结果|否| |<code>Using temporary</code> | 使用了临时表来排序、去重、分组。无法通过索引排序得到结果集，通过建立内部的临时表来执行|否| |Using join buffer (Block Nested Loop)|连接查询执行过程中，<code>被驱动表``不能利用索引</code>,则会分配<code>基于块的嵌套循环算法</code>的内存|是| |Using intersect(...) |使用<code>Intersect</code>索引合并的方式执行查询|是| |Using union(...) |使用<code>Union</code>索引合并的方式执行查询|是| |Using sort_union(...) |使用<code>Sort-Union</code>索引合并的方式执行查询|是|</p>',32)]))}]]),a=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/14.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-explain%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E7%BB%93%E6%9E%9C.html","title":"14.性能优化-explain优化器决策结果","lang":"zh-CN","frontmatter":{"title":"14.性能优化-explain优化器决策结果","date":"2025-06-17T15:22:00.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","explain","性能优化"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"explain结果列说明： case： 普通查询中，每出现一个SELECT关键字，就会分配一个唯一的id值 连接查询，一个select关键字后边的from子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的 子查询，可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELEC...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/14.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-explain%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E7%BB%93%E6%9E%9C.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"14.性能优化-explain优化器决策结果"}],["meta",{"property":"og:description","content":"explain结果列说明： case： 普通查询中，每出现一个SELECT关键字，就会分配一个唯一的id值 连接查询，一个select关键字后边的from子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的 子查询，可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELEC..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"explain"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:22:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14.性能优化-explain优化器决策结果\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:22:00.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":8.58,"words":2574},"filePathRelative":"常用软件/数据库/mysql/14.性能优化-explain优化器决策结果.md","localizedDate":"2025年6月17日","excerpt":"<h3>explain结果列说明：</h3>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:left\\"><code>explain</code> 列名</th>\\n<th style=\\"text-align:left\\">描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:left\\">id</td>\\n<td style=\\"text-align:left\\">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>select_type</code></td>\\n<td style=\\"text-align:left\\">SELECT关键字对应的那个查询的类型</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">table</td>\\n<td style=\\"text-align:left\\">表名</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">partitions</td>\\n<td style=\\"text-align:left\\">匹配的分区信息</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>type</code></td>\\n<td style=\\"text-align:left\\">针对单表的访问方法</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">possible_keys</td>\\n<td style=\\"text-align:left\\">可能用到的索引</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">key</td>\\n<td style=\\"text-align:left\\">实际上使用的索引</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>key_len</code></td>\\n<td style=\\"text-align:left\\">实际使用到的索引长度</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">ref</td>\\n<td style=\\"text-align:left\\">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">rows</td>\\n<td style=\\"text-align:left\\">预估的需要读取的记录条数</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">filtered</td>\\n<td style=\\"text-align:left\\">某个表经过搜索条件过滤后剩余记录条数的百分比</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"><code>Extra</code></td>\\n<td style=\\"text-align:left\\">一些额外的信息</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')}}]);
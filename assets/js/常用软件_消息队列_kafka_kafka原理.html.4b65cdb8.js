"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[11066],{36995:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,t]of a)i[e]=t;return i}},39822:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>o,data:()=>l});var t=i(6254);const n={},o=(0,i(36995).A)(n,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,a[0]||(a[0]=[(0,t.Fv)('<h3 id="整体架构" tabindex="-1"><a class="header-anchor" href="#整体架构"><span>整体架构：</span></a></h3><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/09d7819af5b62fff56e36721d01d7c4f.png" width="60%"><h3 id="高性能" tabindex="-1"><a class="header-anchor" href="#高性能"><span>高性能：</span></a></h3><h4 id="减少资源竞争" tabindex="-1"><a class="header-anchor" href="#减少资源竞争"><span>减少资源竞争：</span></a></h4><ul><li>将消息按照业务拆分到多个<code>topic</code>。减少生产者和消费者对topic的读、写竞争</li><li>将topic再拆分为多个<code>partition</code>。每个消费者负责一个partition <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f8284857339d397d22154713ddd2a9ae.png" width="60%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4e5f3f34a51e479142bca13f96b9c579.png" width="60%"></li></ul><h4 id="使用的高性能技术" tabindex="-1"><a class="header-anchor" href="#使用的高性能技术"><span>使用的高性能技术：</span></a></h4><ul><li>PageCache 内核缓冲区</li><li>磁盘顺序写</li><li>零拷技术</li><li>批量处理</li><li>拉模式消费消息，由消费者自行控制</li></ul><h3 id="扩展性" tabindex="-1"><a class="header-anchor" href="#扩展性"><span>扩展性：</span></a></h3><ul><li>横向扩展，从单个<code>broker</code>变成多个，提高CPU、内存上限</li><li>如何拆分？ <ul><li>kafka 按照partition粒度，将topic对应的多个partition分散到多个broker中</li><li>这样一个broker拥有多个topic的部分partition数据</li><li><strong>存疑？kafka集群的扩容如何进行？</strong><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2f88899b52b6ed6dc5ae53e81de587b8.png" width="60%"></li></ul></li></ul><h3 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用"><span>高可用：</span></a></h3><ul><li>kafka使用replication机制，按照partition粒度，设置replicas副本，这样 partition 就有了主、从的职责区分</li><li>Leader负责应付生产者和消费者的<code>读写请求</code>，而Follower只管同步Leader的消息，做数据备份</li><li>如何做故障转移： <ul><li>将Leader partition 和 Follower partition分散到不同的broker中</li><li>某个broker故障时，通过zookeeper进行协商出新的Leader partition，实现故障转移 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ec462fd29aa03e8143bc24d8dcd21f8b.png" width="60%"></li></ul></li></ul><h3 id="持久化、过期策略" tabindex="-1"><a class="header-anchor" href="#持久化、过期策略"><span>持久化、过期策略：</span></a></h3><ul><li>持久化：将内存中的数据存到磁盘</li><li>过期：</li><li>写入过程： <ul><li>生产者决定数据产生到集群的哪个 partition 中</li><li>每一条消息都是以（key， value）格式，Key 是由生产者发送数据传入，同一个 key 的消息可以保证只发送到同一个 partition</li></ul></li><li>** 如何持久化**：</li><li>** 如何做主从同步**：</li><li>物理存储： <ul><li><code>Topic</code>中的多个 partition 以<code>文件夹</code>的形式保存，序号从0递增</li><li>消息有序写入Segment（段）文件</li><li><code>Partition</code>文件下有多个segment（xxx.index，xxx.log）</li><li><code>Segment</code>大小固定，写满时滚动写入新Segment，新Segment按照最后一条消息的偏移量命名</li><li>&lt;topic_name&gt;/&lt;partition_id&gt;/&lt;segment_id&gt;</li></ul></li></ul><h3 id="消费者组" tabindex="-1"><a class="header-anchor" href="#消费者组"><span>消费者组：</span></a></h3><ul><li>同组内如何消费： <ul><li>组内的消费者与topic的某个partition绑定消费</li><li>消费者消费时，通过offset偏移进行消费位置的定位</li></ul></li><li>组件如何消费： <ul><li>组与组之间的消费互不影响，新加的组可以从头开始消费 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6502720c0591ca52d8decde6e0db329f.png" width="60%"></li></ul></li></ul><h3 id="消息的有序消费" tabindex="-1"><a class="header-anchor" href="#消息的有序消费"><span>消息的有序消费：</span></a></h3><ul><li>方式1：设置1个Topic只对应1个Partition。并发能力变差。</li><li>方式2：指定消息对应的<code>topic</code>, <code>partition</code>, <code>key</code>, <code>data</code>（数据）4 个参数中的前三个一致</li></ul><h3 id="消息的不丢失-ack" tabindex="-1"><a class="header-anchor" href="#消息的不丢失-ack"><span>消息的不丢失：ACK</span></a></h3><ul><li>生产者 -&gt; kafka：因为send是异步的，消息send之后，生产者通过get获取消息状态</li><li>kafka -&gt; 消费者：关闭消费者的自动提交offset，在消费后主动提交offset</li></ul><h3 id="分布式协商组件zookeeper" tabindex="-1"><a class="header-anchor" href="#分布式协商组件zookeeper"><span>分布式协商组件zookeeper：</span></a></h3><ul><li>zookeeper 负责管理 broker、partition等组件状态信息</li><li>定期和broker通信，获取整个kafka集群的状态</li><li>进行Leader选举 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/5767625df0abde9c4e8277f158e8f23d.png" width="60%"></li></ul>',21)]))}]]),l=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/kafka%E5%8E%9F%E7%90%86.html","title":"kafka原理","lang":"zh-CN","frontmatter":{"title":"kafka原理","date":"2025-06-17T15:16:07.000Z","author":"Navyum","tags":["kafka"],"categories":["消息队列","常用软件"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"icon":"logos:kafka-icon","description":"整体架构： 高性能： 减少资源竞争： 将消息按照业务拆分到多个topic。减少生产者和消费者对topic的读、写竞争 将topic再拆分为多个partition。每个消费者负责一个partition 使用的高性能技术： PageCache 内核缓冲区 磁盘顺序写 零拷技术 批量处理 拉模式消费消息，由消费者自行控制 扩展性： 横向扩展，从单个broke...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/kafka%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"kafka原理"}],["meta",{"property":"og:description","content":"整体架构： 高性能： 减少资源竞争： 将消息按照业务拆分到多个topic。减少生产者和消费者对topic的读、写竞争 将topic再拆分为多个partition。每个消费者负责一个partition 使用的高性能技术： PageCache 内核缓冲区 磁盘顺序写 零拷技术 批量处理 拉模式消费消息，由消费者自行控制 扩展性： 横向扩展，从单个broke..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-24T03:13:58.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"kafka"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:16:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-24T03:13:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"kafka原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:16:07.000Z\\",\\"dateModified\\":\\"2025-06-24T03:13:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750734838000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.6,"words":779},"filePathRelative":"常用软件/消息队列/kafka/kafka原理.md","localizedDate":"2025年6月17日","excerpt":"<h3>整体架构：</h3>\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/09d7819af5b62fff56e36721d01d7c4f.png\\" width=\\"60%\\">\\n<h3>高性能：</h3>\\n<h4>减少资源竞争：</h4>\\n<ul>\\n<li>将消息按照业务拆分到多个<code>topic</code>。减少生产者和消费者对topic的读、写竞争</li>\\n<li>将topic再拆分为多个<code>partition</code>。每个消费者负责一个partition\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f8284857339d397d22154713ddd2a9ae.png\\" width=\\"60%\\">\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4e5f3f34a51e479142bca13f96b9c579.png\\" width=\\"60%\\"></li>\\n</ul>","autoDesc":true}')}}]);
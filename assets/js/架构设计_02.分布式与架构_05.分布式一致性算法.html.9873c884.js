"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[13105],{11490:(a,e,l)=>{l.r(e),l.d(e,{comp:()=>t,data:()=>r});var i=l(6254);const n={},t=(0,l(36995).A)(n,[["render",function(a,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h1 id="_05-分布式一致性算法" tabindex="-1"><a class="header-anchor" href="#_05-分布式一致性算法"><span>05.分布式一致性算法</span></a></h1><h2 id="分布式一致性" tabindex="-1"><a class="header-anchor" href="#分布式一致性"><span>分布式一致性：</span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义：</span></a></h3><ul><li>分布式一致性是指在分布式系统中，确保所有节点对数据的视图是一致的，即所有节点在某个时间点上看到的数据状态是一致的。</li><li>分布式系统的核心目标：确保所有节点的数据和状态一致</li></ul><h3 id="强一致性" tabindex="-1"><a class="header-anchor" href="#强一致性"><span>强一致性：</span></a></h3><ul><li>所有读操作都能看到最新的写操作结果</li><li>强一致性模型： <ul><li>线性一致性</li><li>顺序一致性</li></ul></li></ul><h3 id="弱一致性" tabindex="-1"><a class="header-anchor" href="#弱一致性"><span>弱一致性：</span></a></h3><ul><li>读操作可能不会立即看到最新的写操作结果</li><li>弱一致性模型： <ul><li>最终一致性</li><li>会话一致性</li></ul></li></ul><h2 id="分布式一致性算法" tabindex="-1"><a class="header-anchor" href="#分布式一致性算法"><span>分布式一致性算法：</span></a></h2><ul><li>它们主要关注的是数据的一致性，即所有节点在任何时刻看到的数据都是一致的</li></ul><h2 id="gossip-协议-一种去中心化的通信协议" tabindex="-1"><a class="header-anchor" href="#gossip-协议-一种去中心化的通信协议"><span>Gossip 协议：（一种去中心化的通信协议）</span></a></h2><h3 id="具体应用场景" tabindex="-1"><a class="header-anchor" href="#具体应用场景"><span>具体应用场景：</span></a></h3><ul><li>Amazon Dynamo、zookeeper、Consul、Kafka-KRaft</li></ul><h3 id="核心" tabindex="-1"><a class="header-anchor" href="#核心"><span>核心：</span></a></h3><ul><li>像流言蜚语一样，<code>利用一种随机、带有传染性的方式</code>，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致</li></ul><h3 id="直接邮寄-direct-mail" tabindex="-1"><a class="header-anchor" href="#直接邮寄-direct-mail"><span>直接邮寄（Direct Mail）</span></a></h3><ul><li>实现：直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传</li><li>优点： <ul><li>数据变更时，同步及时</li></ul></li><li>难点： <ul><li>失败需要缓存数据，进而会丢数据</li></ul></li></ul><h3 id="反熵-anti-entropy" tabindex="-1"><a class="header-anchor" href="#反熵-anti-entropy"><span>反熵（Anti-entropy）</span></a></h3><ul><li>核心：通过<code>异步修复</code>实现最终一致性的方法。</li><li>实现：集群中的节点，每隔段时间就随机选择某个其他节点，然后<code>通过互相交换自己的所有数据</code>来<code>消除两者之间的差异</code>实现反熵</li><li>数据交换方式： <ul><li>推：将自己的<code>所有副本数据</code>推给对方，修复对方数据</li><li>拉：拉取对方的<code>所有副本数据</code>，修复自己数据</li><li>推拉：即推自己数据、也拉对方数据，同时修复自己数据和对方数据</li></ul></li><li>缺点： <ul><li>通信成本极高，因为要传输完整副本数据</li></ul></li><li>局限性： <ul><li>相关的节点需要互相已知</li><li>节点不能频繁动态变化</li><li>节点过多的分布式环境</li></ul></li><li>数据修复的具体实现： <ul><li>按照一定顺序来修复节点的数据差异，实现闭环（顺时针或逆时针）</li><li>先随机选择一个节点，然后循环修复，每个节点生成自己节点有、下一个节点没有的差异数据，发送给下一个节点，进行修复</li><li>A修复B，B修复C，C修复A，A再次修复B</li><li>通过闭环方式，这样可以在某个时间范围内达到最终一致；如果采用节点随机修复，则只是理论最终一致，所需时间变成随机 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/996af1b3c21bbe04c2d5929af3f94bec.png" width="40%"></li></ul></li></ul><h3 id="谣言传播" tabindex="-1"><a class="header-anchor" href="#谣言传播"><span>谣言传播</span></a></h3><ul><li>核心：当一个节点收到新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据(A-&gt;B;B-&gt;C,B-&gt;D,...)</li><li>适用：谣言传播非常具有传染性，它适合动态变化的分布式系统</li></ul><h2 id="quorum-nwr-算法-灵活地制定一致性的级别的算法" tabindex="-1"><a class="header-anchor" href="#quorum-nwr-算法-灵活地制定一致性的级别的算法"><span>Quorum NWR 算法：（灵活地制定一致性的级别的算法）</span></a></h2><h3 id="具体应用场景-1" tabindex="-1"><a class="header-anchor" href="#具体应用场景-1"><span>具体应用场景：</span></a></h3><ul><li>通过多数优先，灵活地制定一致性的级别</li><li>能有效弥补 <code>AP</code> 型系统缺乏<code>强一致性</code>的痛点，给业务提供了<code>按需选择一致性级别</code>的灵活度</li></ul><h3 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想：</span></a></h3><ul><li>通过 Quorum NWR，你可以自定义一致性级别。通过临时调整写入或者查询的方式，当 W + R &gt; N 时，就可以实现强一致性。</li></ul><h3 id="quorum-nwr-的三要素" tabindex="-1"><a class="header-anchor" href="#quorum-nwr-的三要素"><span>Quorum NWR 的三要素：</span></a></h3><ul><li>N，表示副本数，集群中<code>同一份数据有多少个副本</code>。又叫做复制因子（Replication Factor）。 <ul><li>副本数可以不等于节点数，不同的数据可以有不同的副本数</li></ul></li><li>W，又称写一致性级别（Write Consistency Level），<code>表示成功完成W个副本更新，才算成功完成写操作</code></li><li>R，又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读R个副本。（读取指定数据时，要读R副本，然后返回R个副本中<code>最新的那份数据</code>）</li></ul><h3 id="nwr的组合" tabindex="-1"><a class="header-anchor" href="#nwr的组合"><span>NWR的组合：</span></a></h3><ul><li>当 W + R &gt; N 的时候，对于客户端来讲，整个系统能保证强一致性，一定能返回更新后的那份数据。</li><li>当 W + R &lt;= N 的时候，对于客户端来讲，整个系统只能保证最终一致性，可能会返回旧数据。</li></ul><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例：</span></a></h3><ul><li>W(2) + R(2) &gt; N(3)</li><li>数据有3个副本，每次写入2个副本才成功，每次读都需要读任意两个副本的最新数据。此时读到的数据一定是最新的数据。</li></ul><h3 id="副本和节点的关系" tabindex="-1"><a class="header-anchor" href="#副本和节点的关系"><span>副本和节点的关系：</span></a></h3><ul><li>副本数一般不能超过节点数据</li><li>解释：多副本的意义在于冗余备份。如果副本数超过节点数，则一个节点上会存在多个相同副本。对于这个节点的冗余来说，这个就没意义。</li></ul><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4c8e36db927652db679d0eafcb8b9aa2.png" width="40%"><h2 id="分布式容错算法" tabindex="-1"><a class="header-anchor" href="#分布式容错算法"><span>分布式容错算法：</span></a></h2><h3 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1"><span>定义：</span></a></h3><ul><li>分布式容错算法是用于确保分布式系统在部分节点发生故障时，仍能保持数据的一致性和服务的可用性的方法</li><li>分布式容错算法是分布式系统实现高可用性和可靠性的基础</li><li>分布式协调服务和共识算法通常会结合容错算法来处理<code>节点故障</code>和<code>网络分区</code>等问题</li></ul><h3 id="常用算法" tabindex="-1"><a class="header-anchor" href="#常用算法"><span>常用算法：</span></a></h3><h4 id="复制-副本-从库" tabindex="-1"><a class="header-anchor" href="#复制-副本-从库"><span>复制/副本/从库：</span></a></h4><ul><li>将数据复制到多个节点，以便在某个节点故障时仍能访问数据</li></ul><h4 id="数据分片" tabindex="-1"><a class="header-anchor" href="#数据分片"><span>数据分片：</span></a></h4><ul><li>将数据分布到多个节点上，减少单点故障的影响</li></ul><hr><h2 id="分布式共识算法" tabindex="-1"><a class="header-anchor" href="#分布式共识算法"><span>分布式共识算法：</span></a></h2><ul><li>它们主要关注的是在存在部分节点故障或网络分区的情况下，确保系统对某个值或者决策能够<code>达成一致的决策</code></li></ul><h3 id="定义-2" tabindex="-1"><a class="header-anchor" href="#定义-2"><span>定义：</span></a></h3><ul><li>分布式共识算法是用于在分布式系统中<code>多个节点对某个值或决策达成一致的算法</code>，从而保证数据的一致性</li></ul><h3 id="常用算法-1" tabindex="-1"><a class="header-anchor" href="#常用算法-1"><span>常用算法：</span></a></h3><h4 id="paxos" tabindex="-1"><a class="header-anchor" href="#paxos"><span><code>Paxos</code>：</span></a></h4><ul><li>基于<code>多轮投票机制</code>，确保分布式系统中的数据一致性。主要关注理论上的一致性保证，设计较为复杂。</li><li>实际应用中通常使用其变种（如Multi-Paxos）来简化实现</li><li>Paxos和Raft都依赖于多数派原则，即在多数节点达成一致的情况下，整个系统认为达成了一致</li></ul><h4 id="raft" tabindex="-1"><a class="header-anchor" href="#raft"><span><code>Raft</code>：</span></a></h4><ul><li>通过<code>领导者选举</code>和<code>日志复制</code>，提供简化和易于理解的一致性保证。</li><li>Paxos和Raft都依赖于多数派原则，即在多数节点达成一致的情况下，整个系统认为达成了一致</li></ul><h4 id="zab-zookeeper-atomic-broadcast" tabindex="-1"><a class="header-anchor" href="#zab-zookeeper-atomic-broadcast"><span><code>ZAB</code>（ZooKeeper Atomic Broadcast）：</span></a></h4><ul><li>专为ZooKeeper设计的原子广播协议，确保分布式协调服务中的数据一致性</li><li>通过<code>领导者选举</code>和<code>事务广播机制</code>，专门为ZooKeeper设计</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景：</span></a></h3><ul><li>分布式数据库的<code>主备同步</code></li><li>分布式文件系统的<code>元数据管理</code></li><li>分布式协调服务（如ZooKeeper、etcd）</li></ul>',57)]))}]]),r=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/05.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html","title":"05.分布式一致性算法","lang":"zh-CN","frontmatter":{"title":"05.分布式一致性算法","date":"2025-06-17T14:39:16.000Z","author":"Navyum","tags":["架构设计","一致性算法"],"categories":["分布式"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"description":"05.分布式一致性算法 分布式一致性： 定义： 分布式一致性是指在分布式系统中，确保所有节点对数据的视图是一致的，即所有节点在某个时间点上看到的数据状态是一致的。 分布式系统的核心目标：确保所有节点的数据和状态一致 强一致性： 所有读操作都能看到最新的写操作结果 强一致性模型： 线性一致性 顺序一致性 弱一致性： 读操作可能不会立即看到最新的写操作结果...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/05.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"05.分布式一致性算法"}],["meta",{"property":"og:description","content":"05.分布式一致性算法 分布式一致性： 定义： 分布式一致性是指在分布式系统中，确保所有节点对数据的视图是一致的，即所有节点在某个时间点上看到的数据状态是一致的。 分布式系统的核心目标：确保所有节点的数据和状态一致 强一致性： 所有读操作都能看到最新的写操作结果 强一致性模型： 线性一致性 顺序一致性 弱一致性： 读操作可能不会立即看到最新的写操作结果..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"架构设计"}],["meta",{"property":"article:tag","content":"一致性算法"}],["meta",{"property":"article:published_time","content":"2025-06-17T14:39:16.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"05.分布式一致性算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T14:39:16.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":6.29,"words":1888},"filePathRelative":"架构设计/02.分布式与架构/05.分布式一致性算法.md","localizedDate":"2025年6月17日","excerpt":"\\n<h2>分布式一致性：</h2>\\n<h3>定义：</h3>\\n<ul>\\n<li>分布式一致性是指在分布式系统中，确保所有节点对数据的视图是一致的，即所有节点在某个时间点上看到的数据状态是一致的。</li>\\n<li>分布式系统的核心目标：确保所有节点的数据和状态一致</li>\\n</ul>\\n<h3>强一致性：</h3>\\n<ul>\\n<li>所有读操作都能看到最新的写操作结果</li>\\n<li>强一致性模型：\\n<ul>\\n<li>线性一致性</li>\\n<li>顺序一致性</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>弱一致性：</h3>\\n<ul>\\n<li>读操作可能不会立即看到最新的写操作结果</li>\\n<li>弱一致性模型：\\n<ul>\\n<li>最终一致性</li>\\n<li>会话一致性</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},36995:(a,e)=>{e.A=(a,e)=>{const l=a.__vccOpts||a;for(const[a,i]of e)l[a]=i;return l}}}]);
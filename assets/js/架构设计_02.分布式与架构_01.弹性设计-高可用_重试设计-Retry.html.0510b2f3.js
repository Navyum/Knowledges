"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[5170],{36995:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,p]of t)i[e]=p;return i}},44360:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>r,data:()=>n});var p=i(6254);const l={},r=(0,i(36995).A)(l,[["render",function(e,t){return(0,p.uX)(),(0,p.CE)("div",null,t[0]||(t[0]=[(0,p.Fv)('<h1 id="重试设计-retry" tabindex="-1"><a class="header-anchor" href="#重试设计-retry"><span>重试设计-Retry</span></a></h1><p>定义：</p><pre><code> “重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。\n</code></pre><p>重试设计重点：</p><ul><li><p>确定重试场景，即什么样的错误下需要重试。 可重试：调用超时、返回已知的可以重试的错误（如繁忙中、流控中、维护中、资源不足等）</p><pre><code>不可重试：业务级错误，无权限等，技术级错误，bug，500\n</code></pre></li><li><p>重试的时间和重试的次数。即重试策略。 引入“指数级退避”策略，即每次重试，时间间隔成倍增加。类似：TCP拥塞控制</p></li><li><p>服务长期故障的处理。如果超过重试次数，或是重试时间，那么重试没有意义。触发熔断，对新请求直接返回错误直到服务恢复。</p></li><li><p>调用方需要做幂等设计，否则会不安全。</p></li><li><p>重试代码设计比较通用和简单。两种模式：<br> 1. java annotation 2. service mesh</p></li><li><p>对于有事务相关的操作，我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。此时需要保存上下文。 拓展：</p></li></ul><p>spring 重试策略：</p><ul><li><p>NeverRetryPolicy：只允许调用 RetryCallback 一次，不允许重试。</p></li><li><p>AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环。</p></li><li><p>SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为 3 次，RetryTemplate 默认使用的策略。</p></li><li><p>TimeoutRetryPolicy：超时时间重试策略，默认超时时间为 1 秒，在指定的超时时间内允许重试。</p></li><li><p>CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置 3 个参数 openTimeout、resetTimeout 和 delegate；关于熔断，会在后面描述。</p></li><li><p>CompositeRetryPolicy：组合重试策略。有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。但不管哪种组合方式，组合中的每一个策略都会执行。 backoff策略：</p></li><li><p>NoBackOffPolicy：无退避算法策略，即立即重试；</p></li><li><p>FixedBackOffPolicy：固定时间的退避策略，需设置参数 sleeper 和 backOffPeriod，sleeper 指定等待策略，默认是 Thread.sleep，即线程休眠，backOffPeriod 指定休眠时间，默认 1 秒。</p></li><li><p>UniformRandomBackOffPolicy：随机时间退避策略，需设置 sleeper、minBackOffPeriod 和 maxBackOffPeriod。该策略在[minBackOffPeriod, maxBackOffPeriod]之间取一个随机休眠时间，minBackOffPeriod 默认为 500 毫秒，maxBackOffPeriod 默认为 1500 毫秒。</p></li><li><p>ExponentialBackOffPolicy：指数退避策略，需设置参数 sleeper、initialInterval、maxInterval 和 multiplier。initialInterval 指定初始休眠时间，默认为 100 毫秒。maxInterval 指定最大休眠时间，默认为 30 秒。multiplier 指定乘数，即下一次休眠时间为当前休眠时间 *multiplier。</p></li><li><p>ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致 DDos，使用随机休眠时间来避免这种情况。</p></li></ul>',7)]))}]]),n=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1-Retry.html","title":"重试设计-Retry","lang":"zh-CN","frontmatter":{"description":"重试设计-Retry 定义： 重试设计重点： 确定重试场景，即什么样的错误下需要重试。 可重试：调用超时、返回已知的可以重试的错误（如繁忙中、流控中、维护中、资源不足等） 重试的时间和重试的次数。即重试策略。 引入“指数级退避”策略，即每次重试，时间间隔成倍增加。类似：TCP拥塞控制 服务长期故障的处理。如果超过重试次数，或是重试时间，那么重试没有意义...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1-Retry.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"重试设计-Retry"}],["meta",{"property":"og:description","content":"重试设计-Retry 定义： 重试设计重点： 确定重试场景，即什么样的错误下需要重试。 可重试：调用超时、返回已知的可以重试的错误（如繁忙中、流控中、维护中、资源不足等） 重试的时间和重试的次数。即重试策略。 引入“指数级退避”策略，即每次重试，时间间隔成倍增加。类似：TCP拥塞控制 服务长期故障的处理。如果超过重试次数，或是重试时间，那么重试没有意义..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-15T10:30:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-15T10:30:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"重试设计-Retry\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-15T10:30:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\",\\"url\\":\\"https://myblog.camscanner.top\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1749983452000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":2.51,"words":753},"filePathRelative":"架构设计/02.分布式与架构/01.弹性设计-高可用/重试设计-Retry.md","localizedDate":"2025年6月15日","excerpt":"\\n<p>定义：</p>\\n<pre><code> “重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。\\n</code></pre>\\n<p>重试设计重点：</p>\\n<ul>\\n<li>\\n<p>确定重试场景，即什么样的错误下需要重试。\\n可重试：调用超时、返回已知的可以重试的错误（如繁忙中、流控中、维护中、资源不足等）</p>\\n<pre><code>不可重试：业务级错误，无权限等，技术级错误，bug，500\\n</code></pre>\\n</li>\\n<li>\\n<p>重试的时间和重试的次数。即重试策略。\\n引入“指数级退避”策略，即每次重试，时间间隔成倍增加。类似：TCP拥塞控制</p>\\n</li>\\n<li>\\n<p>服务长期故障的处理。如果超过重试次数，或是重试时间，那么重试没有意义。触发熔断，对新请求直接返回错误直到服务恢复。</p>\\n</li>\\n<li>\\n<p>调用方需要做幂等设计，否则会不安全。</p>\\n</li>\\n<li>\\n<p>重试代码设计比较通用和简单。两种模式：<br>\\n1. java annotation 2. service mesh</p>\\n</li>\\n<li>\\n<p>对于有事务相关的操作，我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。此时需要保存上下文。\\n拓展：</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);
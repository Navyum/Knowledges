"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[88722],{28558:(e,a,l)=>{l.r(a),l.d(a,{comp:()=>d,data:()=>o});var i=l(6254);const c={},d=(0,l(36995).A)(c,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念：</span></a></h2><ul><li>容错：代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常）</li><li>共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒）</li></ul><h2 id="paxos" tabindex="-1"><a class="header-anchor" href="#paxos"><span>Paxos：</span></a></h2><h3 id="角色" tabindex="-1"><a class="header-anchor" href="#角色"><span>角色：</span></a></h3><ul><li>提议者（proposer）：<code>提出提案</code>的节点</li><li>接收者（acceptor）：<code>接受并投票</code>提案的节点</li><li>学习者（learner）：接收来自接受者的Accept通知，了解<code>最终被接受的提案</code></li></ul><h3 id="核心思想-多轮投票" tabindex="-1"><a class="header-anchor" href="#核心思想-多轮投票"><span>核心思想：多轮投票</span></a></h3><ul><li>通过让<code>proposer</code> 与大多数 <code>acceptor</code> 提前进行一次交流，让 proposer 感知到当前提出的值是否可能被大多数 acceptor 接收</li><li>如果不能被接收，proposer 可以改变策略之后（例如增加提议编号，或接收某一个 proposer 已经提出的值）再继续进行协调，最终让大多数<code>acceptor</code>就某一个值达成共识</li><li>通过<code>提议编码</code>保证了后面被接收的值一定是编号更大的值，从而实现了写操作的线性一致性</li></ul><h3 id="达成共识过程-先测试是否能通过、调整后再真正提议" tabindex="-1"><a class="header-anchor" href="#达成共识过程-先测试是否能通过、调整后再真正提议"><span>达成共识过程：（先测试是否能通过、调整后再真正提议）</span></a></h3><ol><li><p><code>Prepare 准备阶段</code>：</p><ul><li>提议者：选择一个新的<code>提案</code>，编号为N，并向所有接受者发送该<code>Prepare请求</code></li></ul></li><li><p><code>Promise 承诺阶段</code>：</p><ul><li>接受者：收到Prepare请求后： <ul><li>如果提案 <code>编号N</code> &gt; <code>之前收到的所有提案编号</code>： <ul><li><code>承诺不再接受编号小于N的提案</code>（只接受到比本地编号大的提案）</li><li>返回<code>Promise响应</code>，响应内容：接收到的<code>最高编号</code>的<code>提案</code>和<code>提案内容</code>（此时可能返回的是其他提议者编号）</li></ul></li><li>如果提案 <code>编号N</code> &lt;= <code>之前收到的所有提案编号</code>： <ul><li>不会给出承诺，并且拒绝提案，返回<code>Nack响应</code>（拒绝响应）</li></ul></li></ul></li></ul></li><li><p><code>Propose 提议阶段</code>：</p><ul><li>提议者： <ul><li><span style="color:rgb(255, 41, 65);">收到大多数接受者</span>的<code>Promise响应</code>后，进入提议阶段</li><li>根据接受者<code>返回的提案</code>，选择一个提案值V，并向所有接受者发送<code>Propose请求</code>，包含提案编号N和提案值V。</li><li>如果所有<code>Promise响应</code>中没有任何提案值，提议者可以选择任意值V作为提案值。</li></ul></li></ul></li><li><p><code>Accept 接受阶段</code>：</p><ul><li>接受者：收到Propose请求后，如果<code>此次提案编号</code>N大于或等于<code>之前承诺的提案编号</code>，则接受该提案，并通知提议者和学习者。</li><li>提议者：<span style="color:rgb(255, 41, 65);">收到大多数接受者</span>的<code>Accept响应</code>，认为提案已经被接受，并通知所有学习者该提案已经被选定。</li></ul></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c9dc04cfa5f06aa0c98166addcd62f4f.png" width="40%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0c870aaed9bc560caf94fe649c3d71ee.png" width="40%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/830fcc62f4490877297404058c41f3ee.png" width="40%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e6531ceb21608d1a817277e1cd75c321.png" width="40%"></p></li><li><p>容错的实现：</p><ul><li>不需要所有接受者响应，满足大部分即可，（<code>多数派（quorum）原则，至少一半</code>）</li></ul></li></ol><hr><h2 id="raft-算法" tabindex="-1"><a class="header-anchor" href="#raft-算法"><span>Raft 算法：</span></a></h2><h3 id="具体应用场景" tabindex="-1"><a class="header-anchor" href="#具体应用场景"><span>具体应用场景：</span></a></h3><ul><li>etcd、tidb、consul、nacos</li></ul><h3 id="重要" tabindex="-1"><a class="header-anchor" href="#重要"><span>重要！：</span></a></h3><ul><li>将每一个<code>对Raft集群的操作称为一个提案</code>，希望Raft集群对外屏蔽内部的网络或节点异常，依次对每一个提案作出响应，提交成功的提案可以在后续操作中持续可见。</li><li>这里的提案需要是幂等的，即重复执行不会导致集群状态不同。</li></ul><h3 id="角色-1" tabindex="-1"><a class="header-anchor" href="#角色-1"><span>角色：</span></a></h3><ul><li><code>领导者</code>（Leader）： <ul><li>集群中的管理者</li><li>所有client的流量都从leader这里经过；负责日志复制；</li><li>周期性的向follower发出心跳维持统治；</li><li>当发现自己不是leader的时候会转为follower</li></ul></li><li><code>候选人</code>（Candidate）： <ul><li>集群的候选者，会发起投票试图当选leader</li></ul></li><li><code>跟随者</code>（Follower）： <ul><li>集群中的被管理者，只会对其它服务器的命令做出响应。</li><li>在长时间得不到leader响应之后会转为candidate</li></ul></li><li><code>任期</code>（term）： <ul><li>在raft协议中实际是作为逻辑时钟，系统中处于<code>最新term</code>的节点才是安全有效的。</li></ul></li></ul><h3 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想：</span></a></h3><ul><li>Raft算法通过<code>领导者选举</code>和<code>日志复制</code>两个主要机制，进而保证所有节点的最终状态是一致的</li><li>Raft将共识问题分解为以下三个子问题： <ul><li><code>领导者选举</code>（Leader Election）：在集群启动或领导者故障时，选举出一个新的领导者。</li><li><code>日志复制</code>（Log Replication）：<code>领导者</code>将<code>客户端请求</code>作为<code>日志条目</code>追加到<code>本地日志</code>中，并将其复制到所有跟随者（Followers）。</li><li><code>安全性</code>（Safety）：确保所有节点最终达成一致，即所有节点的日志内容相同。</li></ul></li></ul><h3 id="节点间通讯" tabindex="-1"><a class="header-anchor" href="#节点间通讯"><span>节点间通讯：</span></a></h3><ul><li>基于RPC： <ul><li>请求投票（RequestVote）RPC <ul><li>由候选人在选举期间发起，通知各节点进行投票</li></ul></li><li>日志复制（AppendEntries）RPC <ul><li>由领导者发起，用来复制日志和提供心跳消息</li></ul></li></ul></li></ul><h3 id="选举过程" tabindex="-1"><a class="header-anchor" href="#选举过程"><span>选举过程：</span></a></h3><h4 id="选举超时" tabindex="-1"><a class="header-anchor" href="#选举超时"><span>选举超时：</span></a></h4><ul><li>如果<code>跟随者</code>在<code>选举超时时间</code>内没有收到<code>领导者</code>的心跳消息，它会变成<code>候选者</code>并开始<code>发起选举</code></li><li>每个<code>跟随者</code>都有一个随机的选举超时时间。</li><li><em><strong>注意：</strong></em> RAFT的<code>选举超时时间</code>是<code>随机超时时间间隔</code>，确保不会有大量候选者同时发起选举，在超时之后重试即可重新选举成功</li></ul><h4 id="发起选举" tabindex="-1"><a class="header-anchor" href="#发起选举"><span>发起选举：</span></a></h4><ul><li><code>候选者</code>递增自己的任期号（term），并向集群中的其他节点发送请求投票（RequestVote）消息。</li></ul><h4 id="请求投票-requestvote" tabindex="-1"><a class="header-anchor" href="#请求投票-requestvote"><span>请求投票（RequestVote）</span></a></h4><ul><li>候选者先投自己一票，并发送<code>RequestVote消息</code>给其他节点，RequestVote消息包含以下信息（其他节点投票依据）： <ul><li>候选者的任期号（term）</li><li>候选者的ID（candidateId）</li><li>候选者日志中最后一个日志条目的索引（lastLogIndex）</li><li>候选者日志中最后一个日志条目的任期号（lastLogTerm）</li></ul></li></ul><h4 id="投票规则" tabindex="-1"><a class="header-anchor" href="#投票规则"><span>投票规则：</span></a></h4><h5 id="任期号检查" tabindex="-1"><a class="header-anchor" href="#任期号检查"><span><code>任期号检查</code>：</span></a></h5><ul><li>如果 <code>请求投票任期号</code> &lt; <code>当前任期号</code>，那么拒绝投票，并返回当前的<code>Term</code></li><li>否则，将<code>请求投票任期号</code>作为<code>当前任期号</code>，并将自身状态切换成<code>Follower</code>，并重置投票状态</li></ul><h5 id="检测当前节点的投票状态" tabindex="-1"><a class="header-anchor" href="#检测当前节点的投票状态"><span><code>检测当前节点的投票状态</code>：</span></a></h5><ul><li>规则：<code>每个节点在一个任期内只能投票给一个候选者</code></li><li>如果节点没有给任何其他候选者投过票，或者是已经给该候选者投过票，那么继续<code>日志检查</code></li><li>如果当前节点自己也是候选者，且选举超时时间内，收到其他候选者的请求投票，则比较自己任期号和日志新旧，如果别人的新，则更新自己的任期号，并回到跟随者状态</li><li>否则，拒绝投票</li></ul><h5 id="日志新旧检查-在任期号相等时的进一步比较" tabindex="-1"><a class="header-anchor" href="#日志新旧检查-在任期号相等时的进一步比较"><span><code>日志新旧检查</code>（在任期号相等时的进一步比较）</span></a></h5><ul><li>检测<code>候选者的日志</code>是否至少比当前节点的日志新，从而确保新选举出来的<code>Leader</code>不会丢失已经提交的日志： <ul><li><code>日志新、旧比较标准</code>： <ul><li>首先比较<code>最后一个日志条目</code>的<code>任期号</code>（lastLogTerm），任期号大的，日志新</li><li>如果两者任期号相同，则比较<code>最后一个日志条目</code>的<code>索引</code>（lastLogIndex），索引大的，日志新</li></ul></li></ul></li><li>如果候选者日志新，则投票给候选者</li><li>否则，那么就拒绝投票</li></ul><h4 id="投票结果-选举超时时间内" tabindex="-1"><a class="header-anchor" href="#投票结果-选举超时时间内"><span>投票结果（选举超时时间内）：</span></a></h4><ul><li>结果1：自己选举成功： <ul><li>候选者<code>收到大多数节点的赞成票</code>后，当选为领导者。（<code>多数派（quorum）原则，至少一半</code>）</li><li>当选领导者后，开始发送心跳消息给所有跟随者，宣布自己成为领导者，中指选举，保持自己领导者状态</li></ul></li><li>结果2：期间其他节点成为<code>领导者</code>： <ul><li>选举期间收到其他候选者的RequestVote，并且Term和日志都比自己大，则自己变成跟随者</li></ul></li><li>结果3：选举超时或者没有节点选举成功： <ul><li>超时后重新发起选举 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/306c053adab081f7942475807f72a26c.png" width="40%"></li></ul></li></ul><h3 id="日志复制" tabindex="-1"><a class="header-anchor" href="#日志复制"><span>日志复制：</span></a></h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念：</span></a></h4><ul><li>日志条目（Log Entry）：每个日志条目包含一个客户端请求和相关的元数据（如索引和任期号）。</li><li>日志索引（Log Index）：日志条目在日志文件中的位置。日志项对应的整数索引值。它其实就是用来标识日志项的，是一个连续的、单调递增的整数号码</li><li>任期号（Term）：创建这条日志项的领导者的任期编号。</li><li>指令：一条由客户端请求指定的、状态机需要执行的指令。即客户端指定的数据。 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/cf0f5603d1b1493810939d81e4d18de7.png" width="40%"></li></ul><h4 id="日志复制过程-优化后的二阶段提交" tabindex="-1"><a class="header-anchor" href="#日志复制过程-优化后的二阶段提交"><span>日志复制过程：（优化后的二阶段提交）</span></a></h4><h5 id="领导者接收请求" tabindex="-1"><a class="header-anchor" href="#领导者接收请求"><span>领导者接收请求：</span></a></h5><ul><li>领导者节点接收到客户端的写请求，将请求作为<code>新的日志条目</code>追加到<code>本地日志</code>中</li></ul><h5 id="领导者发送appendentries-rpc-给所有追随者" tabindex="-1"><a class="header-anchor" href="#领导者发送appendentries-rpc-给所有追随者"><span>领导者发送AppendEntries RPC 给所有追随者：</span></a></h5><ul><li>领导者将新的日志条目复制到所有跟随者，发送AppendEntries消息</li></ul><h5 id="跟随者处理appendentries-rpc" tabindex="-1"><a class="header-anchor" href="#跟随者处理appendentries-rpc"><span>跟随者处理AppendEntries RPC：</span></a></h5><ul><li>跟随者收到AppendEntries消息后，首先验证prevLogIndex和prevLogTerm是否匹配。如果匹配，则将新的日志条目追加到本地日志中 <ul><li>怎么理解验证prevLogIndex和prevLogTerm是否匹配？见下方：<code>日志的一致性保证</code></li></ul></li><li>跟随者将处理结果（成功或失败）返回给领导者</li></ul><h5 id="日志确认和提交" tabindex="-1"><a class="header-anchor" href="#日志确认和提交"><span>日志确认和提交：</span></a></h5><ul><li>领导者收到大多数跟随者的AppendEntries响应后，认为日志条目已经被复制到大多数节点。</li><li>领导者将这条日志项应用到它的状态机中，更新已提交日志索引，并将提交的信息发送给所有跟随者</li></ul><h5 id="跟随着提交并应用到状态机" tabindex="-1"><a class="header-anchor" href="#跟随着提交并应用到状态机"><span>跟随着提交并应用到状态机：</span></a></h5><ul><li>跟随者收到提交信息后，将日志条目标记为已提交，并应用到状态机 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/186a602618690cfa2a04f67382b5465a.png" width="40%"></li></ul><h5 id="个人理解" tabindex="-1"><a class="header-anchor" href="#个人理解"><span>个人理解：</span></a></h5><ul><li>领导者先写日志，通知跟随者写日志</li><li>大多数跟随者写日志成功，领导者将日志改为提交状态，并应用到状态机，响应客户端。</li><li>跟随者收到领导者的消息，也提交状态并应用到状态机</li></ul><h4 id="日志一致性保证" tabindex="-1"><a class="header-anchor" href="#日志一致性保证"><span>日志一致性保证：</span></a></h4><h5 id="准则" tabindex="-1"><a class="header-anchor" href="#准则"><span>准则：</span></a></h5><ul><li>领导者通过<code>强制</code>跟随者<code>直接复制</code>自己的日志项，处理不一致日志。Raft日志是以领导者的日志为准。</li><li>Raft中日志必须是<code>连续的</code>，Paxos没这个要求</li></ul><h5 id="具体" tabindex="-1"><a class="header-anchor" href="#具体"><span>具体：</span></a></h5><ul><li><p><code>找到差异日志项起始Entry</code>：</p><ul><li>领导者通过日志复制 RPC消息，发送自己当前最新日志项给某个跟随者，消息包含PrevLogEntry和PrevLogTerm</li><li>如果跟随者在它的日志中找不到PrevLogEntry： <ul><li>那么日志复制 RPC 返回失败，跟随者就会拒绝接收这个新的日志项的写入</li><li>也就是说它的日志和领导者的不一致了，并<code>返回失败信息</code>给领导者</li></ul></li><li>失败时领导者会<code>递减要复制的日志项</code>的索引值，并发送新的日志项到跟随者</li><li>直到跟随者在它的日志中找到某个PrevLogEntry： <ul><li>那么日志复制 RPC 返回成功，这样领导者就知道跟随者的日志项与自己相同的起始位置。</li></ul></li></ul></li><li><p><code>覆盖更新起始Entry后的所有Entry</code>：</p><ul><li>领导者通过日志复制RPC，<em><strong><code>复制并更新覆盖起始Entry之后的日志项</code></strong></em>，最终实现了集群各节点日志的一致。</li></ul></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/55075c407a3ce602aca5503ce1daaea3.png" width="40%"></p></li><li><p>视频介绍：</p><ul><li>http://thesecretlivesofdata.com/raft/</li></ul></li></ul><h3 id="成员变更问题" tabindex="-1"><a class="header-anchor" href="#成员变更问题"><span>成员变更问题：</span></a></h3><h4 id="成员变更问题的本质" tabindex="-1"><a class="header-anchor" href="#成员变更问题的本质"><span>成员变更问题的本质：</span></a></h4><ul><li>新增加成员、删除成员时，需要调整配置，此时就会出现新配置和旧配置，进而导致两个领导者的脑裂问题。</li></ul><h4 id="如何解决" tabindex="-1"><a class="header-anchor" href="#如何解决"><span>如何解决：</span></a></h4><ul><li>先关闭集群，再重新启动（不太能被接受）</li><li>单节点变更，每次新增或者删除一个节点（确保旧配置的“大多数”和新配置的“大多数”都会有一个节点是重叠的，而不是完全割裂的）</li></ul><hr><h2 id="zab算法" tabindex="-1"><a class="header-anchor" href="#zab算法"><span>ZAB算法：</span></a></h2><p>https://freegeektime.com/100046101/229975/</p><h3 id="具体应用场景-1" tabindex="-1"><a class="header-anchor" href="#具体应用场景-1"><span>具体应用场景：</span></a></h3><ul><li>zookeeper专用</li></ul><h3 id="角色-2" tabindex="-1"><a class="header-anchor" href="#角色-2"><span>角色：</span></a></h3><ul><li><p><code>领导者</code>（Leader）：</p></li><li><p><code>候选人</code>（Candidate）：</p></li><li><p><code>跟随者</code>（Follower）：</p></li></ul><h3 id="核心思想-1" tabindex="-1"><a class="header-anchor" href="#核心思想-1"><span>核心思想：</span></a></h3><h3 id="节点间通讯-1" tabindex="-1"><a class="header-anchor" href="#节点间通讯-1"><span>节点间通讯</span></a></h3><hr><h4 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考：</span></a></h4><p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjUx7L9_-XXAhUES7wKHbENAw8QFggnMAA&amp;url=https%3a%2f%2flamport%2eazurewebsites%2enet%2fpubs%2fpaxos-simple%2epdf&amp;usg=AOvVaw2LqxhZNPEfgaMeyvZEm9xs" target="_blank" rel="noopener noreferrer">Paxos made simple</a><a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener noreferrer">Practical Byzantine Fault Tolerance</a><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">Bitcoin: A Peer-to-Peer Electronic Cash System</a></p>',75)]))}]]),o=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/06.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E5%8F%AF%E4%BF%A1.html","title":"06.分布式共识算法-可信","lang":"zh-CN","frontmatter":{"title":"06.分布式共识算法-可信","date":"2025-06-17T14:39:25.000Z","author":"Navyum","tags":["架构设计","共识算法"],"categories":["分布式"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"description":"基本概念： 容错：代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常） 共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒） Paxos： 角色： 提议者（proposer）：提出提案的节点 接收者（acceptor）：接受并投票提案的节点 学习者（learner）：接收来自接受者的Accept通知...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/06.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E5%8F%AF%E4%BF%A1.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"06.分布式共识算法-可信"}],["meta",{"property":"og:description","content":"基本概念： 容错：代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常） 共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒） Paxos： 角色： 提议者（proposer）：提出提案的节点 接收者（acceptor）：接受并投票提案的节点 学习者（learner）：接收来自接受者的Accept通知..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"架构设计"}],["meta",{"property":"article:tag","content":"共识算法"}],["meta",{"property":"article:published_time","content":"2025-06-17T14:39:25.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06.分布式共识算法-可信\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T14:39:25.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":10.49,"words":3146},"filePathRelative":"架构设计/02.分布式与架构/06.分布式共识算法-可信.md","localizedDate":"2025年6月17日","excerpt":"<h2>基本概念：</h2>\\n<ul>\\n<li>容错：代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常）</li>\\n<li>共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒）</li>\\n</ul>\\n<h2>Paxos：</h2>\\n<h3>角色：</h3>\\n<ul>\\n<li>提议者（proposer）：<code>提出提案</code>的节点</li>\\n<li>接收者（acceptor）：<code>接受并投票</code>提案的节点</li>\\n<li>学习者（learner）：接收来自接受者的Accept通知，了解<code>最终被接受的提案</code></li>\\n</ul>","autoDesc":true}')},36995:(e,a)=>{a.A=(e,a)=>{const l=e.__vccOpts||e;for(const[e,i]of a)l[e]=i;return l}}}]);
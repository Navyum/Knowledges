"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[645],{36995:(a,e)=>{e.A=(a,e)=>{const t=a.__vccOpts||a;for(const[a,n]of e)t[a]=n;return t}},55558:(a,e,t)=>{t.r(e),t.d(e,{comp:()=>l,data:()=>r});var n=t(6254);const i={},l=(0,t(36995).A)(i,[["render",function(a,e){return(0,n.uX)(),(0,n.CE)("div",null,e[0]||(e[0]=[(0,n.Fv)('<h3 id="系统解耦" tabindex="-1"><a class="header-anchor" href="#系统解耦"><span>系统解耦：</span></a></h3><ul><li>系统内的多个组件可以通过消息系统进行解耦</li></ul><h3 id="异步处理" tabindex="-1"><a class="header-anchor" href="#异步处理"><span>异步处理：</span></a></h3><ul><li>发送方可以立即继续执行，而不必等待接收方处理完成</li></ul><h3 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡"><span>负载均衡：</span></a></h3><ul><li>通过分发机制实现消费者的负载均衡</li></ul><h3 id="可靠性" tabindex="-1"><a class="header-anchor" href="#可靠性"><span>可靠性：</span></a></h3><ul><li>比进程内存模型的数组、链表更可靠</li><li>可以实现持久化，避免消息丢失</li><li>通过多副本方式避免单机故障</li><li>通过协调机制确保服务不停机</li></ul><h3 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制：</span></a></h3><ul><li>根缓存一样，可以缓存消息，防止高峰流量导致系统过载</li><li>消费者根据自己的承受能力进行消费（此处可对比滑动窗口）</li></ul><h3 id="顺序保证" tabindex="-1"><a class="header-anchor" href="#顺序保证"><span>顺序保证：</span></a></h3><ul><li>根进程内存模型的数组、链表一样，可以实现消息的有序消费</li></ul><h3 id="发布-订阅" tabindex="-1"><a class="header-anchor" href="#发布-订阅"><span>发布/订阅：</span></a></h3><ul><li>可以让通信的高效（此处可对比事件驱动机制）</li></ul><h1 id="最简单的队列" tabindex="-1"><a class="header-anchor" href="#最简单的队列"><span>最简单的队列：</span></a></h1><ul><li>内存模型的<code>数组</code>、<code>链表</code></li></ul><h1 id="图解" tabindex="-1"><a class="header-anchor" href="#图解"><span>图解：</span></a></h1><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/668c767ebdc9f7847a7032e5ca547a6c.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',18)]))}]]),r=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8.html","title":"消息队列的作用","lang":"zh-CN","frontmatter":{"title":"消息队列的作用","date":"2025-06-17T15:14:45.000Z","author":"Navyum","tags":["消息队列"],"categories":["常用软件","消息队列"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"系统解耦： 系统内的多个组件可以通过消息系统进行解耦 异步处理： 发送方可以立即继续执行，而不必等待接收方处理完成 负载均衡： 通过分发机制实现消费者的负载均衡 可靠性： 比进程内存模型的数组、链表更可靠 可以实现持久化，避免消息丢失 通过多副本方式避免单机故障 通过协调机制确保服务不停机 流量控制： 根缓存一样，可以缓存消息，防止高峰流量导致系统过载...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"消息队列的作用"}],["meta",{"property":"og:description","content":"系统解耦： 系统内的多个组件可以通过消息系统进行解耦 异步处理： 发送方可以立即继续执行，而不必等待接收方处理完成 负载均衡： 通过分发机制实现消费者的负载均衡 可靠性： 比进程内存模型的数组、链表更可靠 可以实现持久化，避免消息丢失 通过多副本方式避免单机故障 通过协调机制确保服务不停机 流量控制： 根缓存一样，可以缓存消息，防止高峰流量导致系统过载..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/668c767ebdc9f7847a7032e5ca547a6c.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:14:45.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列的作用\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/668c767ebdc9f7847a7032e5ca547a6c.png\\"],\\"datePublished\\":\\"2025-06-17T15:14:45.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":0.98,"words":294},"filePathRelative":"常用软件/消息队列/消息队列的作用.md","localizedDate":"2025年6月17日","excerpt":"<h3>系统解耦：</h3>\\n<ul>\\n<li>系统内的多个组件可以通过消息系统进行解耦</li>\\n</ul>\\n<h3>异步处理：</h3>\\n<ul>\\n<li>发送方可以立即继续执行，而不必等待接收方处理完成</li>\\n</ul>\\n<h3>负载均衡：</h3>\\n<ul>\\n<li>通过分发机制实现消费者的负载均衡</li>\\n</ul>\\n<h3>可靠性：</h3>\\n<ul>\\n<li>比进程内存模型的数组、链表更可靠</li>\\n<li>可以实现持久化，避免消息丢失</li>\\n<li>通过多副本方式避免单机故障</li>\\n<li>通过协调机制确保服务不停机</li>\\n</ul>\\n<h3>流量控制：</h3>","autoDesc":true}')}}]);
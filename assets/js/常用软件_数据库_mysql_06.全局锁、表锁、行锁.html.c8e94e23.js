"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[54736],{24649:(l,i,e)=>{e.r(i),e.d(i,{comp:()=>c,data:()=>d});var o=e(6254);const n={},c=(0,e(36995).A)(n,[["render",function(l,i){return(0,o.uX)(),(0,o.CE)("div",null,i[0]||(i[0]=[(0,o.Fv)('<h2 id="mysql中的锁" tabindex="-1"><a class="header-anchor" href="#mysql中的锁"><span>Mysql中的锁</span></a></h2><h3 id="全局锁-对整个数据库实例加锁" tabindex="-1"><a class="header-anchor" href="#全局锁-对整个数据库实例加锁"><span><code>全局锁</code>：对整个数据库实例加锁</span></a></h3><ul><li>全库逻辑备份： <ol><li>针对<code>MyISAM</code>做全库逻辑备份，只能用<code>FTWRL</code>方式，在备份时不能更新 <ul><li>补充：MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，破坏了数据一致性</li></ul></li><li>针对<code>innodb</code>备份，可以使用<code>mysqldump –single-transaction</code> 在备份时可以更新 <ul><li>补充：通过启动一个事务来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的</li></ul></li></ol></li><li>全库只读设置： <ol><li><code>Flush tables with read lock</code><ul><li>FTWRL，连接周期内有效，如果连接断开会自动释放库锁</li></ul></li><li><code>set global readonly=true</code><ul><li>全局生效，连接断开也不会自动修改readonly状态</li><li>常用来做主从库判断</li><li>备份操作不建议使用，如果备份客户端断开连接，整个库会一直维持不可写状态</li></ul></li></ol></li><li>备份补充说明： <ul><li>物理备份：使用binlog <ul><li>binlog记录了对数据库执行的所有更改，增量数据</li><li>日志格式是二进制</li></ul></li><li>逻辑备份：使用mysqldump <ul><li>提供数据库对应时间点的完整的数据快照，当前时间点的全量数据</li><li>格式是快照形式</li></ul></li></ul></li></ul><hr><h3 id="表级锁-针对数据表加锁" tabindex="-1"><a class="header-anchor" href="#表级锁-针对数据表加锁"><span><code>表级锁</code>：针对数据表加锁</span></a></h3><ol><li>表级锁包括： <ul><li><code>表锁</code></li><li><code>元数据锁</code>（<code>meta data lock</code>/<code>MDL锁</code>）</li><li><code>意向锁</code></li><li><code>AUTO-INC锁</code></li></ul></li><li>表级锁说明：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作</li><li>使用时机：Innodb锁的是索引优先使用<code>MDL锁</code>，如果更新、删除条件没走索引，会降级成表锁</li><li><code>表锁</code>： <ol><li>表级别的共享锁/读锁：lock tables T read</li><li>表级别的独占锁/写锁：lock tables T write</li><li>释放：unlock tables 或者 连接断开时会自动释放锁</li></ol></li><li><code>MDL锁</code>： <ul><li>支持版本 &gt;= MySQL5.5, 不需要显式的使用 MDL</li><li>MDL锁的目的：为了表结构的一致性设计的 <ol><li>防止CURD期间变更结构，导致不一致</li><li>防止变更结构期间，执行CURD，导致不一致</li></ol></li><li>MDL锁分为： <ul><li><code>MDL读锁</code>：对表做<code>增、删、改、查</code>操作（DDL）的时候添加</li><li><code>MDL写锁</code>：对<code>表结构变更</code>操作（DML）的时候添加</li><li>释放：MDL直到事务提交<code>commit</code>/<code>rollback</code>才释放</li><li>读锁之间<code>不互斥</code>，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是<code>互斥</code>的，用来保证变更表结构操作的安全性。 ´</li></ul></li><li>DDL：增、删、改、查 SQL语句</li><li>DML：修改表结构语句</li><li>锁表的例子： <ul><li><em>MDL申请失败导致锁表的例子</em>： <ul><li>申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。如果出现 MDL 写锁获取阻塞，该操作会同时阻塞后续获取MDL读锁，即后续该表的所有CRUD 操作都会阻塞</li><li>对有访问的数据库做DML操作 <ul><li>DDL会占用<code>MDL读锁</code>，如果事务一直不提交，对应读锁将一直得不到释放。因为读锁共享，其他DDL期间申请<code>读锁</code>不会阻塞。</li><li>如果执行DML，因为读写锁互斥，会导致申请<code>写锁</code>阻塞</li><li>因为写锁的原因，后续的DDL再申请<code>读锁</code>不再成功，从而导致整个表不可用。</li></ul></li><li>解决方案： <ul><li>针对1，<code>避免DDL长事务</code><ul><li>长事务不提交会长期占用锁，从而导致其他事务申请MDL锁失败</li><li>长事务还会导致回滚段内存占用不释放</li></ul></li><li>针对2，<code>对DML设定等待时间</code><ul><li>如果时间内无法申请到MDL写锁，则重复该步骤，而不是一直阻塞等待</li><li>具体语法：NOWAIT/WAIT N</li><li>e.g. <code>ALTER TABLE tbl_name WAIT N add column ...</code></li></ul></li></ul></li></ul></li><li><em>DML执行时间过长，导致锁表的例子</em>： <ol><li>表数据超大</li><li>DML拿着<code>MDL写锁</code>，一直执行</li><li>其他事务执行DDL申请<code>MDL读锁</code>一直申请不到阻塞，导致失败</li><li>解决方案： <ul><li>避免表数据超大 <ul><li>升级mysql版本到8.0</li></ul></li></ul></li></ol></li></ul></li></ul></li><li><code>意向锁</code>： <ul><li>设计的目的：协调行级锁和表级锁之间的关系。（为了快速判断表里是否有记录被加锁）</li><li>意向锁的含义：表明事务打算在表的<code>某些行上</code>获取<code>锁</code></li><li>存在意向锁，可以快速判断一定存在行锁。（这样就不需要通过遍历行记录来判断是否有行锁）</li><li>加锁时机： <ul><li>InnoDB引擎的表里，对某些<code>行记录</code>加上<code>共享锁</code>之前，则需要先在<code>表级别</code>加上一个<code>意向共享锁</code>；</li><li>InnoDB引擎的表里，对某些<code>行记录</code>加上<code>独占锁</code>，则需要先在<code>表级别</code>加上一个<code>意向独占锁</code>；</li></ul></li><li>对某些<code>行记录</code>加<code>共享锁</code>的触发条件： <ul><li>select 添加共享锁</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   select ... lock in share mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>对某些<code>行记录</code>加<code>独占锁</code>的触发条件： <ul><li>增、删、改语句操作</li><li>select 添加互斥锁</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    select ... for update;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>意向锁和表锁兼容性：</li><li>|兼容性|<code>X</code>|<code>IX</code>|<code>S</code>|<code>IS</code>| |:--😐:--😐:--😐:--😐:--😐 |<code>X</code>|不兼容|不兼容|不兼容|不兼容| |<code>IX</code>|不兼容|<span style="color:rgb(0, 209, 0);">兼容</span>|不兼容|<span style="color:rgb(0, 209, 0);">兼容</span>| |<code>S</code>|不兼容|不兼容|<span style="color:rgb(0, 209, 0);">兼容</span>|<span style="color:rgb(0, 209, 0);">兼容</span>| |<code>IS</code>|不兼容|<span style="color:rgb(0, 209, 0);">兼容</span>|<span style="color:rgb(0, 209, 0);">兼容</span>|<span style="color:rgb(0, 209, 0);">兼容</span>|</li></ul></li><li><code>AUTO_INC锁</code>： <ul><li>设计目的：使用AUTO_INC锁，数据库实现自增主键的自动赋值递增的逻辑</li><li>释放时机：不是在一个事务提交后才释放，而是在<code>执行完插入语句</code>后就会立即释放</li><li>弊端：大量数据进行插入的时候，因为锁存在，会影响插入性能</li><li>工作机制： <ul><li>在插入数据时，MySQL 会加一个表级别的 AUTO-INC 锁</li><li>然后会为被 AUTO_INCREMENT 修饰的字段赋递增的值</li><li><strong>等插入语句执行完成后</strong>，才会把 AUTO-INC 锁释放掉</li></ul></li><li><code>轻量级的锁</code>： &gt; MySQL 5.1.22 <ul><li>工作机制： <ul><li>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，</li><li>然后给该字段赋值一个自增的值</li><li>然后就把这个轻量级锁释放了，** 不需要等待整个插入语句执行完**</li></ul></li><li>注意事项：当innodb_autoinc_lock_mode = 2，开启轻量锁，此时binlog日志格式不能设置为<code>statement</code>，而要使用<code>row</code>，否则会出现自增主键数据不一致的情况</li></ul></li></ul></li></ol><hr><h3 id="行锁-针对数据表中行记录的锁" tabindex="-1"><a class="header-anchor" href="#行锁-针对数据表中行记录的锁"><span><code>行锁</code>：针对数据表中行记录的锁</span></a></h3><ol><li>引擎差异： <ul><li>MyISAM <code>不支持</code>行锁 <ul><li>只能用<code>表锁</code>来实现并发控制</li><li>同一时间单个表只能有一个更新</li><li><code>并发度低</code></li></ul></li><li>Innodb<code>支持</code>行锁 <ul><li><code>并发度高</code></li></ul></li></ul></li><li><code>两阶段锁协议</code>： <ul><li>在InnoDB事务中，行锁是在需要的时候才加（具体sql执行时）</li><li>在事务结束时才释放（<code>commit</code>/<code>rollback</code>）。</li><li>即使中间不需要锁，也不会自动释放</li></ul></li><li>最佳实践： <ul><li>避免锁冲突和并发占用过长时间 <ul><li>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</li></ul></li></ul></li><li><code>死锁和死锁检测</code>： <ul><li>死锁出现时机：当多个事务出现循环依赖，导致所有事务都在等待。（即饿死现象）</li><li>死锁的解决方案： <ol><li><code>设置超时时间</code>：<code>innodb_lock_wait_timeout=X</code><ul><li>缺点：超时时间不太好把控，过长过短都不行，innodb默认50s</li></ul></li><li><code>开启死锁检测</code>：<code>innodb_deadlock_detect=on</code><ul><li>缺点：死锁检测要耗费大量的CPU资源，需要慎重开启</li></ul></li></ol></li></ul><ol start="3"><li>最佳实践： <ol><li>确定不会出现死锁的业务，可以考虑<code>关闭死锁检测</code></li><li><code>控制并发程度</code>，降低死锁检测成本。具体做法是使用dbproxy<code>控制并发线程数量</code>或者直接修改mysql源码</li><li>从该行数据的设计上考虑，拆解成多行。但是这需要结合业务</li></ol></li></ol></li></ol><hr><h3 id="行锁分类" tabindex="-1"><a class="header-anchor" href="#行锁分类"><span>行锁分类：</span></a></h3><ul><li><code>Record Lock</code>：记录锁，也就是仅仅把<code>一条记录</code>锁上 <ul><li>记录锁: 有S锁和X锁的区分</li><li>发生时机： <ul><li>增、删、改会对行记录加行锁</li><li>普通SELECT查询时都是快照读，不加锁</li><li>特殊的SELECT查询会对记录加行锁:<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//对读取的记录加共享锁/S锁</span></span>\n<span class="line"><span>select ... lock in share mode;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>//对读取的记录加独占锁/X锁</span></span>\n<span class="line"><span>select ... for update;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li><li><code>Gap Lock</code>：间隙锁，<code>锁定一个范围</code>，但是不包含记录本身 <ul><li>作用：只存在于可重复读隔离级别，是为了解决可重复读隔离级别下幻读的现象</li><li>间隙锁: 存在S锁和X锁区分，但没区别。且多个事务可以<code>同时拥有间隙锁</code>，获取锁操作不互斥。（因为间隙锁是为了防止对应区间插入）</li></ul></li><li><code>Next-Key Lock</code>：Record Lock + Gap Lock 的组合，<code>锁定一个范围，并且锁定记录本身</code>，区间范围：左开右闭 <ul><li>作用：即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中</li><li>存在S锁和X锁区分</li><li>仅S锁之间不互斥，SX、XX获取是互斥的(因为Record Lock的原因)</li></ul></li><li><code>插入意向锁</code>：插入位置没有记录，为了解决幻读问题，同时尽可能降低影响范围 <ul><li>当插入操作INSERT被间隙锁阻塞时，会申请插入意向锁(此时插入意向锁是等待状态，意味着并未获取到)，等待间隙锁释放后，插入意向锁变成正常状态，成功获取到插入意向锁，然后执行插入操作。</li><li>如果没有插入意向锁? 那么只能使用间隙锁，锁粒度太粗，对同一个间隙的插入操作必须逐个进行；而插入意向锁可以控制锁的粒度只在插入点上</li><li>为什么叫插入意向锁而不是插入锁？个人理解因为插入意向锁只表示期望插入，在阻塞期间实际未真正拿到锁。</li><li>作用：确保间隙锁释放后，执行当前的插入操作。这些事务按顺序执行。</li><li>插入意向锁并不是<code>意向锁</code>（表级别锁），它是一种特殊的间隙锁，属于<code>行级别锁</code></li><li>插入意向锁锁住的是一个插入点，间隙锁是点和点之间的区间</li><li>插入意向锁之间不互斥（非唯一索引情况下，即使是同一个插入点也不互斥），插入意向锁和间隙锁互斥</li></ul></li></ul><h3 id="行锁补充" tabindex="-1"><a class="header-anchor" href="#行锁补充"><span>行锁补充：</span></a></h3><ul><li>MySQL加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当<code>锁状态为正常状态</code>时，才代表事务成功<code>获取到了锁</code></li><li>Mysql加行锁的对象是索引，加锁的基本单位是 <code>next-key lock</code></li><li><em><strong>锁是在遍历索引的时候加上的，并不是针对输出的结果加锁</strong></em></li><li><code>next-key look</code> 退化成<code>Record lock</code>、<code>Gap lock</code>： <ul><li>在能使用<code>Record lock</code>、<code>Gap lock</code>就能避免幻读现象的场景下</li><li>不可以针对不存在的记录加记录锁，此时会退化成<code>Gap lock</code></li><li>锁区间如何确定： <ul><li>唯一索引、主键索引： <ul><li>确定锁定区间按照索引扫描的方向（从小到大）</li><li>等值查询： <ul><li>值存在，记录锁</li><li>值不存在，值对应索引上一条记录，下一条记录的间隙锁</li></ul></li><li>范围查询： <ul><li>考虑前后的间隙，考虑等值临界点是否可以不锁</li></ul></li></ul></li><li>非唯一索引、二级索引： <ul><li>确定锁定区间按照索引扫描的方向（从小到大）</li><li>等值查询： <ul><li>需要基于索引扫描到<code>所有的符合等值的行记录</code>，添加<code>next-key lock</code></li><li>等值存在间隙锁时，进行等值插入： <ul><li>再基于插入值的主键是否存在间隙锁，判断插入是否成功</li></ul></li></ul></li><li>范围查询： <ul><li>索引的 <code>next-key lock</code> 不会有退化为间隙锁和记录锁,主键依然会退化</li></ul></li></ul></li><li>无索引： <ul><li>当前读查询语句、增、删、改都会触发全表扫描，全记录都会加 <code>next-key lock</code>，等价于锁住全表</li><li><em><strong>在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引</strong></em></li></ul></li></ul></li></ul></li><li>查看当前引擎的锁状态：<code>select * from performance_schema.data_locks\\G;</code> (mysql &gt;= 8.0) <ul><li>LOCK_MODE： 判断是何种锁：以下只考虑<code>写锁</code>情况 <ul><li>如果 LOCK_MODE 为 X，说明是 next-key 锁；</li><li>如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；</li><li>如果 LOCK_MODE 为 X, GAP，说明是间隙锁；</li><li>如果 LOCK_MODE 为 IX, 说明X型意向锁，属于表锁；</li><li>如果 LOCK_MODE 为 X,GAP,INSERT_INTENTION，说明是插入意向锁</li></ul></li><li>LOCK_TYPE: 判断是表锁还是行锁： <ul><li>RECORD：行锁</li><li>TABLE：表锁</li></ul></li><li>LOCK_STATUS：判断当前锁状态 <ul><li>GRANTED：获取</li><li>WAITING：等待</li></ul></li><li>LOCK_DATA：判断锁定的行数据 <ul><li>如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围<code>右边界</code></li><li>而锁的<code>左边界</code>需要通过当前索引找到上一个记录</li></ul></li><li>INDEX_NAME：判断是对哪个索引加锁</li><li>e.g.<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; select THREAD_ID,LOCK_TYPE,INDEX_NAME,LOCK_MODE,LOCK_STATUS,LOCK_DATA from data_locks;</span></span>\n<span class="line"><span>+-----------+-----------+------------+-----------+-------------+------------------------+</span></span>\n<span class="line"><span>| THREAD_ID | LOCK_TYPE | INDEX_NAME | LOCK_MODE | LOCK_STATUS | LOCK_DATA              |</span></span>\n<span class="line"><span>+-----------+-----------+------------+-----------+-------------+------------------------+</span></span>\n<span class="line"><span>|        52 | TABLE     | NULL       | IX        | GRANTED     | NULL                   |</span></span>\n<span class="line"><span>|        51 | TABLE     | NULL       | IS        | GRANTED     | NULL                   |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | supremum pseudo-record |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 21                     |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 1                      |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 15                     |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 5                      |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 10                     |</span></span>\n<span class="line"><span>|        51 | RECORD    | PRIMARY    | S         | GRANTED     | 20                     |</span></span>\n<span class="line"><span>+-----------+-----------+------------+-----------+-------------+------------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>',14)]))}]]),d=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06.%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81.html","title":"06.全局锁、表锁、行锁","lang":"zh-CN","frontmatter":{"title":"06.全局锁、表锁、行锁","date":"2025-06-17T15:20:56.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","锁"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"Mysql中的锁 全局锁：对整个数据库实例加锁 全库逻辑备份： 针对MyISAM做全库逻辑备份，只能用FTWRL方式，在备份时不能更新 补充：MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，破坏了数据一致性 针对innodb备份，可以使用mysqldump –single-transaction 在备份时可以更新 补充：...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06.%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"06.全局锁、表锁、行锁"}],["meta",{"property":"og:description","content":"Mysql中的锁 全局锁：对整个数据库实例加锁 全库逻辑备份： 针对MyISAM做全库逻辑备份，只能用FTWRL方式，在备份时不能更新 补充：MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，破坏了数据一致性 针对innodb备份，可以使用mysqldump –single-transaction 在备份时可以更新 补充：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:20:56.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06.全局锁、表锁、行锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:20:56.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":11.58,"words":3475},"filePathRelative":"常用软件/数据库/mysql/06.全局锁、表锁、行锁.md","localizedDate":"2025年6月17日","excerpt":"<h2>Mysql中的锁</h2>\\n<h3><code>全局锁</code>：对整个数据库实例加锁</h3>\\n<ul>\\n<li>全库逻辑备份：\\n<ol>\\n<li>针对<code>MyISAM</code>做全库逻辑备份，只能用<code>FTWRL</code>方式，在备份时不能更新\\n<ul>\\n<li>补充：MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，破坏了数据一致性</li>\\n</ul>\\n</li>\\n<li>针对<code>innodb</code>备份，可以使用<code>mysqldump –single-transaction</code> 在备份时可以更新\\n<ul>\\n<li>补充：通过启动一个事务来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n<li>全库只读设置：\\n<ol>\\n<li><code>Flush tables with read lock</code>\\n<ul>\\n<li>FTWRL，连接周期内有效，如果连接断开会自动释放库锁</li>\\n</ul>\\n</li>\\n<li><code>set global readonly=true</code>\\n<ul>\\n<li>全局生效，连接断开也不会自动修改readonly状态</li>\\n<li>常用来做主从库判断</li>\\n<li>备份操作不建议使用，如果备份客户端断开连接，整个库会一直维持不可写状态</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n<li>备份补充说明：\\n<ul>\\n<li>物理备份：使用binlog\\n<ul>\\n<li>binlog记录了对数据库执行的所有更改，增量数据</li>\\n<li>日志格式是二进制</li>\\n</ul>\\n</li>\\n<li>逻辑备份：使用mysqldump\\n<ul>\\n<li>提供数据库对应时间点的完整的数据快照，当前时间点的全量数据</li>\\n<li>格式是快照形式</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},36995:(l,i)=>{i.A=(l,i)=>{const e=l.__vccOpts||l;for(const[l,o]of i)e[l]=o;return e}}}]);
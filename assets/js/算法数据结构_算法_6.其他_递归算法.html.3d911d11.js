"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[96962],{21950:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>l,data:()=>s});var n=i(6254);const t={},l=(0,i(36995).A)(t,[["render",function(e,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h3 id="一、什么是递归" tabindex="-1"><a class="header-anchor" href="#一、什么是递归"><span>一、什么是递归？</span></a></h3><p>利用了函数栈实现</p><ol><li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li><li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li><li>基本上，所有的递归问题都可以用递推公式来表示，比如</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    f(n) = f(n-1) + 1; </span></span>\n<span class="line"><span>    f(n) = f(n-1) + f(n-2);</span></span>\n<span class="line"><span>    f(n) = n*f(n-1);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二、为什么使用递归-递归的优缺点" tabindex="-1"><a class="header-anchor" href="#二、为什么使用递归-递归的优缺点"><span>二、为什么使用递归？递归的优缺点？</span></a></h3><ul><li>优点：代码的表达力很强，写起来简洁。</li><li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</li></ul><h3 id="三、什么样的问题可以用递归解决呢" tabindex="-1"><a class="header-anchor" href="#三、什么样的问题可以用递归解决呢"><span>三、什么样的问题可以用递归解决呢？</span></a></h3><p>同时满足以下3个条件：</p><ol><li>问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。</li><li>问题与子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><h3 id="四、如何实现递归" tabindex="-1"><a class="header-anchor" href="#四、如何实现递归"><span>四、如何实现递归？</span></a></h3><ul><li><p>递归代码编写：</p><ul><li>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</li></ul></li><li><p>递归代码理解：</p><ul><li>如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</li></ul></li><li><p>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p></li></ul><h3 id="五、递归常见问题及解决方案" tabindex="-1"><a class="header-anchor" href="#五、递归常见问题及解决方案"><span>五、递归常见问题及解决方案</span></a></h3><ol><li>警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。</li><li>警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</li></ol><h3 id="六、如何将递归改写为非递归代码" tabindex="-1"><a class="header-anchor" href="#六、如何将递归改写为非递归代码"><span>六、如何将递归改写为非递归代码？</span></a></h3><p>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。</p>',15)]))}]]),s=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.html","title":"递归","lang":"zh-CN","frontmatter":{"title":"递归","author":"navyum","date":"2025-06-15T00:00:00.000Z","order":-1,"article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法"],"tag":["递归算法"],"description":"一、什么是递归？ 利用了函数栈实现 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如 二、为什么使用递归？递归的优缺点？ 优点：代码的表达力很强，写起来简洁。 缺点：空...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"递归"}],["meta",{"property":"og:description","content":"一、什么是递归？ 利用了函数栈实现 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如 二、为什么使用递归？递归的优缺点？ 优点：代码的表达力很强，写起来简洁。 缺点：空..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"递归算法"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.38,"words":714},"filePathRelative":"算法数据结构/算法/6.其他/递归算法.md","localizedDate":"2025年6月15日","excerpt":"<h3>一、什么是递归？</h3>\\n<p>利用了函数栈实现</p>\\n<ol>\\n<li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li>\\n<li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li>\\n<li>基本上，所有的递归问题都可以用递推公式来表示，比如</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>    f(n) = f(n-1) + 1; </span></span>\\n<span class=\\"line\\"><span>    f(n) = f(n-1) + f(n-2);</span></span>\\n<span class=\\"line\\"><span>    f(n) = n*f(n-1);</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')},36995:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,n]of a)i[e]=n;return i}}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[43062],{36995:(e,o)=>{o.A=(e,o)=>{const l=e.__vccOpts||e;for(const[e,c]of o)l[e]=c;return l}},53256:(e,o,l)=>{l.r(o),l.d(o,{comp:()=>d,data:()=>a});var c=l(6254);const i={},d=(0,l(36995).A)(i,[["render",function(e,o){return(0,c.uX)(),(0,c.CE)("div",null,o[0]||(o[0]=[(0,c.Fv)('<h3 id="buffer-pool" tabindex="-1"><a class="header-anchor" href="#buffer-pool"><span>buffer pool</span></a></h3><h4 id="常识" tabindex="-1"><a class="header-anchor" href="#常识"><span>常识：</span></a></h4><ul><li>Buffer Pool 是一片<code>连续</code>的内存空间，通过<code>innodb_buffer_pool_size</code>在服务器运行过程中调整buffer pool大小，默认为128MB</li><li><code>Free Page</code>（空闲页），此页未被使用，位于 <code>Free 链表</code>；</li><li><code>Clean Page</code>（干净页），此页已被使用，但是页面<code>未发生修改</code>，位于 <code>LRU 链表</code>。</li><li><code>Dirty Page</code>（脏页），表示此页<code>已被使用</code>且<code>已经被修改</code>，其数据和磁盘上的数据已经不一致。</li><li>当<code>脏页</code>上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了<code>干净页</code>。脏页同时存在于LRU链表和Flush链表。</li><li><code>提高读性能</code>: 读取数据的时候，先从buffer pool LRU链表（干净页）读取数据，如果没有从磁盘读取并把它相邻的数据页一并加载进来。</li><li><code>提高写性能</code>: 更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘</li></ul><h4 id="buffer-pool的作用" tabindex="-1"><a class="header-anchor" href="#buffer-pool的作用"><span>buffer pool的作用：</span></a></h4><ul><li>本质上就是个缓存池。为了降低磁盘和内存的IO差异，提高数据库的读写性能而设计</li><li>存储的数据包括： <ul><li><code>索引页</code></li><li><code>数据页</code></li><li><code>undo页</code></li><li><code>插入缓冲区change buffer</code></li><li><code>自适应哈希索引</code></li><li><code>锁</code></li><li><code>其他</code></li></ul></li></ul><h4 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/058365e2e09ca5c1ed90474ef1e3647c.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>基本构成： <ul><li>控制块： <ul><li>存储信息：缓存页的表空间、页号、缓存页地址、链表节点</li><li>控制块跟缓存页<code>一一对应</code></li></ul></li><li>缓存页： <ul><li>大小16KB,跟页的大小一致</li></ul></li></ul></li></ul><h4 id="管理空闲页" tabindex="-1"><a class="header-anchor" href="#管理空闲页"><span>管理空闲页：</span></a></h4><ul><li>如何查找空闲页? <ul><li>当需要从磁盘中加载一个页到 Buffer Pool 中时，通过<code>Free链表</code>，<code>取一个空闲的缓存页</code>，并且填写该缓存页<code>对应的控制块的信息</code>，然后把该缓存页对应的控制块从Free 链表中移除 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8ee379a0fadd87c2430b800416d4a074.png" alt="Img" loading="lazy"></li></ul></li></ul><h4 id="管理脏页" tabindex="-1"><a class="header-anchor" href="#管理脏页"><span>管理脏页：</span></a></h4><ul><li>如何查找脏页并写入磁盘？</li><li>在需要刷盘时，使用<code>Flush链表</code>，后台线程就可以遍历<code>脏页</code>，写入到磁盘 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/29f0c6de27a31c1717187cea069ebb5e.png" alt="Img" loading="lazy"></li><li><code>脏页刷盘时机</code>： <ul><li>核心：既要保证缓存、磁盘的一致性，又要确保刷盘的效率 <ul><li><code>空闲时</code>后台线程定期将适量的脏页刷入到磁盘： <ul><li>BUF_FLUSH_LRU方式：<code>定时</code>从<code>LRU链表``尾部</code>扫描<code>脏页</code>刷新到磁盘</li><li>BUF_FLUSH_LIST方式：<code>定时</code>从<code>Flush链表</code>刷新部分<code>脏页</code>到磁盘</li></ul></li><li>Mysql<code>服务关闭前</code>，会把所有的脏页刷入到磁盘</li><li><code>Buffer Pool 空间不足</code>时，如果需要淘汰脏页，此时会先将脏页刷入磁盘，再进行淘汰</li><li><code>redo log 日志满了</code>的情况下，会触发脏页刷入磁盘</li></ul></li></ul></li></ul><h4 id="缓存淘汰和命中率" tabindex="-1"><a class="header-anchor" href="#缓存淘汰和命中率"><span>缓存淘汰和命中率：</span></a></h4><ul><li>基于<code>LRU</code>（Least recently used）</li><li>如何管理缓存页的过期，提高命中率</li><li>缓存相关的问题 <ol><li>避免预读导致的缓存失效 <ul><li>预读：在加载数据页时，为了减少磁盘IO，会提前把它相邻的数据页一并加载进来</li><li>失效：预读数据占据了缓存头部，一直未被访问，一些可能访问更频繁缓存反而被迫淘汰，导致失效</li><li>解决方案： <ul><li>区分<code>预读数据</code>和<code>真正被访问到的数据</code>，分别存到<code>old区</code>和<code>young区</code></li><li>进入<code>young</code>区新增条件：<code>在 old 区域被真正访问过</code></li></ul></li><li>具体方法： <ul><li><code>young区</code>：在LRU前部分，缓存时间更长，占63%</li><li><code>old</code>区：在LRU后部分，缓存时间相对短，占37%</li><li>通过<code>innodb_old_blocks_pct</code>设置young区和old区占比</li><li>这样如果预读的页就只加入到 <code>old区域</code>的头部，当页被真正访问的时候，才将页插入 young 区域的头部，否则会被优先淘汰 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/66ffc5b4042bc71b3fdbe58e1149359d.png" alt="Img" loading="lazy"></li></ul></li></ul></li><li>避免Buffer Pool污染 <ul><li>污染的含义：扫描了大量的数据，导致全部页被替换，大量热数据被淘汰</li><li>触发： <ul><li>结果集比较离散，大量的页被访问</li><li>全表扫描，所有页被访问</li></ul></li><li>解决方案： <ul><li>进入<code>young</code>区新增条件：<code>在 old 区域停留时间超过 1 秒</code></li><li>在<code>控制块</code>中记录该页<code>第一次被真正访问的时间</code></li><li>通过<code>innodb_old_blocks_time</code>设置停留时间</li></ul></li><li>具体方法： <ul><li>当前访问时间与控制块中该页<code>第一次被访问的时间</code>相比 <ul><li>大于1s, 则可以移动到<code>young</code>区域头部</li><li>小于1s，则继续停留在<code>old</code>区域</li></ul></li></ul></li></ul></li><li>其他优化： <ul><li>防止<code>young</code>区域内部移动过于频繁 <ul><li>处于<code>young</code>区域前1/4的数据被访问时，不会移动到头部</li><li>处于<code>young</code>区域后3/4的数据被访问时，移动到头部</li></ul></li></ul></li></ol></li></ul><h3 id="buffer-pool的其他优化" tabindex="-1"><a class="header-anchor" href="#buffer-pool的其他优化"><span>Buffer Pool的其他优化：</span></a></h3><h4 id="多实例" tabindex="-1"><a class="header-anchor" href="#多实例"><span>多实例：</span></a></h4><ul><li>在<code>Buffer Pool特别大</code>而且<code>多线程并发访问</code>特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。（多线程下，访问<code>Buffer Pool</code>中的各种链表都需要<code>加锁</code>）</li><li>多实例解决了锁的粒度问题 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2b588bf4eb6713a507d8f0f8c936a467.png" alt="Img" loading="lazy"></li></ul><h4 id="以chunk为单位申请内存" tabindex="-1"><a class="header-anchor" href="#以chunk为单位申请内存"><span>以chunk为单位申请内存：</span></a></h4><ul><li>在重新调整<code>Buffer Pool</code>大小的时候，需要重新向操作系统申请一块连续的内存空间，然后将旧的<code>Buffer Pool</code>中的内容复制到这一块新空间，这个操作极其耗时</li><li>改为以<code>chunk</code>为单位向操作系统申请连续内存，这样一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的。调整大小时，只需要申请新的chunk或者减少chunk即可 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e1f6a913309313f42824eac7f7504980.png" alt="Img" loading="lazy"></li><li>参数配置：<code>innodb_buffer_pool_chunk_size</code>，默认为128M。<code>只能在服务器启动时指定，在服务器运行过程中是不可以修改的</code></li></ul><h3 id="change-buffer-insert-buffer-插入缓冲区" tabindex="-1"><a class="header-anchor" href="#change-buffer-insert-buffer-插入缓冲区"><span>Change buffer/Insert buffer（插入缓冲区）</span></a></h3><ul><li>作用：避免频繁磁盘IO</li><li>触发时机： <ul><li>当对 <strong><code>非唯一索引</code></strong> 进行<code>插入、更新或删除</code>操作时：</li><li>如果相关的索引页不在<code>Buffer Pool</code>中，InnoDB会将<code>这些操作</code>暂存在<code>插入缓冲区</code>；等到系统有空闲资源时，InnoDB会将插入缓冲区中的操作<code>应用</code>到<code>Buffer Pool</code>中的索引页。</li><li>如果相关索引页在<code>Buffer Pool</code>中，则直接更新<code>Buffer Pool</code></li></ul></li><li>注意点：只针对<code>非唯一索引</code>生效，原因：唯一索引有唯一性约束，必须要从磁盘取出数据才能校验唯一性是否正确；<code>非唯一索引</code>没有这个限制，所以可以这么做</li></ul>',21)]))}]]),a=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/16.%E7%BC%93%E5%86%B2%E6%B1%A0-BufferPool.html","title":"16.缓冲池-BufferPool","lang":"zh-CN","frontmatter":{"title":"16.缓冲池-BufferPool","date":"2025-06-17T15:22:19.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","缓冲池","BufferPool"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"buffer pool 常识： Buffer Pool 是一片连续的内存空间，通过innodb_buffer_pool_size在服务器运行过程中调整buffer pool大小，默认为128MB Free Page（空闲页），此页未被使用，位于 Free 链表； Clean Page（干净页），此页已被使用，但是页面未发生修改，位于 LRU 链表。 D...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/16.%E7%BC%93%E5%86%B2%E6%B1%A0-BufferPool.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"16.缓冲池-BufferPool"}],["meta",{"property":"og:description","content":"buffer pool 常识： Buffer Pool 是一片连续的内存空间，通过innodb_buffer_pool_size在服务器运行过程中调整buffer pool大小，默认为128MB Free Page（空闲页），此页未被使用，位于 Free 链表； Clean Page（干净页），此页已被使用，但是页面未发生修改，位于 LRU 链表。 D..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/058365e2e09ca5c1ed90474ef1e3647c.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"缓冲池"}],["meta",{"property":"article:tag","content":"BufferPool"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:22:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"16.缓冲池-BufferPool\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/058365e2e09ca5c1ed90474ef1e3647c.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8ee379a0fadd87c2430b800416d4a074.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/29f0c6de27a31c1717187cea069ebb5e.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/66ffc5b4042bc71b3fdbe58e1149359d.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2b588bf4eb6713a507d8f0f8c936a467.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e1f6a913309313f42824eac7f7504980.png\\"],\\"datePublished\\":\\"2025-06-17T15:22:19.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":5.46,"words":1637},"filePathRelative":"常用软件/数据库/mysql/16.缓冲池-BufferPool.md","localizedDate":"2025年6月17日","excerpt":"<h3>buffer pool</h3>\\n<h4>常识：</h4>\\n<ul>\\n<li>Buffer Pool 是一片<code>连续</code>的内存空间，通过<code>innodb_buffer_pool_size</code>在服务器运行过程中调整buffer pool大小，默认为128MB</li>\\n<li><code>Free Page</code>（空闲页），此页未被使用，位于 <code>Free 链表</code>；</li>\\n<li><code>Clean Page</code>（干净页），此页已被使用，但是页面<code>未发生修改</code>，位于 <code>LRU 链表</code>。</li>\\n<li><code>Dirty Page</code>（脏页），表示此页<code>已被使用</code>且<code>已经被修改</code>，其数据和磁盘上的数据已经不一致。</li>\\n<li>当<code>脏页</code>上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了<code>干净页</code>。脏页同时存在于LRU链表和Flush链表。</li>\\n<li><code>提高读性能</code>: 读取数据的时候，先从buffer pool LRU链表（干净页）读取数据，如果没有从磁盘读取并把它相邻的数据页一并加载进来。</li>\\n<li><code>提高写性能</code>: 更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘</li>\\n</ul>","autoDesc":true}')}}]);
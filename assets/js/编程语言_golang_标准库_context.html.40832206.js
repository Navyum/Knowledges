"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[96086],{36995:(e,t)=>{t.A=(e,t)=>{const n=e.__vccOpts||e;for(const[e,i]of t)n[e]=i;return n}},55818:(e,t,n)=>{n.r(t),n.d(t,{comp:()=>l,data:()=>o});var i=n(6254);const a={},l=(0,n(36995).A)(a,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<ol><li>作用：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能</li><li>context 使用注意事项： <ol><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li><li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li></ol></li><li>相关函数： 这些函数都是幂等的，也就是说连续多次调用同一个方法，得到的结果都是相同的</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span></span>\n<span class="line"><span>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span></span>\n<span class="line"><span>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span></span>\n<span class="line"><span>func WithValue(parent Context, key, val interface{}) Context</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>WithValue查找过程： <ol><li>内存结构： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1b05ecae8854b7b4bc2dd07bea5059d3.png" alt="图片" loading="lazy"></li></ol></li></ol><p>和链表有点像，只是它的方向相反。Context 指向它的父节点，链表则指向下一个节点</p><pre><code>2. 查找过程：\n</code></pre><p>它会顺着链路一直往上找，比较当前节点的 key 是否是要找的 key；如果是则直接返回 value（多个key满足，只返回接近的）；否则一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</p><p>因为查找方向是往上走的，所以父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><pre><code>3. 创建过程：\n</code></pre><p>创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。</p><pre><code>4. 局限性：\n    1. 查找效率低\n    2. 多个节点设置相同的key，只会离当前节点接近的满足条件的一个结果\n</code></pre><ol start="5"><li>WithCancel过程：</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type cancelCtx struct {</span></span>\n<span class="line"><span>\tContext</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\t// 保护之后的字段</span></span>\n<span class="line"><span>\tmu       sync.Mutex</span></span>\n<span class="line"><span>\tdone     chan struct{}</span></span>\n<span class="line"><span>\tchildren map[canceler]struct{}</span></span>\n<span class="line"><span>\terr      error</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cancel()</code> 方法的功能就是关闭 channel：c.done；递归地取消它的所有子节点；从父节点从删除自己。达到的效果是通过关闭 channel，将取消信号传递给了它的所有子节点 。</p><p>当 WithCancel 函数返回的 CancelFunc 被调用或者是父节点的 done channel 被关闭（父节点的 CancelFunc 被调用），此 context（子节点） 的 done channel 也会被关闭。</p><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e5619f1e1058c0518fdbc7045f53670d.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="6"><li></li></ol>',16)]))}]]),o=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/context.html","title":"context","lang":"zh-CN","frontmatter":{"title":"context","author":"navyum","date":"2025-06-21T22:29:35.000Z","article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"category":["笔记"],"tag":["笔记"],"description":"作用：context 用来解决 goroutine 之间退出通知、元数据传递的功能 context 使用注意事项： 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。 ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/context.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"context"}],["meta",{"property":"og:description","content":"作用：context 用来解决 goroutine 之间退出通知、元数据传递的功能 context 使用注意事项： 不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1b05ecae8854b7b4bc2dd07bea5059d3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T14:30:17.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:published_time","content":"2025-06-21T22:29:35.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T14:30:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"context\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1b05ecae8854b7b4bc2dd07bea5059d3.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e5619f1e1058c0518fdbc7045f53670d.png\\"],\\"datePublished\\":\\"2025-06-21T22:29:35.000Z\\",\\"dateModified\\":\\"2025-06-21T14:30:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750516217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":2,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":2.27,"words":681},"filePathRelative":"编程语言/golang/标准库/context.md","localizedDate":"2025年6月21日","excerpt":"<ol>\\n<li>作用：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能</li>\\n<li>context 使用注意事项：\\n<ol>\\n<li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li>\\n<li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li>\\n<li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li>\\n<li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li>\\n</ol>\\n</li>\\n<li>相关函数：\\n这些函数都是幂等的，也就是说连续多次调用同一个方法，得到的结果都是相同的</li>\\n</ol>","autoDesc":true}')}}]);
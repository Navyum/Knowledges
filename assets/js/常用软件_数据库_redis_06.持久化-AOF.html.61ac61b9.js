"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[76823],{36995:(e,i)=>{i.A=(e,i)=>{const a=e.__vccOpts||e;for(const[e,l]of i)a[e]=l;return a}},69216:(e,i,a)=>{a.r(i),a.d(i,{comp:()=>t,data:()=>c});var l=a(6254);const n={},t=(0,a(36995).A)(n,[["render",function(e,i){return(0,l.uX)(),(0,l.CE)("div",null,i[0]||(i[0]=[(0,l.Fv)('<h3 id="写日志的方式" tabindex="-1"><a class="header-anchor" href="#写日志的方式"><span>写日志的方式：</span></a></h3><ul><li><p>WAL：写前日志（Write Ahead Log, WAL）在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复（mysql 先把数据写到redo log，再落盘）。</p></li><li><p>AOF：写后日志， Redis 是先执行命令，把数据写入内存，然后才记录日志。（所以AOF不是crash-safe的）</p></li></ul><h3 id="aof" tabindex="-1"><a class="header-anchor" href="#aof"><span>AOF：</span></a></h3><ul><li>AOF 里记录的是 Redis 收到的<code>每一条写操作</code>。以文本形式保存的。</li><li>优点： <ul><li>AOF是<code>顺序写</code>，不需要检查和索引操作，避免了额外检查的开销</li><li>不会阻塞<code>当前</code>的写入操作</li></ul></li><li>缺点： <ul><li>未写入AOF的那部分数据可能会丢失</li><li>因为些操作和写AOF都是在主进程中，所以写AOF时，可能会阻塞后一个<code>写操作</code></li></ul></li><li>刷盘时机： <ul><li><p>配置<code>appendfsync</code>：</p><ul><li>Always：每次执行命令后，通过系统调用fsync刷盘</li><li>Everysec：创建异步，每隔1秒，调用一次fsync刷盘</li><li>No：由操作系统控制，不主动调用fsync</li></ul></li><li><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f82ece977374ec72eca3b92d1d068d57.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ul></li><li><code>AOF 缓冲区</code>： <ul><li>将命令刷盘前，先放入 AOF 缓冲区，然后通过fsync刷盘。服务于AOF 文件刷盘，提高刷盘效率。</li></ul></li></ul><h3 id="aof-文件格式" tabindex="-1"><a class="header-anchor" href="#aof-文件格式"><span>AOF 文件格式：</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>*3</span></span>\n<span class="line"><span>$3</span></span>\n<span class="line"><span>set</span></span>\n<span class="line"><span>$4</span></span>\n<span class="line"><span>name</span></span>\n<span class="line"><span>$3</span></span>\n<span class="line"><span>yhj</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="aof-完整过程" tabindex="-1"><a class="header-anchor" href="#aof-完整过程"><span>AOF 完整过程：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4d2193905855f7f71646edd66affc7a9.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><h3 id="aof-重写机制" tabindex="-1"><a class="header-anchor" href="#aof-重写机制"><span>AOF 重写机制：</span></a></h3><ul><li>作用： 通过将原有AOF文件进行重写（单个键值的操作合并），从而<code>对AOF文件大小进行压缩</code></li><li>文件过大带来的问题： <ol><li>文件系统本身的限制，无法保存过大的文件</li><li>文件太大，追加命令记录效率会变低</li><li>大文件恢复过程会非常缓慢</li></ol></li><li>机制说明： <ul><li><code>AOF 重写</code>发生时，原AOF操作依然在进行</li><li>如何重写：根据Redis当前内存中，这个键值对当前的<code>最新状态</code>，生成对应的写入命令</li><li>重写过程是由后台子进程<code>bgrewriteaof</code>执行，不阻塞主进程</li></ul></li><li>技术细节： <ul><li>写时复制COW（copy on write）： <ul><li>通过fork，生成后台子进程<code>bgrewriteaof</code></li><li>这样后台子进程共享主进程的物理内存数据，不需要花费大量时间进行数据复制</li><li>子进程只会对该物理内存进行读取操作</li><li>主进程中因为不阻塞命令执行，会发生数据变更。此时操作系统会复制这些<code>变化的数据内存</code>，即<code>写时复制</code></li></ul></li><li>数据一致性： <ul><li>当数据出现变更时，主进程会把增量写命令写到<code>AOF 缓冲区</code>和<code>AOF重写缓冲区</code></li><li>子进程AOF重写完成后，发送信号给主进程。</li><li>继续将<code>AOF重写缓冲区</code>数据写入AOF文件</li><li>替换AOF文件</li></ul></li><li>主进程发生阻塞时机： <ul><li>触发重写时，fork操作需要复制页表，如果页表比较大（比如开启<code>内存大页</code>4KB-&gt;1MB），会阻塞主进程</li><li>当发生写时复制，如果写入bigkey，会阻塞主进程（主要是又触发了内存分配）</li></ul></li><li><code>AOF 重写缓冲区</code>： <ul><li><code>AOF 重写</code>过程中，增量的<code>写命令</code>需要额外记录到<code>AOF 重写缓冲区</code>，等重写完成，将其写入AOF文件。<code>AOF 重写缓冲区</code>服务于AOF重写时的数据一致性。</li></ul></li></ul></li></ul><h3 id="aof-重写过程" tabindex="-1"><a class="header-anchor" href="#aof-重写过程"><span>AOF 重写过程：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4c437c1a4d3a5729a64148a755e62168.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',12)]))}]]),c=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/06.%E6%8C%81%E4%B9%85%E5%8C%96-AOF.html","title":"06.持久化-AOF","lang":"zh-CN","frontmatter":{"title":"06.持久化-AOF","date":"2025-06-17T15:38:12.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","持久化","AOF"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"写日志的方式： WAL：写前日志（Write Ahead Log, WAL）在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复（mysql 先把数据写到redo log，再落盘）。 AOF：写后日志， Redis 是先执行命令，把数据写入内存，然后才记录日志。（所以AOF不是crash-safe的） AOF： AOF 里记录的是 Redi...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/06.%E6%8C%81%E4%B9%85%E5%8C%96-AOF.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"06.持久化-AOF"}],["meta",{"property":"og:description","content":"写日志的方式： WAL：写前日志（Write Ahead Log, WAL）在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复（mysql 先把数据写到redo log，再落盘）。 AOF：写后日志， Redis 是先执行命令，把数据写入内存，然后才记录日志。（所以AOF不是crash-safe的） AOF： AOF 里记录的是 Redi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f82ece977374ec72eca3b92d1d068d57.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"持久化"}],["meta",{"property":"article:tag","content":"AOF"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:38:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06.持久化-AOF\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f82ece977374ec72eca3b92d1d068d57.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4d2193905855f7f71646edd66affc7a9.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4c437c1a4d3a5729a64148a755e62168.png\\"],\\"datePublished\\":\\"2025-06-17T15:38:12.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.87,"words":860},"filePathRelative":"常用软件/数据库/redis/06.持久化-AOF.md","localizedDate":"2025年6月17日","excerpt":"<h3>写日志的方式：</h3>\\n<ul>\\n<li>\\n<p>WAL：写前日志（Write Ahead Log, WAL）在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复（mysql 先把数据写到redo log，再落盘）。</p>\\n</li>\\n<li>\\n<p>AOF：写后日志， Redis 是先执行命令，把数据写入内存，然后才记录日志。（所以AOF不是crash-safe的）</p>\\n</li>\\n</ul>\\n<h3>AOF：</h3>\\n<ul>\\n<li>AOF 里记录的是 Redis 收到的<code>每一条写操作</code>。以文本形式保存的。</li>\\n<li>优点：\\n<ul>\\n<li>AOF是<code>顺序写</code>，不需要检查和索引操作，避免了额外检查的开销</li>\\n<li>不会阻塞<code>当前</code>的写入操作</li>\\n</ul>\\n</li>\\n<li>缺点：\\n<ul>\\n<li>未写入AOF的那部分数据可能会丢失</li>\\n<li>因为些操作和写AOF都是在主进程中，所以写AOF时，可能会阻塞后一个<code>写操作</code></li>\\n</ul>\\n</li>\\n<li>刷盘时机：\\n<ul>\\n<li>\\n<p>配置<code>appendfsync</code>：</p>\\n<ul>\\n<li>Always：每次执行命令后，通过系统调用fsync刷盘</li>\\n<li>Everysec：创建异步，每隔1秒，调用一次fsync刷盘</li>\\n<li>No：由操作系统控制，不主动调用fsync</li>\\n</ul>\\n</li>\\n<li>\\n<figure><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f82ece977374ec72eca3b92d1d068d57.png\\" alt=\\"图片\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>图片</figcaption></figure>\\n</li>\\n</ul>\\n</li>\\n<li><code>AOF 缓冲区</code>：\\n<ul>\\n<li>将命令刷盘前，先放入 AOF 缓冲区，然后通过fsync刷盘。服务于AOF 文件刷盘，提高刷盘效率。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);
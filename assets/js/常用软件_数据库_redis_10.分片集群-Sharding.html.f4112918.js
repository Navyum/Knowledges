"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[27275],{36995:(e,i)=>{i.A=(e,i)=>{const l=e.__vccOpts||e;for(const[e,a]of i)l[e]=a;return l}},44461:(e,i,l)=>{l.r(i),l.d(i,{comp:()=>c,data:()=>o});var a=l(6254);const d={},c=(0,l(36995).A)(d,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h2 id="分片集群" tabindex="-1"><a class="header-anchor" href="#分片集群"><span>分片集群：</span></a></h2><h4 id="分片集群作用" tabindex="-1"><a class="header-anchor" href="#分片集群作用"><span>分片集群作用：</span></a></h4><ul><li>单机内存存在上限，通过横向扩展来突破存储的上限</li></ul><h4 id="主从集群作用" tabindex="-1"><a class="header-anchor" href="#主从集群作用"><span>主从集群作用：</span></a></h4><ul><li>提升可用性，避免单点故障</li></ul><h4 id="分片集群方案" tabindex="-1"><a class="header-anchor" href="#分片集群方案"><span>分片集群方案：</span></a></h4><ul><li>官方的<code>redis cluster</code></li><li>更早更稳定的<code>codis</code></li></ul><h2 id="redis-cluster" tabindex="-1"><a class="header-anchor" href="#redis-cluster"><span>redis cluster：</span></a></h2><h4 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性：</span></a></h4><ol><li>采用无中心化的模式（无proxy，客户端与服务端直连）</li><li>cluster 使用<code>哈希槽（Hash Slot）</code>处理数据和实例之间的映射关系</li><li>默认有16384个槽，需要把所有的槽分配给实例，否则 Redis 集群无法正常工作。（一个实例会对应多个槽位）</li><li>每个redis实例都有所有哈希槽的映射关系</li><li>如果集群中Redis实例的内存大小不一样，可以使用cluster addslots进行手动分配哈希槽</li><li><code>hash slot</code>简化了节点扩缩容的难度，便于集群的维护和管理，但是增加了客户端<code>映射表的维护成本</code>，客户端需要支持重定向机制带来的新的协议。</li></ol><h4 id="查找过程-主要在客户端" tabindex="-1"><a class="header-anchor" href="#查找过程-主要在客户端"><span>查找过程（主要在客户端）:</span></a></h4><ol><li><code>客户端</code>通过哈希函数CRC16，给<code>key</code>计算哈希值</li><li>将结果与<code>16384</code>取模</li><li>查找本地哈希槽表，找出对应槽的redis实例信息</li><li>客户端到对应实例查询key的value <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a972f0c4aa3a67622ef9e3d9020933a1.png" width="60%"></li></ol><h4 id="哈希槽获取和更新" tabindex="-1"><a class="header-anchor" href="#哈希槽获取和更新"><span><code>哈希槽获取和更新</code>：</span></a></h4><ul><li><p><code>广播</code>（去中心化的gossip协议）：</p><ul><li>Redis每个实例通过<code>广播</code>，把自己的哈希槽信息发给和它<code>相连接</code>的其它实例，完成哈希槽分配信息的扩散</li></ul></li><li><p>客户端通过key获取对应实例：</p><ol><li>客户端连接实例，实例把本地哈希槽信息发给客户端</li><li>当客户端请求键值对时，先计算键所对应的哈希槽，找到对应的实例</li><li>客户端连接对应实例，获取key对应的value</li></ol></li></ul><h4 id="集群扩容、数据迁移" tabindex="-1"><a class="header-anchor" href="#集群扩容、数据迁移"><span>集群扩容、数据迁移：</span></a></h4><ul><li>扩容的难点： <ul><li>扩容时按照<code>hash slot</code>的粒度进行数据迁移</li><li>扩容通过修改哈希槽信息，将部分哈希槽重新分配给新实例，这样原来负责这些槽的redis实例需要把这些数据迁移给新实例</li><li>扩容时，数据可能在旧实例上，需要客户端支持<code>重定向协议</code></li></ul></li><li><code>重定向机制</code>： <ul><li>含义： <ul><li>客户端给一个实例发送数据读写操作时（假设本地哈希槽信息还没更新，访问了旧槽），这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令</li></ul></li><li>产生的原因： <ul><li>因为扩容导致哈希槽映射发生变化，但客户端本地的哈希槽信息还没更新，此时Cluster 提供<code>重定向机制</code>，让客户端可以到新实例查询数据</li></ul></li><li>客户端查询哈希槽： <ul><li><p>哈希槽<code>已迁移完成</code>：</p><ul><li>key已经迁移到新实例： <ul><li>旧实例返回<code>MOVED</code></li><li>客户端<code>更新本地哈希槽信息</code>，并向返回的新实例发起<code>GET查询</code></li></ul></li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    GET hello:key</span></span>\n<span class="line"><span>    (error) MOVED 13320 172.16.19.5:6379</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>哈希槽<code>迁移中</code>：</p><ul><li>key已经迁移到新实例： <ul><li>旧实例返回<code>ASK</code></li><li>客户端<code>不更新哈希槽信息</code>，先向返回的新实例发送<code>ASKING</code>，新实例响应后，再发<code>GET查询</code></li></ul></li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    GET hello:key</span></span>\n<span class="line"><span>    (error) ASK 13320 172.16.19.5:6379</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>key还在旧实例： <ul><li>旧实例直接返回 Value</li></ul></li></ul></li><li><p>已完成： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7035d186145ff7c51487c21ab377c5dc.png" width="60%"></p></li><li><p>迁移中： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e9fbb970ec0728baf2c24726e578bd9d.png" width="60%"></p></li></ul></li></ul></li></ul><h2 id="codis" tabindex="-1"><a class="header-anchor" href="#codis"><span>codis：</span></a></h2><h4 id="特性-1" tabindex="-1"><a class="header-anchor" href="#特性-1"><span>特性：</span></a></h4><ol><li>采用中心化的模式（proxy，客户端proxy连接）</li><li>使用<code>1024</code>个逻辑槽，给redis实例分配若干逻辑槽，映射key和逻辑槽的关系</li></ol><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c5067bf7f7cfeb0a25e42a522a8ea5df.png" width="60%"><h4 id="查找过程-主要在服务端" tabindex="-1"><a class="header-anchor" href="#查找过程-主要在服务端"><span>查找过程（主要在服务端）:</span></a></h4><ol><li>客户端直接和codis proxy 建立连接，使用<code>RESP</code>Redis Serialization Protocol协议交互（一种序列化协议）</li><li><code>codis-proxy</code>接收到客户端的请求</li><li><code>codis-proxy</code>通过哈希函数CRC32，计算<code>key</code>哈希值</li><li>将结果与<code>1024</code>取模</li><li>查找槽和实例路由表，找出对应<code>codis server</code></li><li>将客户端请求转发给相应的<code>codis server</code>进行处理，并返回给客户端处理结果 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ada61aae2cfb9962c65610737c9c4ad7.png" width="60%"></li></ol><h4 id="逻辑槽信息获取和更新" tabindex="-1"><a class="header-anchor" href="#逻辑槽信息获取和更新"><span><code>逻辑槽信息获取和更新</code>：</span></a></h4><ol><li>在codis dashboard 上分配好路由表</li><li>dashboard 会把路由表push给codis proxy，同时把路由表保存在 Zookeeper 中</li><li>codis-proxy 会把路由表缓存在本地，当它接收到客户端请求后查找本地缓存。</li><li>当proxy宕机重启，则从zookeeper重新获取配置</li></ol><h4 id="集群扩容、数据迁移-1" tabindex="-1"><a class="header-anchor" href="#集群扩容、数据迁移-1"><span>集群扩容、数据迁移：</span></a></h4><ul><li><p>扩容特点：</p><ul><li>Codis集群扩容时按照Slot的粒度进行数据迁移</li><li>codis 扩容时，客户端不需要关心当前各实例状态</li></ul></li><li><p>扩容过程：</p><ul><li>在<code>源server上</code>，Codis从要迁移的Slot中随机选择一个数据，发送给<code>目的server</code></li><li><code>目的server</code>正常响应，给<code>源server</code>返回确认消息</li><li><code>源server</code>将本地的key删除</li><li>不断重复上述步骤，直到slot数据全部迁移</li></ul></li><li><p>同步迁移/异步迁移：</p><ul><li><code>同步</code>： <ul><li><code>源server</code>发送迁移数据给<code>目的server</code>时，暂停处理用户请求，等待<code>目的server</code>确认消息</li><li>优点： <ul><li>逻辑简单，不会出现数据不一致</li></ul></li><li>缺点： <ul><li>阻塞，可能会影响正常用户访问</li><li>bigkey迁移会导致阻塞时间过长</li></ul></li></ul></li><li><code>异步</code>： <ul><li><code>源server</code>把数据发送给<code>目的server</code>时，继续处理用户请求。key被发送之后，会被设置为只读以确保数据一致性。</li><li>优点： <ul><li>非阻塞，不影响正常用户访问</li><li>异步迁移 Slot时，允许每次迁移多个key</li><li>对于bigkey，异步迁移采用了拆分指令的方式进行迁移</li></ul></li><li>缺点： <ul><li>相比同步稍微复杂些</li><li>部分阻塞，迁移中的数据会被设置为只读，无法修改</li></ul></li></ul></li></ul></li><li><p>异步下的bigkey迁移：</p><ul><li>如果key是<code>bigkey</code>，codis会拆分成多次发送并设置<code>过期时间</code>，来保证数据一致性和原子性</li><li>如果bigkey迁移发生中断，则<code>新server</code>会在过期后删除bigkey</li><li>如果整个bigkey迁移完成，则<code>新server</code>删除bigkey的过期时间</li></ul></li></ul><h4 id="codis可靠性集群设计" tabindex="-1"><a class="header-anchor" href="#codis可靠性集群设计"><span>codis可靠性集群设计：</span></a></h4><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4ccaed84bc566fc12056c7ce7e33283d.png" width="60%"><ol><li><code>codis server</code>使用主从模式进行读写分离，从库挂了不影响服务</li><li>使用哨兵集群，实现主从自动切换，故障转移</li><li>使用<code>zookeeper</code>集群存储 slot-&gt; redis实例路由表，确保proxy列表获取的可用性</li><li><code>codis proxy</code>设计为无状态服务，可以随时扩容</li></ol><h2 id="两者比较" tabindex="-1"><a class="header-anchor" href="#两者比较"><span>两者比较：</span></a></h2><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/b1c5f18db43f63cddd89296c3a73911f.png" width="60%"><h4 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充：</span></a></h4><ul><li>都使用了逻辑上的<code>slot</code>将实例切成更小的槽 <ul><li>提升扩容速度</li><li>实现数据分片和负载均衡</li><li>易于水平扩展</li></ul></li></ul>',33)]))}]]),o=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/10.%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-Sharding.html","title":"10.分片集群-Sharding","lang":"zh-CN","frontmatter":{"title":"10.分片集群-Sharding","date":"2025-06-17T15:38:41.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","分片集群","Sharding"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"分片集群： 分片集群作用： 单机内存存在上限，通过横向扩展来突破存储的上限 主从集群作用： 提升可用性，避免单点故障 分片集群方案： 官方的redis cluster 更早更稳定的codis redis cluster： 特性： 采用无中心化的模式（无proxy，客户端与服务端直连） cluster 使用哈希槽（Hash Slot）处理数据和实例之间的...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/10.%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-Sharding.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"10.分片集群-Sharding"}],["meta",{"property":"og:description","content":"分片集群： 分片集群作用： 单机内存存在上限，通过横向扩展来突破存储的上限 主从集群作用： 提升可用性，避免单点故障 分片集群方案： 官方的redis cluster 更早更稳定的codis redis cluster： 特性： 采用无中心化的模式（无proxy，客户端与服务端直连） cluster 使用哈希槽（Hash Slot）处理数据和实例之间的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"分片集群"}],["meta",{"property":"article:tag","content":"Sharding"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:38:41.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10.分片集群-Sharding\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:38:41.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":5.83,"words":1750},"filePathRelative":"常用软件/数据库/redis/10.分片集群-Sharding.md","localizedDate":"2025年6月17日","excerpt":"<h2>分片集群：</h2>\\n<h4>分片集群作用：</h4>\\n<ul>\\n<li>单机内存存在上限，通过横向扩展来突破存储的上限</li>\\n</ul>\\n<h4>主从集群作用：</h4>\\n<ul>\\n<li>提升可用性，避免单点故障</li>\\n</ul>\\n<h4>分片集群方案：</h4>\\n<ul>\\n<li>官方的<code>redis cluster</code></li>\\n<li>更早更稳定的<code>codis</code></li>\\n</ul>\\n<h2>redis cluster：</h2>\\n<h4>特性：</h4>\\n<ol>\\n<li>采用无中心化的模式（无proxy，客户端与服务端直连）</li>\\n<li>cluster 使用<code>哈希槽（Hash Slot）</code>处理数据和实例之间的映射关系</li>\\n<li>默认有16384个槽，需要把所有的槽分配给实例，否则 Redis 集群无法正常工作。（一个实例会对应多个槽位）</li>\\n<li>每个redis实例都有所有哈希槽的映射关系</li>\\n<li>如果集群中Redis实例的内存大小不一样，可以使用cluster addslots进行手动分配哈希槽</li>\\n<li><code>hash slot</code>简化了节点扩缩容的难度，便于集群的维护和管理，但是增加了客户端<code>映射表的维护成本</code>，客户端需要支持重定向机制带来的新的协议。</li>\\n</ol>","autoDesc":true}')}}]);
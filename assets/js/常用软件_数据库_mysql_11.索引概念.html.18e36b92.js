"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[619],{36995:(e,i)=>{i.A=(e,i)=>{const l=e.__vccOpts||e;for(const[e,a]of i)l[e]=a;return l}},71311:(e,i,l)=>{l.r(i),l.d(i,{comp:()=>n,data:()=>o});var a=l(6254);const t={},n=(0,l(36995).A)(t,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h3 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引：</span></a></h3><ol><li>作用：提高查询效率</li><li><code>索引不止存在内存中，还要写到磁盘上</code></li></ol><h3 id="常见的索引模型" tabindex="-1"><a class="header-anchor" href="#常见的索引模型"><span>常见的索引模型：</span></a></h3><ul><li>哈希表：适用于只有等值查询的场景（kv键值对）</li><li>有序数组：等值查询和范围查询场景（redis的有序集合）</li><li>搜索树：二叉树是搜索效率最高，大多数的数据库存储却并不使用二叉树 <blockquote><p>[!TIP] 索引不止存在内存中，还要写到磁盘上。N 叉树（B+树）由于在读写上的性能优点，以及适配磁盘的访问模式</p></blockquote></li></ul><h3 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型"><span>索引类型：</span></a></h3><ul><li>按「数据结构」分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引、覆盖索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li><li>补充说明： <ol><li>主键索引（聚簇索引） <ol><li>主键索引是一种特殊的唯一索引，单表只能有一个（primary key）</li></ol></li><li>非主键索引（非聚簇索引） <ol><li>唯一索引 索引的列的值必须唯一，可以有多个（unique key）</li><li>普通索引 非唯一索引（没有唯一性约束）</li><li>前缀索引 特殊的索引类型，只使用<code>索引列的前缀</code>来建立索引</li><li>覆盖索引 特殊的索引类型，不需要回表就可以</li><li>全文索引 特殊的索引类型，在文本列上创建，以<code>支持自然语言</code>查询</li><li>空间索引 支持空间数据类型的查询和分析等操作，点查询、矩形查询、距离查询，又叫做矢量索引（opensearch）</li><li>哈希索引 等值查询</li></ol></li></ol></li></ul><h3 id="innodb的索引" tabindex="-1"><a class="header-anchor" href="#innodb的索引"><span>innodb的索引：</span></a></h3><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e3f497ea5445cbdaee3ee2e91a286634.png" width="60%"><h4 id="索引组织表" tabindex="-1"><a class="header-anchor" href="#索引组织表"><span>索引组织表：</span></a></h4><p>InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，每一个索引在 InnoDB 里面对应一棵 B+ 树</p><h4 id="mysql数据行格式" tabindex="-1"><a class="header-anchor" href="#mysql数据行格式"><span>mysql数据行格式：</span></a></h4><p>见 <code>行记录结构.md</code></p><h4 id="innodb-页分裂、页合并" tabindex="-1"><a class="header-anchor" href="#innodb-页分裂、页合并"><span>innodb 页分裂、页合并：</span></a></h4><ol><li>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护</li><li>如果数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂。(数据复制的过程比较耗时)</li><li>页分裂操作还影响数据页的利用率：原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</li><li>页合并：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li></ol><h3 id="innodb-索引优化" tabindex="-1"><a class="header-anchor" href="#innodb-索引优化"><span>innodb 索引优化：</span></a></h3><ul><li>使用最左前缀原则：索引项按照索引定义的字段顺序进行排序</li><li>使用覆盖索引优化</li><li>使用索引下推：遍历时先按照索引中包含的字段做判断，直接过滤掉不满足条件的记录，从而减少回表次数。（与之对应的是，按照字段顺序逐个比对，无索引下推，会先回表）</li><li>主键索引最好是自增</li><li>防止索引失效</li></ul><p>select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1; <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3fd503860905ed2b4ee7927fe1028a5f.png" width="60%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3677bd4254265f1d21f980e64fe0bd93.png" width="60%"></p><h3 id="change-buffer" tabindex="-1"><a class="header-anchor" href="#change-buffer"><span><code>change buffer</code>:</span></a></h3><ul><li><p>作用：在<code>更新操作</code>中，当数据页不在内存中的时候，在不影响一致性的前提下，mysql会把当前操作放到change buffer，等下次数据页被读到内存时再更新。</p></li><li><p>配置change buffer 大小： innodb_change_buffer_max_size</p></li><li><p>补充：</p><ul><li>change buffer是持久化、crash-safe的（通过redo log）</li><li><code>只有普通索引</code>会用到change buffer;<code>唯一索引</code>因为唯一性约束，不可避免需要读出数据页;</li><li>适用性： <ul><li>对于写多读少的业务，change buffer 效果明显；</li><li>对于写入后立即查询的业务，反而多了维护change buffer的成本。</li></ul></li><li><code>redo log</code> 主要节省的是随机写磁盘的IO消耗（转成顺序写），change buffer主要节省的则是随机读磁盘的IO消耗</li></ul></li></ul><h3 id="待移除" tabindex="-1"><a class="header-anchor" href="#待移除"><span>待移除</span></a></h3><ol start="9"><li><p>优化器如何选择索引：</p><ol><li>宗旨：找到一个最优的执行方案，并用最小的代价去执行语句</li><li>判断指标： <ol><li>扫描行数（基于统计信息来估算符合的记录数即索引区分度，索引上不同值的数量叫做基数，越多越好）</li><li>临时表</li><li>排序</li><li>其他综合因素</li></ol></li><li>查看各索引基数的方法：show index from T</li><li>纠正错误统计信息：analyze table T</li></ol></li><li><p>优化器索引选择错误如何处理：</p><ol><li>select * from T force index</li><li>不改变sql语义，微调sql语句，引导优化器使用正确索引</li><li>新建更合适的索引或者删除误用的索引</li></ol></li><li><p>explain用法：见单独标题</p></li></ol>',21)]))}]]),o=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/11.%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5.html","title":"11.索引概念","lang":"zh-CN","frontmatter":{"title":"11.索引概念","date":"2025-06-17T15:21:36.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","索引"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"索引： 作用：提高查询效率 索引不止存在内存中，还要写到磁盘上 常见的索引模型： 哈希表：适用于只有等值查询的场景（kv键值对） 有序数组：等值查询和范围查询场景（redis的有序集合） 搜索树：二叉树是搜索效率最高，大多数的数据库存储却并不使用二叉树 [!TIP] 索引不止存在内存中，还要写到磁盘上。N 叉树（B+树）由于在读写上的性能优点，以及适配...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/11.%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"11.索引概念"}],["meta",{"property":"og:description","content":"索引： 作用：提高查询效率 索引不止存在内存中，还要写到磁盘上 常见的索引模型： 哈希表：适用于只有等值查询的场景（kv键值对） 有序数组：等值查询和范围查询场景（redis的有序集合） 搜索树：二叉树是搜索效率最高，大多数的数据库存储却并不使用二叉树 [!TIP] 索引不止存在内存中，还要写到磁盘上。N 叉树（B+树）由于在读写上的性能优点，以及适配..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"索引"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:21:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"11.索引概念\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:21:36.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":4.31,"words":1292},"filePathRelative":"常用软件/数据库/mysql/11.索引概念.md","localizedDate":"2025年6月17日","excerpt":"<h3>索引：</h3>\\n<ol>\\n<li>作用：提高查询效率</li>\\n<li><code>索引不止存在内存中，还要写到磁盘上</code></li>\\n</ol>\\n<h3>常见的索引模型：</h3>\\n<ul>\\n<li>哈希表：适用于只有等值查询的场景（kv键值对）</li>\\n<li>有序数组：等值查询和范围查询场景（redis的有序集合）</li>\\n<li>搜索树：二叉树是搜索效率最高，大多数的数据库存储却并不使用二叉树\\n<blockquote>\\n<p>[!TIP] 索引不止存在内存中，还要写到磁盘上。N 叉树（B+树）由于在读写上的性能优点，以及适配磁盘的访问模式</p>\\n</blockquote>\\n</li>\\n</ul>","autoDesc":true}')}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[49993],{36995:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,a]of i)t[e]=a;return t}},44571:(e,i,t)=>{t.r(i),t.d(i,{comp:()=>l,data:()=>d});var a=t(6254);const o={},l=(0,t(36995).A)(o,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h3 id="误解-redis只有一个线程" tabindex="-1"><a class="header-anchor" href="#误解-redis只有一个线程"><span>误解：redis只有一个线程</span></a></h3><ul><li>Redis 的<code>网络IO</code>和<code>键值对读写</code>是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型）</li><li>Redis的其他功能，比如<code>持久化</code>、<code>异步删除</code>、<code>集群数据同步</code>等，其实是由额外的线程执行的。</li></ul><h3 id="为什么用单线程" tabindex="-1"><a class="header-anchor" href="#为什么用单线程"><span>为什么用单线程：</span></a></h3><ol><li>多线程开销问题</li><li>多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作） （此处没有很好解释原因，而是用多线程缺点来阐述，不够严谨）</li></ol><h3 id="为什么用单线程还这么快" tabindex="-1"><a class="header-anchor" href="#为什么用单线程还这么快"><span>为什么用单线程还这么快：</span></a></h3><ol><li>大部分操作在内存</li><li>使用了IO多路复用（Redis6.0之后采用<code>多线程模型</code>处理网络IO请求）</li></ol><h3 id="redis常见的性能瓶颈问题" tabindex="-1"><a class="header-anchor" href="#redis常见的性能瓶颈问题"><span>redis常见的性能瓶颈问题：</span></a></h3><ol><li><p>请求耗时严重时，会影响整个server的性能。例如：</p><ul><li><code>操作bigkey</code>：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时</li><li><code>使用复杂度过高的命令</code>：例如一次查询全量数据；</li><li><code>大量key集中过期</code>：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；</li><li><code>淘汰策略</code>：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；</li><li><code>AOF刷盘开启always机制</code>：每次写入都需要把这个操作刷到磁盘。写磁盘的速度远比写内存慢，会拖慢Redis的性能；</li><li><code>主从全量同步生成RDB</code>：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大阻塞时间越久；</li></ul></li><li><p>并发请求量非常大时，单线程读写客户端IO数据存在性能瓶颈</p><ul><li>虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</li></ul></li></ol><h3 id="瓶颈问题解决方案" tabindex="-1"><a class="header-anchor" href="#瓶颈问题解决方案"><span>瓶颈问题解决方案：</span></a></h3><ul><li><p>针对问题1：</p><ul><li>通过业务人员规避</li><li>Redis4.0 推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</li></ul></li><li><p>针对问题2：</p><ul><li>Redis6.0 推出了多线程网络IO模型，可以在高并发场景下利用CPU多核多线程读写客户端数据。但只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</li></ul></li></ul>',10)]))}]]),d=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/03.%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html","title":"03.线程模型","lang":"zh-CN","frontmatter":{"title":"03.线程模型","date":"2025-06-17T15:37:58.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","线程模型"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"误解：redis只有一个线程 Redis 的网络IO和键值对读写是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型） Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。 为什么用单线程： 多线程开销问题 多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作） （此处没有很好解释原因，...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/03.%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"03.线程模型"}],["meta",{"property":"og:description","content":"误解：redis只有一个线程 Redis 的网络IO和键值对读写是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型） Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。 为什么用单线程： 多线程开销问题 多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作） （此处没有很好解释原因，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"线程模型"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:37:58.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03.线程模型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:37:58.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.4,"words":719},"filePathRelative":"常用软件/数据库/redis/03.线程模型.md","localizedDate":"2025年6月17日","excerpt":"<h3>误解：redis只有一个线程</h3>\\n<ul>\\n<li>Redis 的<code>网络IO</code>和<code>键值对读写</code>是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型）</li>\\n<li>Redis的其他功能，比如<code>持久化</code>、<code>异步删除</code>、<code>集群数据同步</code>等，其实是由额外的线程执行的。</li>\\n</ul>\\n<h3>为什么用单线程：</h3>\\n<ol>\\n<li>多线程开销问题</li>\\n<li>多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作）\\n（此处没有很好解释原因，而是用多线程缺点来阐述，不够严谨）</li>\\n</ol>","autoDesc":true}')}}]);
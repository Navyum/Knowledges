"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[15746],{2337:(i,e,l)=>{l.r(e),l.d(e,{comp:()=>c,data:()=>d});var a=l(6254);const t={},c=(0,l(36995).A)(t,[["render",function(i,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h2 id="http" tabindex="-1"><a class="header-anchor" href="#http"><span>HTTP</span></a></h2><h4 id="发送格式" tabindex="-1"><a class="header-anchor" href="#发送格式"><span>发送格式：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3e072d70ba9af070642f25856b372028.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h4 id="响应格式" tabindex="-1"><a class="header-anchor" href="#响应格式"><span>响应格式：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/31bc1a1c077cb1ef967ba20d2cda4c55.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https"><span>HTTPS</span></a></h2><h4 id="与http相比-多了ssl-tls-握手协议" tabindex="-1"><a class="header-anchor" href="#与http相比-多了ssl-tls-握手协议"><span>与HTTP相比，多了SSL/TLS 握手协议</span></a></h4><h4 id="概念-前向安全性" tabindex="-1"><a class="header-anchor" href="#概念-前向安全性"><span>概念：前向安全性：</span></a></h4><ul><li>密钥泄露后，即使拿到以前的记录，也无法通过密钥进行破解</li><li>RSA、DH加密算法是非前向安全的；ECDHE是前向安全的</li></ul><h4 id="ssl-tls-握手协议" tabindex="-1"><a class="header-anchor" href="#ssl-tls-握手协议"><span>SSL/TLS 握手协议：</span></a></h4><ul><li>目的： <ul><li><code>通过非对称加密算法，握手后协商出对称加密密钥</code></li></ul></li><li>花费： <ul><li>2 RTT <ul><li>TLS 1.2 通常情况下</li></ul></li><li>1 RTT <ul><li>使用会话复用技术后</li></ul></li><li>0 RTT <ul><li>TLS 1.3 使用会话复用和<code>Pre-shared Key</code>（请求和Ticket一起发）</li></ul></li></ul></li></ul><h4 id="tls-密钥套件ciper-suite" tabindex="-1"><a class="header-anchor" href="#tls-密钥套件ciper-suite"><span>TLS 密钥套件<code>Ciper suite</code>：</span></a></h4><ul><li>格式： <ul><li>TLS + 密钥协商算法 + 证书签名算法 + WITH + 对称加密算法 + 摘要算法</li></ul></li><li>举例：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256（TLS 1.2）</li><li>算法说明： <ul><li>密钥协商算法：TLS阶段，用于生成对称密钥或者加密对称密钥的要素（要素加密）</li><li>签名算法：TLS阶段，用户客户端校验服务器证书有效性、ECDHE公钥的有效性（证书校验）</li><li>对称加密算法：TLS完成后，数据传输时加密（数据传输）</li><li>摘要算法：TLS最后阶段，对密钥协商过程数据做摘要并验证（过程验证）</li></ul></li><li>举例：TLS_AES_256_GCM_SHA384（TLS 1.3） <ul><li>密钥协商算法不在套件内，而是通过<code>key_share</code>扩展指定</li><li>签名算法不在套件内，而是通过<code>signature_algorithms</code>扩展指定 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6e438da1013944db557141a57deb690b.png" alt="Img" loading="lazy"></li></ul></li></ul><h4 id="tls-1-2-ecdhe-握手过程" tabindex="-1"><a class="header-anchor" href="#tls-1-2-ecdhe-握手过程"><span>TLS 1.2 （ECDHE）握手过程：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8e1a73d1c9158a0ec1040f1777f6019e.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li><code>TCP 握手、挥手过程在内核协议栈进行</code>,<code>TLS在应用层</code></li><li><code>TLS第一次握手</code>： <ul><li>客户端发 <code>client hello</code>消息 <ul><li>消息包含：客户端TLS 版本号、支持的密码套件列表、客户端随机数</li></ul></li></ul></li><li><code>TLS第二次握手</code>： <ul><li>服务端发 <code>server hello</code>消息 <ul><li>消息包含：协商后的TLS 版本号、协商后的协议套件、服务端随机数</li></ul></li><li>服务端发 <code>certificate</code>消息 <ul><li>消息包含：证书、证书对应的签名</li></ul></li><li>服务端生成用于协议传输的公、私钥（基于协商的协议套件）</li><li>服务端发 <code>serverKeyExchange</code>消息（ECDHE有该过程，RSA没有） <ul><li>消息包含：ECDHE公钥、公钥签名、椭圆曲线的参数</li></ul></li><li>服务端发 <code>serverHelloDone</code>消息 <ul><li>消息包含：服务端协商相关数据已传输结束</li></ul></li></ul></li><li><code>TLS第三次握手</code>： <ul><li>客户端验证证书有效性（通过CA或者OSCP stampling）</li><li>客户端生成用于协议传输的公、私钥（基于协商的协议套件）</li><li>客户端发 <code>clientKeyExchange</code>消息 <ul><li>ECDHE 消息包含：ECDHE公钥、公钥签名、椭圆曲线的参数</li><li>RSA 消息包含：使用服务端证书公钥加密<code>premaster secret</code>后的字符串</li></ul></li><li>客户端发 <code>changeCipherSpec</code>消息 <ul><li>计算出对称加密密钥，即会话密钥 <ul><li>ECDHE：双端公钥+椭圆曲线的参数+双端随机数</li><li>RSA：pre-master secret+双端随机数</li></ul></li><li>消息包含：通知服务端后续使用对称加密</li></ul></li><li>客户端发 <code>Encrypted Handshake Message</code>消息 <ul><li>先使用摘要算法，计算协商过程产生的数据摘要</li><li>客户端再使用对称加密的会话密钥对摘要加密 <ul><li>消息包含：加密的摘要</li></ul></li></ul></li></ul></li><li><code>TLS第四次握手</code>：（ECDHE时，客户端无需等待第四次完成即可发用户数据） <ul><li>服务端发 <code>changeCipherSpec</code>消息 <ul><li>使用私钥解密出pre-master secret，计算出对称加密密钥，即会话密钥 <ul><li>ECDHE：双端公钥+椭圆曲线的参数+双端随机数</li><li>RSA：pre-master secret+双端随机数</li></ul></li><li>消息包含：通知客户端后续使用对称加密</li></ul></li><li>服务端发 <code>Encrypted Handshake Message</code>消息 <ul><li>先使用摘要算法，计算协商过程产生的数据摘要</li><li>服务端再使用对称加密的会话密钥对摘要加密</li><li>消息包含：加密的摘要</li></ul></li></ul></li></ul><h4 id="tls-1-2-和-1-3对比" tabindex="-1"><a class="header-anchor" href="#tls-1-2-和-1-3对比"><span>TLS 1.2 和 1.3对比：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1277641be6ab34323df77c4f02950142.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>性能：TLS 1.2 握手4次，2RTT；TLS 1.3 握手2次，1RTT</li><li>安全：TLS 1.3 将支持的密码套件缩减到五个，但都是<code>前向安全</code>的</li></ul><h4 id="tls-握手性能优化" tabindex="-1"><a class="header-anchor" href="#tls-握手性能优化"><span>TLS 握手性能优化：</span></a></h4><ul><li>硬件优化： <ul><li>提升CPU性能（HTTPS协议是计算密集型）</li></ul></li><li>软件优化： <ul><li>软件升级：openssl</li><li>协议升级： <ul><li>使用TLS 1.3</li><li>密钥交换算法使用<code>ECDHE</code>（替换<code>RSA</code>）</li></ul></li><li>证书优化： <ul><li>证书传输： <ul><li>选择使用<code>ECDSA</code>替换<code>RSA</code>（前者协议数据更小）</li></ul></li><li>验证过程： <ul><li><code>OCSP</code> 在线证书状态协议：向CA查询证书的有效状态，按需查询。建议使用。</li><li><code>CRL</code> 证书吊销列表：向CA拉取证书吊销列表，一次查全量，但数据太大。</li><li><code>OCSP Stapling</code>： <ul><li>原先为了验证的服务器的身份，服务器会在 TLS 握手过程中，把自己的证书发给客户端用于验证</li><li>使用<code>OCSP Stapling</code>，服务端向CA周期性地查询证书状态，在握手时返回给客户端，这样客户端就不用再去查询有效性了</li></ul></li></ul></li></ul></li></ul></li><li>工程优化： <ul><li>会话复用： <ul><li>含义：把首次TLS握手协商的对称加密密钥缓存起来，后续需要建立 HTTPS 连接时，直接复用</li><li>基于<code>Session ID</code>： <ul><li>服务端和客户端都缓存。使用唯一Session ID将密钥缓存到内存</li></ul></li><li>基于<code>Session Ticket</code>： <ul><li>仅客户端缓存。客户端握手时上传<code>Session Ticket</code>，服务端解密验证</li></ul></li><li>基于<code>Pre-shared Key</code>： <ul><li>在 TLS 1.3支持</li><li>客户端重连后，不进行握手，而是直接发 HTTP请求，将<code>Session Ticket</code>同时传给服务器</li></ul></li></ul></li><li>会话复用的缺点： <ul><li>非前向安全</li><li>无法应对重放攻击</li><li>应对方法：需要设置好有效期</li></ul></li></ul></li></ul><h4 id="实战经验" tabindex="-1"><a class="header-anchor" href="#实战经验"><span>实战经验：</span></a></h4><ul><li>wireshark解析TLS加密报文： <ul><li>修改系统环境变量：export SSLKEYLOGFILE=&quot;/data/sslkeylogfile&quot;</li><li>修改wireshark配置 <ul><li>【编辑】-&gt;【首选项】-&gt;【Protocols】-&gt;【TLS】-&gt;【Pre-Master Secret log】-&gt; &quot;/data/sslkeylogfile&quot;</li></ul></li></ul></li></ul><h2 id="http-1-0" tabindex="-1"><a class="header-anchor" href="#http-1-0"><span>HTTP/1.0</span></a></h2><ul><li>略过</li></ul><h2 id="http-1-1" tabindex="-1"><a class="header-anchor" href="#http-1-1"><span>HTTP/1.1</span></a></h2><ul><li>基于TCP，使用文本进行传输</li></ul><h4 id="http-1-1-的改进" tabindex="-1"><a class="header-anchor" href="#http-1-1-的改进"><span>HTTP/1.1 的改进：</span></a></h4><ul><li>长连接：复用TCP连接，避免TCP握手的消耗</li><li>管道网络传输（pipeline）：客户端的请求可以并发，但服务端响应需要有序（HTTP2.0 解决）</li><li>缓存策略：更复杂的缓存，协商缓存</li><li>大文件范围请求Range：断点续传</li><li>必须要Host头字段：一台服务器可以托管多个域名的网站</li></ul><h4 id="http-1-1-存在的问题" tabindex="-1"><a class="header-anchor" href="#http-1-1-存在的问题"><span>HTTP/1.1 存在的问题：</span></a></h4><ul><li><code>并发连接有限</code>： <ul><li>浏览器最大并发连接数是 6 个</li><li>TCP 和 TLS 握手耗时</li></ul></li><li><code>HTTP队头阻塞问题</code>： <ul><li>同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务</li></ul></li><li><code>HTTP头部</code>巨大且重复</li><li>不支持服务器推送消息，需要通过轮询方式</li></ul><h4 id="针对-http-1-1-优化手段" tabindex="-1"><a class="header-anchor" href="#针对-http-1-1-优化手段"><span>针对 HTTP/1.1 优化手段：</span></a></h4><ul><li>减少请求： <ul><li>缓存数据、304 Not Modify</li><li>减少重定向次数</li><li>合并请求</li><li>按需获取</li></ul></li><li>数据压缩： <ul><li>Accept-Encoding、Content-Encoding</li><li>无损压缩：gzip</li><li>有损压缩：webp、png、heif</li></ul></li></ul><h2 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0"><span>HTTP/2.0</span></a></h2><h4 id="特征" tabindex="-1"><a class="header-anchor" href="#特征"><span>特征：</span></a></h4><ul><li>兼容HTTP/1.1，基于TCP，使用二进制传输</li><li>语义不改变，只是全部都是小写</li><li>语法改变大，HTTP报文的传输格式改变</li><li>&quot;h2&quot;表示使用 TLS加密（HTTPS）的HTTP/2.0，&quot;h2c&quot;非加密(HTTP)</li></ul><h4 id="http-2-0-的改进" tabindex="-1"><a class="header-anchor" href="#http-2-0-的改进"><span>HTTP/2.0 的改进：</span></a></h4><h5 id="hpack头部压缩" tabindex="-1"><a class="header-anchor" href="#hpack头部压缩"><span><code>HPACK头部压缩</code>：</span></a></h5><ul><li>静态表编码： <ul><li>共61组，HTTP/2.0协议内默认编码好了</li></ul></li><li>动态表编码： <ul><li>非静态表的头部，由客户端和服务端自行构建</li><li>仅对同一个TCP连接生效、当出现重复传输完全相同的HTTP头部时，才会起作用</li><li>存放在内存中，如果连接一直占用，可能会占用较高内存</li></ul></li><li>Huffman 编码（压缩算法） <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c4803aa491fcfd5ebfde9045d606c748.png" alt="Img" loading="lazy"></li><li>存在的问题： <ul><li><code>HPACK队头阻塞问题</code>：动态表发生变化+并发下，如果完整的编码未被接收，会导致后续压缩结果无法被发送，造成队头阻塞</li></ul></li></ul><h5 id="二进制格式编码" tabindex="-1"><a class="header-anchor" href="#二进制格式编码"><span><code>二进制格式编码</code>：</span></a></h5><ul><li><p>HTTP/1.1 使用<code>文本</code>，HTTP/2.0 使用<code>二进制</code></p></li><li><p>化整为零，将传输信息（header+body）分割为更小的帧 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6d7699ba78eba5dae358267adbf382e8.png" alt="Img" loading="lazy"></p></li><li><p>名词解释：</p><ul><li><code>HEADERS 帧</code>：传输请求Header 内容</li><li><code>DATA 帧</code>：传输请求正文（多个 Data帧属于同一个流，有先后顺序）</li><li><code>Frame Header</code>：帧头（属于帧内的结构）</li><li><code>Frame Payload</code>：帧数据（属于帧内的结构）</li></ul></li><li><p><code>h2</code>包解析： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c42e845055af9f5a4ceb78dafd14087a.png" alt="Img" loading="lazy"></p></li></ul><h5 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用"><span><code>多路复用</code>：</span></a></h5><ul><li>含义： <ul><li>一条 TCP 连接在同一时间可以跑多个Stream</li></ul></li><li>TCP connection、stream、message、frame的关系： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/22170a9e46dad8ff73adff878d2ede0a.png" alt="Img" loading="lazy"><ul><li><code>connection</code>可以有多个<code>Stream</code></li><li><code>Stream</code>包含两个<code>Message</code>，<code>请求message</code>和<code>响应message</code></li><li><code>Message</code>包含一个或者多个<code>Frame</code>（Message 对应 HTTP/1 中的请求或响应）</li><li><code>Frame</code>是 HTTP/2 最小单位，以二进制压缩存放 HTTP/1 中的头部和包体，<code>Frame</code>是有顺序的，一个 Frame 可以由多个 TCP 报文构成`</li></ul></li></ul><h5 id="服务器推送-server-push-cache-push" tabindex="-1"><a class="header-anchor" href="#服务器推送-server-push-cache-push"><span><code>服务器推送</code>（Server Push/ Cache Push）</span></a></h5><ul><li>作用： <ul><li>将可能会用到的数据先发送给客户端<code>缓存</code>下来</li></ul></li><li>服务端推送时创建的stream ID是偶数</li><li>客户端请求时创建的stream ID是奇数</li></ul><h5 id="解决http的队头阻塞" tabindex="-1"><a class="header-anchor" href="#解决http的队头阻塞"><span><code>解决HTTP的队头阻塞</code></span></a></h5><ul><li>通过<code>Stream</code>多路复用解决</li><li>同一个tcp连接中，http1的请求需要排队等待http事务完成后才能进行下一个（默认不开启<code>pipeline</code>，即使开启，服务端响应需要有序返回，这样也会阻塞）；</li><li>http2使用流可以在同一个tcp中实现并发</li></ul><h4 id="http-2-0-未解决的问题" tabindex="-1"><a class="header-anchor" href="#http-2-0-未解决的问题"><span>HTTP/2.0 未解决的问题：</span></a></h4><ul><li><code>TCP队头阻塞问题</code><ul><li>发生丢包时依赖tcp重传，得等到收到数据包后才能继续处理后续的流</li></ul></li><li><code>网络迁移</code>需要重新建立TCP连接 <ul><li>一个 TCP 连接是由四元组确定，IP地址或者端口变动，就需要TCP与 TLS重新握手（TCP存在连接状态导致，UDP无该问题）</li></ul></li></ul><h4 id="帧协议格式" tabindex="-1"><a class="header-anchor" href="#帧协议格式"><span>帧协议格式：</span></a></h4><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/048a9b0325f365cd4f0bc626fa106ebf.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li><p>帧长度：</p><ul><li>单个帧最大2^24 = 16M</li></ul></li><li><p>帧类型：</p><ul><li>大致可以分成： <ul><li>数据帧：HEADERS 、DATA</li><li>控制帧：SETTINGS、PING、PRIORITY等</li></ul></li><li>此外 gRPC 定义了几种自用的新帧类型。</li></ul></li><li><p>帧标志：</p><ul><li><code>End Headers</code>：表示header传输结束，在<code>HEADERS帧</code>使用</li><li><code>End stream</code>：表示客户端或者服务端单方面数据传输结束，在<code>HEADRS帧</code>(get)、<code>DATA帧</code>（post）使用</li><li><code>Padded</code>：表示该流是用来填充的，在任意帧都使用</li><li><code>Ack</code>：表示确认，在<code>PING帧</code>、<code>SETTING帧</code>中使用</li></ul></li><li><p>流标识符：<code>Stream ID</code></p><ul><li>流 ID 是<code>递增</code>的： <ul><li>客户端发起的 ID 是奇数</li><li>服务器端发起的 ID 是偶数</li></ul></li><li>流是<code>可并发</code>的： <ul><li>一个连接上可以同时有多个流，即“多路复用”也就是并发多请求；</li></ul></li><li>流是<code>双向的</code>： <ul><li>客户端和服务器都可以创建流，双方互不干扰</li><li>一个流对应一次http请求、响应</li></ul></li><li>流之间是<code>独立的</code>： <ul><li>但流内部的帧是有严格顺序的</li></ul></li><li>流是有<code>优先级</code>的： <ul><li>在流上发送<code>PRIORITY帧</code>，让服务器优先处理某些流</li><li>e.g. 先传 HTML/CSS，后传图片，优化用户体验</li></ul></li><li>流是<code>可取消</code>的： <ul><li>在流上发送<code>RST_STREAM帧</code>可以随时终止流，取消接收或发送</li></ul></li><li>第0号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。</li></ul></li></ul><h4 id="数据收发" tabindex="-1"><a class="header-anchor" href="#数据收发"><span>数据收发：</span></a></h4><ul><li>从不同层对应的消息： <ul><li>在“流”内看，消息由有序的“帧”序列组成</li><li>在“TCP”的层面上看，消息是乱序收发的“帧” <ul><li>多个请求/响应之间没有了顺序关系，不需要根据请求顺序排队等待 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8fae57c8dcf3faf0f41577042bd9ec58.png" alt="图片" loading="lazy"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7ddf8f4fadc857fe081fd2008950a987.png" alt="图片" loading="lazy"></li></ul></li></ul></li><li>数据发送过程： <ol><li>发送方将多个请求分到多个流中，然后将请求内容拆成帧，进行二进制传输</li><li>多个请求的帧，在传输层打散乱序发送</li><li>接收方根据每个帧首部的流标识符重新进行组装</li><li>可以根据优先级，决定优先处理哪个流的数据</li><li>因为TCP滑动窗口的原因，如果某个包没被确认，虽然后续包已到达，也不会被确认，而是一直阻塞</li><li>1.1 vs 2.0 发送示意图： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0e49e74abc6c7694352d3642d59bdb5d.png" alt="图片" loading="lazy"></li></ol></li></ul><h2 id="http-3-0-http-over-quic" tabindex="-1"><a class="header-anchor" href="#http-3-0-http-over-quic"><span>HTTP/3.0（HTTP-over-QUIC）</span></a></h2><ul><li>在HTTP/3.0中，数据流由传输层QUIC提供，而在HTTP/2中，流由HTTP层完成</li></ul><h3 id="quic" tabindex="-1"><a class="header-anchor" href="#quic"><span>QUIC：</span></a></h3><ul><li>特征： <ul><li>QUIC 基于UDP，是一个自己处理数据流的<code>传输层协议</code>，自身实现了TCP的一些特性</li><li>QUIC 使用且必须用TLS 1.3传输层安全协议</li><li>QUIC流 可以是单向的、也可以是双向的，由发起端决定</li><li>QUIC 在用户空间中实现，使用QUIC意味着选择了套接字API之外的另一套API</li><li>建立过程：可能在首次握手时协商使用HTTP/2协议，通过Alt-Svc头部，服务器通告客户端它对HTTP/3的支持与偏好。所以首次连接可能会有TCP连接和UDP同时进行（跟DNS解析ipv4和ipv6同时进行类似） <ul><li>e.g. Alt-Svc: h3=&quot;:50781&quot;，建议客户端使用UDP端口50781提供的HTTP/3</li></ul></li></ul></li></ul><h4 id="解决http-2-0-的问题" tabindex="-1"><a class="header-anchor" href="#解决http-2-0-的问题"><span>解决HTTP/2.0 的问题：</span></a></h4><ul><li>TCP 队头阻塞： <ul><li>QUIC的流基于UDP连接，每个流相互独立，互不影响（因为UDP不管顺序，不管丢包，所以传输层没有阻塞问题）</li></ul></li><li>TCP 建立连接的延迟更低： <ul><li>HTTP2.0：tcp + tls = 1RTT +2 RTT</li><li>QUIC：传输层握手和tls合并</li></ul></li><li>网络迁移（wifi和蜂窝互换）需要重新建立TCP连接 <ul><li>HTTP2.0 基于TCP，tcp 五元组唯一确认一个连接</li><li>QUIC 基于UDP，使用唯一的<code>connection id</code>，端口号同UDP端口</li></ul></li></ul><h4 id="quic协议" tabindex="-1"><a class="header-anchor" href="#quic协议"><span>QUIC协议：</span></a></h4><ul><li>总览：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>UDP Header</span></span>\n<span class="line"><span>  Packet Header                   -----</span></span>\n<span class="line"><span>      QUIC Frame Header           --  TLS1.3</span></span>\n<span class="line"><span>          HTTP3 Frame Header      -- </span></span>\n<span class="line"><span>              HTTP Message        -----</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e1b1cd669b4881acee9400ff91bb680.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li><p>Packet（负责连接可靠）：</p><ul><li>定义<code>Connection ID</code>，类似TCP连接四元组 <ul><li>64比特位（8字节）整数标识</li></ul></li><li><code>Packet Number</code>实现了类似TCP的可靠的连接 <ul><li>重传：当 UDP 报文丢失后，通过 Packet Header 中的 Packet Number 实现报文重传。</li><li>Packet Number 单调递增，重传的包Packet Number不一样： <ul><li>RTT是精确的，没有TCP重传导致的RTT歧义</li><li><code>包可以被乱序确认</code><ul><li>通过<code>Stream ID</code> + <code>Offset</code>可以确认是同一个包，即使packet Number不一样</li></ul></li></ul></li></ul></li><li><code>Connection ID</code>实现了连接迁移： <ul><li>记录<code>Destination Connection ID</code>，在客户端 IP 地址、端口变化后，绕过 UDP 四元组，继续维持连接</li></ul></li><li>一个 Packet 报文中可以存放多个 <code>QUIC Frame</code>，不能超过PMTUD（1200字节） <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f443e834f43f34c9e2e0647d29b8c24c.png" alt="Img" loading="lazy"></li><li>上图Area Data即多个<code>QUIC Frame</code>，即在一个connection 中并发多个请求</li></ul></li><li><p>QUIC Frame（负责字节流有序）：</p><ul><li>一个Frame不可跨越多个Packet传输</li><li><code>Frame Type</code>： <ul><li>定义不同类型的Frame <ul><li><code>QUIC STREAM Frame</code> 应用层数据传输</li><li><code>other Frame</code> 状态管理 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c33058203fdba04e7b5337171eaf8756.png" alt="Frame通用头" loading="lazy"></li></ul></li></ul></li><li><code>QUIC STREAM Frame</code><ul><li><code>Stream Id</code> 实现有序的字节流： <ul><li>在无序的 Packet 报文中，<code>Stream Id</code>相同表示同一个HTTP消息（消息过大时，可跨Packet传输）</li><li>最低2位比特位用于识别连接的类型（单向、双向、发起者） <ul><li>最低1比特位表示流的发起者： <ul><li>0：双数流，客户端发起； 1：单数流，服务器发起</li></ul></li><li>第2个比特位识别单/双向流： <ul><li>0：双向；1：单向</li></ul></li></ul></li></ul></li><li><code>offset</code>用于重建字节流，实现消息的序列化： <ul><li>通过Offset字段完成类似于TCP协议中的Sequence序号，进行累计确认</li></ul></li><li><code>Length</code> 指明了Frame数据的长度</li><li>以下为QUIC STREAM Frame格式： <ul><li>Stream Data即HTTP/3 Frame <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7569ef8b54999da315b58a34914cf392.png" alt="Stream Frame" loading="lazy"></li></ul></li></ul></li></ul></li><li><p>HTTP/3 Frame（负责HTTP语义）： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d1d2180748b4f6e04c42da9e54754b2a.png" alt="HTTP3 通用Frame头信息" loading="lazy"></p><ul><li><code>Type</code>：类似 HTTP/2的帧类型： <ul><li>DATA帧、HEADERS帧、SETTINGS帧、GOAWAY帧、MAX_PUSH_ID帧（限制服务器推送消息数量）</li></ul></li><li><code>Frame Payload</code>： <ul><li>存放二进制的 <code>HTTP message</code></li></ul></li><li>作用： <ul><li>可跨越多个Packet</li><li>实现服务器推送</li><li>实现 QPACK 编解</li><li>权重优先级设定</li><li>流量控制</li></ul></li></ul></li><li><p>HTTP Message（具体消息内容）：</p><ul><li>通用HTTP协议数据，header、body等</li></ul></li></ul><h4 id="quic机制" tabindex="-1"><a class="header-anchor" href="#quic机制"><span>QUIC机制：</span></a></h4><h5 id="自定义连接" tabindex="-1"><a class="header-anchor" href="#自定义连接"><span>自定义连接：</span></a></h5><ul><li>不再以四元组标识，而是以一个64位的随机数作为Connection ID来标识</li><li>加密算法的版本协商与传输层握手合并完成，以减小延迟</li></ul><h5 id="自定义重传机制" tabindex="-1"><a class="header-anchor" href="#自定义重传机制"><span>自定义重传机制：</span></a></h5><ul><li><code>Packet Number</code>（数据包编号）：在QUIC协议中，每个数据包都有一个唯一的编号，用于标识数据包在传输过程中的顺序和重传情况。Packet Number 用于确保数据包按正确的顺序传输，并在需要时进行重传</li></ul><h5 id="无阻塞的多路复用" tabindex="-1"><a class="header-anchor" href="#无阻塞的多路复用"><span>无阻塞的多路复用：</span></a></h5><ul><li>同一条 QUIC Connection Id上可以创建多个 stream 来发送多个请求(跟HTTP 2.0 一致)</li><li><code>QUIC为每个Stream分配独立的滑动窗口</code>。在传输层面如果出现丢包，只影响包所在的stream，其他stream无需等待。（跟HTTP2.0差异点，因为是基于UDP的）</li></ul><h5 id="自定义流量控制" tabindex="-1"><a class="header-anchor" href="#自定义流量控制"><span>自定义流量控制：</span></a></h5><ul><li>stream级别的滑动窗口： <ol><li>QUIC 通过 <code>window_update帧</code>来告诉对端它可以接受的字节数</li><li>QUIC 窗口的起始位置为当前收到的最大 offset</li><li>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答（相信中间的空档一定会到来）</li><li><code>QUIC为每个Stream分配独立的滑动窗口</code>，相互之间不影响 窗口示意图：TCP 和 QUIC <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6fda22d5782f5f61402846f9e21d018a.png" alt="图片" loading="lazy"></li><li>可用窗口左边界： <ul><li>TCP：<code>已确认的</code>序号</li><li>QUIC：<code>收到的</code>最大Offset</li></ul></li></ol></li><li>连接级别的流量控制窗口： <ul><li>对所有的stream做整体大小控制</li></ul></li></ul><h5 id="服务器推送-server-push-cache-push-1" tabindex="-1"><a class="header-anchor" href="#服务器推送-server-push-cache-push-1"><span><code>服务器推送</code>（Server Push/ Cache Push）</span></a></h5><ul><li>作用： <ul><li>将可能会用到的数据先发送给客户端<code>缓存</code>下来，需要客户端同意</li></ul></li><li>过程： <ul><li>服务器通过请求流发送一个 <code>PUSH_PROMISE 帧</code>，使该推送请求看上去像是一个响应，然后通过<code>新的流</code>发送实际推送数据</li><li>客户端可随时通过<code>CANCEL_PUSH</code> 帧取消推送</li><li>客户端可以设置推送次数限制</li></ul></li></ul><h4 id="http-3-0机制" tabindex="-1"><a class="header-anchor" href="#http-3-0机制"><span>HTTP/3.0机制</span></a></h4><h5 id="头部压缩" tabindex="-1"><a class="header-anchor" href="#头部压缩"><span><code>头部压缩</code>：</span></a></h5><ul><li>QPACK： <ul><li>为什么要改HPACK： <ul><li>由于动态表具有时序性，QUIC中数据流互相独立，并发下因为可能还未建立动态表会导致失败</li></ul></li><li>QPACK使用两个额外的单向QUIC流，用于在两个方向上<code>传递动态表信息</code><ul><li><p><code>QPACK Encoder Stream</code>：用于传输动态表信息 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f02bf0f32626d8a7f3e43ecb3efc4291.png" alt="Img" loading="lazy"></p></li><li><p><code>QPACK Decoder Stream</code>：用于对传输内容的确认响应 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d5a20c3165d8a69314170350c88d2dab.png" alt="Img" loading="lazy"></p></li></ul></li></ul></li></ul><h5 id="二进制格式编码-1" tabindex="-1"><a class="header-anchor" href="#二进制格式编码-1"><span><code>二进制格式编码</code>：</span></a></h5><ul><li>同HTTP2.0相似，将传输信息（header+body）分割为更小的帧 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e1b1cd669b4881acee9400ff91bb680.png" alt="Img" loading="lazy"></li></ul><h5 id="http-3-0-frame" tabindex="-1"><a class="header-anchor" href="#http-3-0-frame"><span>HTTP/3.0 Frame：</span></a></h5><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/386bc276ab8dd65901f640bd19e7a20d.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>帧类型与HTTP2基本相同</li><li>流的相关功能前置到传输层QUIC实现</li><li>头部压缩算法使用QPACK</li></ul><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比：</span></a></h2><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/66735265a54c7ed385a2a94b88e4cda4.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>参考： <ul><li><a href="https://http3-explained.haxx.se/zh/why-QUIC/why-tcphol" target="_blank" rel="noopener noreferrer">https://http3-explained.haxx.se/zh/why-QUIC/why-tcphol</a></li><li><a href="https://xiaolincoding.com/network" target="_blank" rel="noopener noreferrer">https://xiaolincoding.com/network</a></li><li><a href="https://kiosk007.top/post/quic-%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener noreferrer">https://kiosk007.top/post/quic-%E5%8D%8F%E8%AE%AE/</a></li></ul></li></ul>',87)]))}]]),d=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81HTTP%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89.html","title":"08.应用层、HTTP（五层）","lang":"zh-CN","frontmatter":{"title":"08.应用层、HTTP（五层）","date":"2024-03-31T23:52:11.000Z","author":"Navyum","tags":["HTTP","HTTP2","TLS","QUIC","HTTP3"],"categories":["网络"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"icon":"bxs:hot","description":"HTTP 发送格式： 图片图片 响应格式： 图片图片 HTTPS 与HTTP相比，多了SSL/TLS 握手协议 概念：前向安全性： 密钥泄露后，即使拿到以前的记录，也无法通过密钥进行破解 RSA、DH加密算法是非前向安全的；ECDHE是前向安全的 SSL/TLS 握手协议： 目的： 通过非对称加密算法，握手后协商出对称加密密钥 花费： 2 RTT TL...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81HTTP%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"08.应用层、HTTP（五层）"}],["meta",{"property":"og:description","content":"HTTP 发送格式： 图片图片 响应格式： 图片图片 HTTPS 与HTTP相比，多了SSL/TLS 握手协议 概念：前向安全性： 密钥泄露后，即使拿到以前的记录，也无法通过密钥进行破解 RSA、DH加密算法是非前向安全的；ECDHE是前向安全的 SSL/TLS 握手协议： 目的： 通过非对称加密算法，握手后协商出对称加密密钥 花费： 2 RTT TL..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3e072d70ba9af070642f25856b372028.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:tag","content":"HTTP2"}],["meta",{"property":"article:tag","content":"TLS"}],["meta",{"property":"article:tag","content":"QUIC"}],["meta",{"property":"article:tag","content":"HTTP3"}],["meta",{"property":"article:published_time","content":"2024-03-31T23:52:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"08.应用层、HTTP（五层）\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3e072d70ba9af070642f25856b372028.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/31bc1a1c077cb1ef967ba20d2cda4c55.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6e438da1013944db557141a57deb690b.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8e1a73d1c9158a0ec1040f1777f6019e.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1277641be6ab34323df77c4f02950142.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c4803aa491fcfd5ebfde9045d606c748.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6d7699ba78eba5dae358267adbf382e8.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c42e845055af9f5a4ceb78dafd14087a.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/22170a9e46dad8ff73adff878d2ede0a.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/048a9b0325f365cd4f0bc626fa106ebf.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8fae57c8dcf3faf0f41577042bd9ec58.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7ddf8f4fadc857fe081fd2008950a987.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0e49e74abc6c7694352d3642d59bdb5d.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e1b1cd669b4881acee9400ff91bb680.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f443e834f43f34c9e2e0647d29b8c24c.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c33058203fdba04e7b5337171eaf8756.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7569ef8b54999da315b58a34914cf392.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d1d2180748b4f6e04c42da9e54754b2a.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6fda22d5782f5f61402846f9e21d018a.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f02bf0f32626d8a7f3e43ecb3efc4291.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d5a20c3165d8a69314170350c88d2dab.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e1b1cd669b4881acee9400ff91bb680.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/386bc276ab8dd65901f640bd19e7a20d.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/66735265a54c7ed385a2a94b88e4cda4.png\\"],\\"datePublished\\":\\"2024-03-31T23:52:11.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":3,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":15.51,"words":4653},"filePathRelative":"计算机网络/06.应用层、HTTP（五层）.md","localizedDate":"2024年3月31日","excerpt":"<h2>HTTP</h2>\\n<h4>发送格式：</h4>\\n<figure><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3e072d70ba9af070642f25856b372028.png\\" alt=\\"图片\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>图片</figcaption></figure>\\n<h4>响应格式：</h4>\\n<figure><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/31bc1a1c077cb1ef967ba20d2cda4c55.png\\" alt=\\"图片\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>图片</figcaption></figure>","autoDesc":true}')},36995:(i,e)=>{e.A=(i,e)=>{const l=i.__vccOpts||i;for(const[i,a]of e)l[i]=a;return l}}}]);
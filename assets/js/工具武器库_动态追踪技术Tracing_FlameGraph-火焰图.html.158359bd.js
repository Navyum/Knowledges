"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[41309],{36995:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,t]of s)a[i]=t;return a}},71266:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var t=a(6254);const e={},l=(0,a(36995).A)(e,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<p>火焰图是一种分层数据<strong>可视化工具</strong>，用于直观展示程序中时间都花在了哪里。 栈采样：每秒多次，程序中的线程会被中断，同时记录下代码中的当前位置（基于线程的指令指针），以及到达该位置所调用的函数链。聚合结果。 说明： * y轴表示：堆栈深度，主函数更靠近底部 * x轴表示：涵盖所有样本，其顺序无意义。<span style="color:rgb(255, 41, 65);">对于CPU火焰图来说，其宽度表示：该函数在 CPU 上运行或处于调用堆栈中的总时间。</span></p><h3 id="性能数据采集工具介绍" tabindex="-1"><a class="header-anchor" href="#性能数据采集工具介绍"><span>性能数据采集工具介绍</span></a></h3><h4 id="_1-使用-perf-采集数据" tabindex="-1"><a class="header-anchor" href="#_1-使用-perf-采集数据"><span>1. 使用 Perf 采集数据</span></a></h4><ul><li>优点 ： <ul><li>学习成本低： Perf 是 Linux 自带的工具，命令简单易用。</li><li>高效：直接采集 CPU 性能数据，生成火焰图的过程自动化。</li><li>准确：能够精确采集函数调用栈和执行时间。</li></ul></li><li>适用场景 ：Linux 系统下的应用程序性能分析。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  perf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> record</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -g</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">PI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">D&gt;      </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 采集数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  perf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">output.txt</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     # 转换数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  stackcollapse-perf.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">folded.txt</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 聚合数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  flamegraph.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> folded.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">flamegraph.svg</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 生成火焰图</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_2-使用-async-profiler-针对-java-应用-采集并分析" tabindex="-1"><a class="header-anchor" href="#_2-使用-async-profiler-针对-java-应用-采集并分析"><span>2. 使用 Async Profiler（针对 Java 应用）采集并分析</span></a></h4><ul><li>优点 ： <ul><li>学习成本低：专为 Java 设计，命令简单。</li><li>高效：直接采集 JVM 的性能数据，支持多种分析模式（CPU、内存、锁等）。</li><li>准确：能够精确采集 Java 方法的调用栈和执行时间。</li></ul></li><li>适用场景 ：Java 应用的性能分析。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./profiler.sh</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -f</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output.html</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">PI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">D&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h4 id="_3-使用-py-spy-针对-python-应用-采集并分析" tabindex="-1"><a class="header-anchor" href="#_3-使用-py-spy-针对-python-应用-采集并分析"><span>3. 使用 Py-Spy（针对 Python 应用）采集并分析</span></a></h4><ul><li>优点 ： <ul><li>学习成本低：无需修改代码，命令简单。</li><li>高效：直接采集 Python 程序的调用栈。</li><li>准确：能够精确采集 Python 函数的调用栈和执行时间。</li></ul></li><li>适用场景 ：Python 应用的性能分析。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">py-spy</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> record</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output.svg</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --pid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">PI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">D&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h4 id="_4-使用-pprof-针对-go-应用" tabindex="-1"><a class="header-anchor" href="#_4-使用-pprof-针对-go-应用"><span>4. 使用 pprof（针对 Go 应用）</span></a></h4><ul><li>优点 ： <ul><li>学习成本低：Go 语言自带工具，集成度高。</li><li>高效：直接采集 Go 程序的性能数据，支持多种分析模式（CPU、内存、阻塞等）。</li><li>准确：能够精确采集 Go 函数的调用栈和执行时间。</li></ul></li><li>适用场景 ：Go 应用的性能分析。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">go</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tool</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pprof</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -http=:8080</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> http://localhost:6060/debug/pprof/profile</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h4 id="_5-使用-systemtap-所有应用-采集数据" tabindex="-1"><a class="header-anchor" href="#_5-使用-systemtap-所有应用-采集数据"><span>5. 使用 systemtap（所有应用）采集数据</span></a></h4><ul><li>优点 ： <ul><li>学习成本较高：需要学习对应的systemtap语法。</li><li>高效：可以针对性的采集需要的数据，用户态、内核态都可以。</li><li>准确：精准采集特定函数、变量的使用数据。</li></ul></li><li>适用场景 ：更深层次的性能分析，适用于所有应用。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stap</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> script.stp</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -X</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> PID</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">output.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stackcollapse-stap.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">flamegraph.pl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">flamegraph.svg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="使用-flamegraph-工具进行火焰图生成" tabindex="-1"><a class="header-anchor" href="#使用-flamegraph-工具进行火焰图生成"><span>使用 FlameGraph 工具进行火焰图生成</span></a></h3><ul><li>优点 ： <ul><li>学习成本低：生成火焰图的过程自动化，命令简单。</li><li>高效：将原始数据快速转换为直观的火焰图。</li><li>准确：火焰图能够清晰展示性能瓶颈。</li></ul></li><li>适用场景 ：所有支持火焰图生成的语言和工具。</li><li>示例 ：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./stackcollapse-xxx.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> output.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">out.folded</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      # 转换数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./flamegraph.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        out.folded</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">flamegraph.svg</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 生成svg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考：</span></a></h3><p><a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener noreferrer">官方flamegraphs</a><a href="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html" target="_blank" rel="noopener noreferrer">内存frame</a></p>',16)]))}]]),h=JSON.parse('{"path":"/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/FlameGraph-%E7%81%AB%E7%84%B0%E5%9B%BE.html","title":"FlameGraph-火焰图","lang":"zh-CN","frontmatter":{"title":"FlameGraph-火焰图","date":"2025-06-17T11:26:14.000Z","author":"Navyum","tags":["性能分析","可视化","FlameGraph"],"categories":["工具","性能分析","FlameGraph"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"description":"火焰图是一种分层数据可视化工具，用于直观展示程序中时间都花在了哪里。 栈采样：每秒多次，程序中的线程会被中断，同时记录下代码中的当前位置（基于线程的指令指针），以及到达该位置所调用的函数链。聚合结果。 说明： * y轴表示：堆栈深度，主函数更靠近底部 * x轴表示：涵盖所有样本，其顺序无意义。对于CPU火焰图来说，其宽度表示：该函数在 CPU 上运行或...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/FlameGraph-%E7%81%AB%E7%84%B0%E5%9B%BE.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"FlameGraph-火焰图"}],["meta",{"property":"og:description","content":"火焰图是一种分层数据可视化工具，用于直观展示程序中时间都花在了哪里。 栈采样：每秒多次，程序中的线程会被中断，同时记录下代码中的当前位置（基于线程的指令指针），以及到达该位置所调用的函数链。聚合结果。 说明： * y轴表示：堆栈深度，主函数更靠近底部 * x轴表示：涵盖所有样本，其顺序无意义。对于CPU火焰图来说，其宽度表示：该函数在 CPU 上运行或..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T03:50:17.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"性能分析"}],["meta",{"property":"article:tag","content":"可视化"}],["meta",{"property":"article:tag","content":"FlameGraph"}],["meta",{"property":"article:published_time","content":"2025-06-17T11:26:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T03:50:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"FlameGraph-火焰图\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T11:26:14.000Z\\",\\"dateModified\\":\\"2025-06-17T03:50:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750132217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.79,"words":837},"filePathRelative":"工具武器库/动态追踪技术Tracing/FlameGraph-火焰图.md","localizedDate":"2025年6月17日","excerpt":"<p>火焰图是一种分层数据<strong>可视化工具</strong>，用于直观展示程序中时间都花在了哪里。\\n栈采样：每秒多次，程序中的线程会被中断，同时记录下代码中的当前位置（基于线程的指令指针），以及到达该位置所调用的函数链。聚合结果。\\n说明：\\n* y轴表示：堆栈深度，主函数更靠近底部\\n* x轴表示：涵盖所有样本，其顺序无意义。<span style=\\"color: rgb(255, 41, 65);\\">对于CPU火焰图来说，其宽度表示：该函数在 CPU 上运行或处于调用堆栈中的总时间。</span></p>\\n<h3>性能数据采集工具介绍</h3>\\n<h4>1. 使用 Perf 采集数据</h4>","autoDesc":true}')}}]);
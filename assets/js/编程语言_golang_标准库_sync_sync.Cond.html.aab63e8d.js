"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[93082],{19255:(e,o,t)=>{t.r(o),t.d(o,{comp:()=>i,data:()=>a});var n=t(6254);const p={},i=(0,t(36995).A)(p,[["render",function(e,o){return(0,n.uX)(),(0,n.CE)("div",null,o[0]||(o[0]=[(0,n.Fv)("<p>条件变量定义：</p><pre><code>当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，只要等待通知就好了。\n\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的\n\n方法：等待通知（wait）、单发通知（signal）和广播通知（broadcast）\n</code></pre><p>规则：</p><pre><code>利用条件变量可以实现单向的通知，而双向的通知则需要两个条件变量。这也是条件变量的基本使用规则。\n</code></pre><p>Wait： wait方法总会把当前的 goroutine 添加到通知队列的队尾</p><p>Signal： signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。这两个方法的行为决定了它们的适用场景。如果你确定只有一个 goroutine 在等待通知，或者只需唤醒任意一个 goroutine 就可以满足要求，那么使用条件变量的Signal方法就好了。</p><p>Broadcast： 通知所有通知队列的goroutine，只要你设置好各个 goroutine 所期望的共享资源状态就可以了。</p><p>wait的流程：</p><ol><li><p>把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。</p></li><li><p>解锁当前的条件变量基于的那个互斥锁。</p></li><li><p>让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个Wait方法的那行代码上。</p></li><li><p>如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的 goroutine 就会继续执行后面的代码了。 注意点：</p><p>条件变量的通知具有即时性。也就是说，如果发送通知的时候没有 goroutine 为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的 goroutine 只可能被后面的通知唤醒。</p></li></ol><p>e.g.</p><p>goroutine 1：</p><p>lock.Lock()</p><p>for mailbox == 1 {</p><pre><code>sendCond.Wait()\n</code></pre><p>}</p><p>mailbox = 1</p><p>lock.Unlock()</p><p>recvCond.Signal()</p><p>gproutine 2：</p><p>lock.RLock()</p><p>for mailbox == 0 {</p><pre><code>recvCond.Wait()\n</code></pre><p>}</p><p>mailbox = 0</p><p>lock.RUnlock()</p><p>sendCond.Signal()</p>",26)]))}]]),a=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Cond.html","title":"sync.Cond","lang":"zh-CN","frontmatter":{"title":"sync.Cond","author":"navyum","date":"2025-06-21T22:28:53.000Z","article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"category":["笔记"],"tag":["笔记"],"description":"条件变量定义： 规则： Wait： wait方法总会把当前的 goroutine 添加到通知队列的队尾 Signal： signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。这两个方法的行为决定了它们的适用场景。如果你确定只有一个 goro...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Cond.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"sync.Cond"}],["meta",{"property":"og:description","content":"条件变量定义： 规则： Wait： wait方法总会把当前的 goroutine 添加到通知队列的队尾 Signal： signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。这两个方法的行为决定了它们的适用场景。如果你确定只有一个 goro..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T14:30:17.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:published_time","content":"2025-06-21T22:28:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T14:30:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"sync.Cond\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-21T22:28:53.000Z\\",\\"dateModified\\":\\"2025-06-21T14:30:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750516217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":2,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":1.99,"words":598},"filePathRelative":"编程语言/golang/标准库/sync/sync.Cond.md","localizedDate":"2025年6月21日","excerpt":"<p>条件变量定义：</p>\\n<pre><code>当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，只要等待通知就好了。\\n\\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的\\n\\n方法：等待通知（wait）、单发通知（signal）和广播通知（broadcast）\\n</code></pre>\\n<p>规则：</p>\\n<pre><code>利用条件变量可以实现单向的通知，而双向的通知则需要两个条件变量。这也是条件变量的基本使用规则。\\n</code></pre>\\n<p>Wait： wait方法总会把当前的 goroutine 添加到通知队列的队尾</p>\\n<p>Signal： signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。这两个方法的行为决定了它们的适用场景。如果你确定只有一个 goroutine 在等待通知，或者只需唤醒任意一个 goroutine 就可以满足要求，那么使用条件变量的Signal方法就好了。</p>","autoDesc":true}')},36995:(e,o)=>{o.A=(e,o)=>{const t=e.__vccOpts||e;for(const[e,n]of o)t[e]=n;return t}}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[32502],{36995:(e,i)=>{i.A=(e,i)=>{const a=e.__vccOpts||e;for(const[e,l]of i)a[e]=l;return a}},94574:(e,i,a)=>{a.r(i),a.d(i,{comp:()=>o,data:()=>c});var l=a(6254);const t={},o=(0,a(36995).A)(t,[["render",function(e,i){return(0,l.uX)(),(0,l.CE)("div",null,i[0]||(i[0]=[(0,l.Fv)('<h3 id="rdb-redis-database" tabindex="-1"><a class="header-anchor" href="#rdb-redis-database"><span>RDB（Redis DataBase）：</span></a></h3><ul><li>含义：RDB 快照就是记录Redis<code>某一个瞬间的全部内存数据</code>，记录的是实际数据。这个文件就是RDB快照文件。</li></ul><h3 id="跟aof对比" tabindex="-1"><a class="header-anchor" href="#跟aof对比"><span>跟AOF对比：</span></a></h3><ul><li>文件内容： <ul><li>RDB 文件的内容是二进制数据（状态数据）</li><li>AOF文件内容是命令数据（操作数据）</li></ul></li><li>数据恢复效率： <ul><li>RDB 文件直接读入内存完成恢复，效率更高</li><li>AOF 需要执行操作命令，通过逐个重放命令实现恢复，效率低</li></ul></li><li>执行的进程： <ul><li>RDB 是在bgsave子进程，因为RDB需要对全量数据做写入，不能在主进程做</li><li>AOF 是在主进程，因为AOF每次只有少量命令，并且是追加写（顺序写），在主进程影响不大</li></ul></li></ul><h3 id="rdb的特性" tabindex="-1"><a class="header-anchor" href="#rdb的特性"><span>RDB的特性：</span></a></h3><ul><li><code>当前时刻</code>的<code>全量</code>数据做<code>快照</code>，所以需要控制好频率</li><li>生成RDB文件的命令： <ul><li><code>save</code>在主进程进行，会阻塞主进程</li><li><code>bgsave</code>创建<code>子进程</code>，不易阻塞主进程</li></ul></li><li>RDB 文件加载工作： <ul><li>服务器启动时<code>自动执行加载</code></li></ul></li><li>通过<code>写时复制COW</code>（copy on write），做快照时，不阻塞主进程的修改操作。</li><li>当前RDB过程中，增量数据无法在当前周期进行备份，需要等到下一次RDB。RDB保存的是fork子进程那个时刻的数据快照</li><li>缺点： <ul><li>快照频率太低：两次快照期间如果宕机，则只能恢复到最近一次快照的数据，期间的数据都会丢失</li><li>快照频率太高：频繁fork子进程和全量写磁盘，影响性能</li></ul></li></ul><h3 id="rdb-完整过程" tabindex="-1"><a class="header-anchor" href="#rdb-完整过程"><span>RDB 完整过程：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/55ab892415260f6ef29f765a0f98eccb.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ol><li>bgsave fork出子进程，子进程享有主进程的物理内存数据</li><li>子进程进行内存数据写磁盘操作</li><li>期间如果主进程发生数据修改，如键值对C，那么会触发<code>写时复制</code>，生成该数据的副本（键值对 C’），主线程在这个数据副本上进行修改。</li><li>bgsave 子进程不受影响，继续把原来的数据写入 RDB 文件</li></ol><h3 id="混合持久化" tabindex="-1"><a class="header-anchor" href="#混合持久化"><span>混合持久化：</span></a></h3><ul><li><code>发生时机</code>： <ul><li><code>AOF 日志重写</code>发生时</li></ul></li><li><code>aof-use-rdb-preamble</code>配置： <ul><li>yes 开启</li></ul></li><li>特点：结合了RDB的恢复速度和AOF的数据丢失少</li></ul><h3 id="混合持久化过程" tabindex="-1"><a class="header-anchor" href="#混合持久化过程"><span>混合持久化过程：</span></a></h3><ol><li>当<code>AOF 重写日志</code>发生时：</li><li>主进程fork 出重写子进程<code>bgrewriteaof</code></li><li>子进程先将与主进程共享的内存数据以 <code>RDB 方式</code>写入到<code>新的AOF 文件</code></li><li>期间，主线程处理的<code>增量写命令</code>会被记录在<code>AOF 重写缓冲区</code></li><li>当<code>RDB方式</code>完成后，<code>AOF 重写缓冲区</code>的数据会以<code>AOF格式</code>，追加写入到这个新的AOF文件后面</li><li><code>AOF 重写缓冲区</code>的数据全部写入完成后，通知主进程进行新、旧AOF文件替换</li></ol><h3 id="混合持久化文件格式" tabindex="-1"><a class="header-anchor" href="#混合持久化文件格式"><span>混合持久化文件格式：</span></a></h3><ul><li>前半部分为RDB格式</li><li>后半部分为AOF格式 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/742cb8891521a0ade89436926e7fa235.png" alt="Img" loading="lazy"></li></ul><h3 id="持久化的选择" tabindex="-1"><a class="header-anchor" href="#持久化的选择"><span>持久化的选择：</span></a></h3><ol><li>数据<code>不能丢失</code>时，内存快照<code>RDB</code>和<code>AOF</code>的混合使用是一个很好的选择</li><li>如果允许<code>分钟级别的数据丢失</code>，可以只使用RDB</li><li>其他场景建议使用<code>AOF</code>。 <ul><li>使用AOF做持久化，刷盘策略优先使用 <code>everysec</code> 的配置选项，因为它在可靠性和性能之间取了一个平衡</li></ul></li></ol>',17)]))}]]),c=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/07.%E6%8C%81%E4%B9%85%E5%8C%96-RDB.html","title":"07.持久化-RDB","lang":"zh-CN","frontmatter":{"title":"07.持久化-RDB","date":"2025-06-17T15:38:19.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","持久化","RDB"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"RDB（Redis DataBase）： 含义：RDB 快照就是记录Redis某一个瞬间的全部内存数据，记录的是实际数据。这个文件就是RDB快照文件。 跟AOF对比： 文件内容： RDB 文件的内容是二进制数据（状态数据） AOF文件内容是命令数据（操作数据） 数据恢复效率： RDB 文件直接读入内存完成恢复，效率更高 AOF 需要执行操作命令，通过逐...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/07.%E6%8C%81%E4%B9%85%E5%8C%96-RDB.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"07.持久化-RDB"}],["meta",{"property":"og:description","content":"RDB（Redis DataBase）： 含义：RDB 快照就是记录Redis某一个瞬间的全部内存数据，记录的是实际数据。这个文件就是RDB快照文件。 跟AOF对比： 文件内容： RDB 文件的内容是二进制数据（状态数据） AOF文件内容是命令数据（操作数据） 数据恢复效率： RDB 文件直接读入内存完成恢复，效率更高 AOF 需要执行操作命令，通过逐..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/55ab892415260f6ef29f765a0f98eccb.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"持久化"}],["meta",{"property":"article:tag","content":"RDB"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:38:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"07.持久化-RDB\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/55ab892415260f6ef29f765a0f98eccb.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/742cb8891521a0ade89436926e7fa235.png\\"],\\"datePublished\\":\\"2025-06-17T15:38:19.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.98,"words":894},"filePathRelative":"常用软件/数据库/redis/07.持久化-RDB.md","localizedDate":"2025年6月17日","excerpt":"<h3>RDB（Redis DataBase）：</h3>\\n<ul>\\n<li>含义：RDB 快照就是记录Redis<code>某一个瞬间的全部内存数据</code>，记录的是实际数据。这个文件就是RDB快照文件。</li>\\n</ul>\\n<h3>跟AOF对比：</h3>\\n<ul>\\n<li>文件内容：\\n<ul>\\n<li>RDB 文件的内容是二进制数据（状态数据）</li>\\n<li>AOF文件内容是命令数据（操作数据）</li>\\n</ul>\\n</li>\\n<li>数据恢复效率：\\n<ul>\\n<li>RDB 文件直接读入内存完成恢复，效率更高</li>\\n<li>AOF 需要执行操作命令，通过逐个重放命令实现恢复，效率低</li>\\n</ul>\\n</li>\\n<li>执行的进程：\\n<ul>\\n<li>RDB 是在bgsave子进程，因为RDB需要对全量数据做写入，不能在主进程做</li>\\n<li>AOF 是在主进程，因为AOF每次只有少量命令，并且是追加写（顺序写），在主进程影响不大</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[72884],{36995:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}},96390:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>n,data:()=>s});var i=t(6254);const r={},n=(0,t(36995).A)(r,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h3 id="动态追踪原理" tabindex="-1"><a class="header-anchor" href="#动态追踪原理"><span>动态追踪原理</span></a></h3><p>动态追踪工具在逻辑上比较简单：大多是通过类C语言创建一个脚本，通过编译器翻译成探测代码。<strong>通过一个内核地址模块加载探测代码到内核地址空间，然后patch到当前内核的二进制代码中</strong>。探针将收集的数据写到中间缓冲（这些buffers往往是lock-free的，所以他们对内核性能有较少影响，且不需要切换上下文到追踪程序）。另一个独立的实体消费者读取这些buffers，然后输出数据。</p><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8299a9ca33a70fb4ff37387be18a0b2c.png" width="60%"></p><h3 id="linux系统动态追踪工具" tabindex="-1"><a class="header-anchor" href="#linux系统动态追踪工具"><span>linux系统动态追踪工具</span></a></h3><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ea0a557b76ea96275495ade94475e2b4.png" width="40%"></p><h4 id="查看可以进行跟踪的内核符号-kprobe" tabindex="-1"><a class="header-anchor" href="#查看可以进行跟踪的内核符号-kprobe"><span>查看可以进行跟踪的内核符号-kprobe</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sudo bpftrace -l</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="查看可以进行跟踪的用户态符号-uprobe" tabindex="-1"><a class="header-anchor" href="#查看可以进行跟踪的用户态符号-uprobe"><span>查看可以进行跟踪的用户态符号-uprobe</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>nm /path-to-binary</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="如何选择" tabindex="-1"><a class="header-anchor" href="#如何选择"><span>如何选择？</span></a></h3><ul><li>内核版本比较早，选择systemtap</li><li>追求体验，选择systemtap</li><li>追求性能，选择bpftrace</li><li>追求安全性，选择bpftrace</li></ul><h3 id="关于静态检测和动态追踪" tabindex="-1"><a class="header-anchor" href="#关于静态检测和动态追踪"><span>关于静态检测和动态追踪</span></a></h3><p>静态检测：对静态快照的检测，一般是出现问题后，对coredump进行&quot;尸检&quot; 动态追踪：实时动态聚合，一般是出现问题后，在程序尚未出现异常前，通过实时观察程序变化，进行&quot;体检&quot;</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p><a href="https://github.com/lichuang/awesome-systemtap-cn?tab=readme-ov-file" target="_blank" rel="noopener noreferrer">awesome-systemtap</a></p>',15)]))}]]),s=JSON.parse('{"path":"/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/","title":"静态动态追踪原理","lang":"zh-CN","frontmatter":{"title":"静态动态追踪原理","date":"2025-06-17T11:26:41.000Z","author":"Navyum","tags":["性能分析","可视化","trace"],"categories":["工具","性能分析"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"description":"动态追踪原理 动态追踪工具在逻辑上比较简单：大多是通过类C语言创建一个脚本，通过编译器翻译成探测代码。通过一个内核地址模块加载探测代码到内核地址空间，然后patch到当前内核的二进制代码中。探针将收集的数据写到中间缓冲（这些buffers往往是lock-free的，所以他们对内核性能有较少影响，且不需要切换上下文到追踪程序）。另一个独立的实体消费者读取...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"静态动态追踪原理"}],["meta",{"property":"og:description","content":"动态追踪原理 动态追踪工具在逻辑上比较简单：大多是通过类C语言创建一个脚本，通过编译器翻译成探测代码。通过一个内核地址模块加载探测代码到内核地址空间，然后patch到当前内核的二进制代码中。探针将收集的数据写到中间缓冲（这些buffers往往是lock-free的，所以他们对内核性能有较少影响，且不需要切换上下文到追踪程序）。另一个独立的实体消费者读取..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T03:50:17.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"性能分析"}],["meta",{"property":"article:tag","content":"可视化"}],["meta",{"property":"article:tag","content":"trace"}],["meta",{"property":"article:published_time","content":"2025-06-17T11:26:41.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T03:50:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"静态动态追踪原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T11:26:41.000Z\\",\\"dateModified\\":\\"2025-06-17T03:50:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750132217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":1.31,"words":394},"filePathRelative":"工具武器库/动态追踪技术Tracing/README.md","localizedDate":"2025年6月17日","excerpt":"<h3>动态追踪原理</h3>\\n<p>动态追踪工具在逻辑上比较简单：大多是通过类C语言创建一个脚本，通过编译器翻译成探测代码。<strong>通过一个内核地址模块加载探测代码到内核地址空间，然后patch到当前内核的二进制代码中</strong>。探针将收集的数据写到中间缓冲（这些buffers往往是lock-free的，所以他们对内核性能有较少影响，且不需要切换上下文到追踪程序）。另一个独立的实体消费者读取这些buffers，然后输出数据。</p>\\n<p align=\\"center\\"><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8299a9ca33a70fb4ff37387be18a0b2c.png\\" width=\\"60%\\"></p>","autoDesc":true}')}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[21416],{36995:(e,o)=>{o.A=(e,o)=>{const l=e.__vccOpts||e;for(const[e,i]of o)l[e]=i;return l}},93669:(e,o,l)=>{l.r(o),l.d(o,{comp:()=>n,data:()=>r});var i=l(6254);const t={},n=(0,l(36995).A)(t,[["render",function(e,o){return(0,i.uX)(),(0,i.CE)("div",null,o[0]||(o[0]=[(0,i.Fv)('<h3 id="update-t-user-set-name-x-where-id-1" tabindex="-1"><a class="header-anchor" href="#update-t-user-set-name-x-where-id-1"><span>UPDATE t_user SET name = &#39;x&#39; WHERE id = 1</span></a></h3><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： <ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新(id非唯一索引的前提下)；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： <ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务，InnoDB 层更新记录前，首先要记录相应的 <code>undo log</code>，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 <code>undo log</code>，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，先生成对应<code>redo log</code>，并存入redo log buffer里面。当事务提交时，将该语句生成的redo log按组为单位，写入redo log file。然后更新buffer pool中的数据页，将其插入<code>flush 链表</code>（如果不在其中），标记为脏页、记录当前redo log对应的lsn到该页的oldest_modification。这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。（这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。但事务提交时必须要将redo log持久化）</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 <code>binlog</code>，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘，然后进行第二阶段的提交。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）： <ul><li>prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li>commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ul></li><li>至此，一条更新语句执行完成。</li></ol>',2)]))}]]),r=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/17.Sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html","title":"17.Sql是如何执行的","lang":"zh-CN","frontmatter":{"title":"17.Sql是如何执行的","date":"2025-06-17T15:22:27.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","SQL"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"UPDATE t_user SET name = \'x\' WHERE id = 1 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新(id非唯一索引的前提下)； 如果记录不在 buffer pool，将数据页从磁盘...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/17.Sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"17.Sql是如何执行的"}],["meta",{"property":"og:description","content":"UPDATE t_user SET name = \'x\' WHERE id = 1 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新(id非唯一索引的前提下)； 如果记录不在 buffer pool，将数据页从磁盘..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"SQL"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:22:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"17.Sql是如何执行的\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:22:27.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.54,"words":763},"filePathRelative":"常用软件/数据库/mysql/17.Sql是如何执行的.md","localizedDate":"2025年6月17日","excerpt":"<h3>UPDATE t_user SET name = \'x\' WHERE id = 1</h3>\\n<ol>\\n<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：\\n<ul>\\n<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新(id非唯一索引的前提下)；</li>\\n<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>\\n</ul>\\n</li>\\n<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\\n<ul>\\n<li>如果一样的话就不进行后续更新流程；</li>\\n<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>\\n</ul>\\n</li>\\n<li>开启事务，InnoDB 层更新记录前，首先要记录相应的 <code>undo log</code>，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 <code>undo log</code>，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>\\n<li>InnoDB 层开始更新记录，先生成对应<code>redo log</code>，并存入redo log buffer里面。当事务提交时，将该语句生成的redo log按组为单位，写入redo log file。然后更新buffer pool中的数据页，将其插入<code>flush 链表</code>（如果不在其中），标记为脏页、记录当前redo log对应的lsn到该页的oldest_modification。这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。（这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。但事务提交时必须要将redo log持久化）</li>\\n<li>至此，一条记录更新完了。</li>\\n<li>在一条更新语句执行完成后，然后开始记录该语句对应的 <code>binlog</code>，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘，然后进行第二阶段的提交。</li>\\n<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：\\n<ul>\\n<li>prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>\\n<li>commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>\\n</ul>\\n</li>\\n<li>至此，一条更新语句执行完成。</li>\\n</ol>","autoDesc":true}')}}]);
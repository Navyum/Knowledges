"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[37541],{36995:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,i]of n)a[s]=i;return a}},89624:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>p});var i=a(6254);const e={},l=(0,a(36995).A)(e,[["render",function(s,n){return(0,i.uX)(),(0,i.CE)("div",null,n[0]||(n[0]=[(0,i.Fv)('<h2 id="计数、桶、基数" tabindex="-1"><a class="header-anchor" href="#计数、桶、基数"><span>计数、桶、基数</span></a></h2><h3 id="桶排序-bucket-sort" tabindex="-1"><a class="header-anchor" href="#桶排序-bucket-sort"><span>桶排序（Bucket Sort）：</span></a></h3><ul><li><p><u>思想：它通过设置一些具有有限数量、大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并</u></p></li><li><p>稳定排序、非原地排序，需要借助k个桶和n个元素的数组</p></li><li><p><span style="color:rgb(255, 41, 65);"> 非比较排序算法 </span></p></li><li><p>算法流程：条件 一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数组，其元素是范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 内的浮点数</p><ol><li>初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个桶，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素分配到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个桶中。</li><li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li><li>按照桶从小到大的顺序合并结果。</li></ol></li><li><p>桶排序的优化：</p><ul><li>将元素均匀分配到各个桶中，时间复杂度趋近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。可以借助值的概率分布。 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b5e1ed580a44cb933621d58303cc112.png" alt="Img" loading="lazy"></li></ul></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e071c5a7c5c6f087fb9dc231bda365b9.png" alt="Img" loading="lazy"></p></li><li><p>代码：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 桶排序 */</span></span>\n<span class="line"><span>func bucketSort(nums []float64) {</span></span>\n<span class="line"><span>    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span>\n<span class="line"><span>    k := len(nums) / 2</span></span>\n<span class="line"><span>    buckets := make([][]float64, k)</span></span>\n<span class="line"><span>    for i := 0; i &lt; k; i++ {</span></span>\n<span class="line"><span>        buckets[i] = make([]float64, 0)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 1. 将数组元素分配到各个桶中</span></span>\n<span class="line"><span>    for _, num := range nums {</span></span>\n<span class="line"><span>        // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span>\n<span class="line"><span>        i := int(num * float64(k))</span></span>\n<span class="line"><span>        // 将 num 添加进桶 i</span></span>\n<span class="line"><span>        buckets[i] = append(buckets[i], num)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 2. 对各个桶执行排序</span></span>\n<span class="line"><span>    for i := 0; i &lt; k; i++ {</span></span>\n<span class="line"><span>        // 使用内置切片排序函数，也可以替换成其他排序算法</span></span>\n<span class="line"><span>        sort.Float64s(buckets[i])</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 3. 遍历桶合并结果</span></span>\n<span class="line"><span>    i := 0</span></span>\n<span class="line"><span>    for _, bucket := range buckets {</span></span>\n<span class="line"><span>        for _, num := range bucket {</span></span>\n<span class="line"><span>            nums[i] = num</span></span>\n<span class="line"><span>            i++</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="计数排序-counting-sort" tabindex="-1"><a class="header-anchor" href="#计数排序-counting-sort"><span>计数排序（Counting Sort）：</span></a></h3><ul><li><p><u>思想：对于给定的输入序列中的每一个元素，确定小于该元素的元素个数，利用这个信息将该元素直接存放到输出序列的相应位置上。</u></p></li><li><p><span style="color:rgb(255, 41, 65);">本质上，计数排序是桶排序在整型数据下的一个特例</span></p></li><li><p>稳定排序</p></li><li><p><span style="color:rgb(255, 41, 65);">非比较排序算法</span></p></li><li><p>算法流程：</p><ol><li>遍历数组，找出其中的最大数字，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，然后创建一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的辅助数组 <code>counter</code> 。</li><li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 即可。</li><li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li></ol></li><li><p><code>前缀和</code>：</p><ul><li><p><code>counter</code>的前缀和计算方法：</p><ul><li>索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code>个元素之和，公式：</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>prefix</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></munderover><mtext>counter[j]</mtext></mrow><annotation encoding="application/x-tex">\\text{prefix}[i] = \\sum_{j=0}^i \\text{counter[j]} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">prefix</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">counter[j]</span></span></span></span></span></span></p></li><li><p>前缀和的具体意义：</p><ul><li><code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引。</li><li>它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。 <ol><li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li><li>令前缀和 <code>prefix[num]</code> 减小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，从而得到下次放置 <code>num</code> 的索引。</li></ol></li></ul></li></ul></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/cf794ca902c36e96b73ed40c04a5040e.png" alt="Img" loading="lazy"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d7632f76603f0840d61e5a380bcbea6c.png" alt="Img" loading="lazy"></p></li><li><p>局限性：</p><ul><li>计数排序只适用于非负整数</li><li>计数排序适用于数据量大但<code>数据范围较小</code>的情况</li></ul></li><li><p>代码：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 计数排序 */</span></span>\n<span class="line"><span>// 完整实现，可排序对象，并且是稳定排序</span></span>\n<span class="line"><span>func countingSort(nums []int) {</span></span>\n<span class="line"><span>    // 1. 统计数组最大元素 m</span></span>\n<span class="line"><span>    m := 0</span></span>\n<span class="line"><span>    for _, num := range nums {</span></span>\n<span class="line"><span>        if num &gt; m {</span></span>\n<span class="line"><span>            m = num</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 2. 统计各数字的出现次数</span></span>\n<span class="line"><span>    // counter[num] 代表 num 的出现次数</span></span>\n<span class="line"><span>    counter := make([]int, m+1)</span></span>\n<span class="line"><span>    for _, num := range nums {</span></span>\n<span class="line"><span>        counter[num]++</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span>\n<span class="line"><span>    // 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span>\n<span class="line"><span>    for i := 0; i &lt; m; i++ {</span></span>\n<span class="line"><span>        counter[i+1] += counter[i]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span>\n<span class="line"><span>    // 初始化数组 res 用于记录结果</span></span>\n<span class="line"><span>    n := len(nums)</span></span>\n<span class="line"><span>    res := make([]int, n)</span></span>\n<span class="line"><span>    for i := n - 1; i &gt;= 0; i-- {</span></span>\n<span class="line"><span>        num := nums[i]</span></span>\n<span class="line"><span>        // 将 num 放置到对应索引处</span></span>\n<span class="line"><span>        res[counter[num]-1] = num</span></span>\n<span class="line"><span>        // 令前缀和自减 1 ，得到下次放置 num 的索引</span></span>\n<span class="line"><span>        counter[num]--</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 使用结果数组 res 覆盖原数组 nums</span></span>\n<span class="line"><span>    copy(nums, res)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="基数排序-radix-sort" tabindex="-1"><a class="header-anchor" href="#基数排序-radix-sort"><span>基数排序（Radix Sort）：</span></a></h3><ul><li><u>核心思想与计数排序一致，也通过统计个数来实现排序。将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次按照每个位上的数值进行排序。</u></li><li>稳定排序、非就地排序</li><li><span style="color:rgb(255, 41, 65);">非比较排序算法</span></li><li>算法流程： <ol><li>初始化位数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li><li>对学号的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位执行“计数排序”。完成后，数据会根据第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位从小到大排序。</li><li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li></ol></li><li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span>\n<span class="line"><span>func digit(num, exp int) int {</span></span>\n<span class="line"><span>    // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span>\n<span class="line"><span>    return (num / exp) % 10</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 计数排序（根据 nums 第 k 位排序） */</span></span>\n<span class="line"><span>func countingSortDigit(nums []int, exp int) {</span></span>\n<span class="line"><span>    // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span>\n<span class="line"><span>    counter := make([]int, 10)</span></span>\n<span class="line"><span>    n := len(nums)</span></span>\n<span class="line"><span>    // 统计 0~9 各数字的出现次数</span></span>\n<span class="line"><span>    for i := 0; i &lt; n; i++ {</span></span>\n<span class="line"><span>        d := digit(nums[i], exp) // 获取 nums[i] 第 k 位，记为 d</span></span>\n<span class="line"><span>        counter[d]++             // 统计数字 d 的出现次数</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 求前缀和，将“出现个数”转换为“数组索引”</span></span>\n<span class="line"><span>    for i := 1; i &lt; 10; i++ {</span></span>\n<span class="line"><span>        counter[i] += counter[i-1]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span>\n<span class="line"><span>    res := make([]int, n)</span></span>\n<span class="line"><span>    for i := n - 1; i &gt;= 0; i-- {</span></span>\n<span class="line"><span>        d := digit(nums[i], exp)</span></span>\n<span class="line"><span>        j := counter[d] - 1 // 获取 d 在数组中的索引 j</span></span>\n<span class="line"><span>        res[j] = nums[i]    // 将当前元素填入索引 j</span></span>\n<span class="line"><span>        counter[d]--        // 将 d 的数量减 1</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 使用结果覆盖原数组 nums</span></span>\n<span class="line"><span>    for i := 0; i &lt; n; i++ {</span></span>\n<span class="line"><span>        nums[i] = res[i]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 基数排序 */</span></span>\n<span class="line"><span>func radixSort(nums []int) {</span></span>\n<span class="line"><span>    // 获取数组的最大元素，用于判断最大位数</span></span>\n<span class="line"><span>    max := math.MinInt</span></span>\n<span class="line"><span>    for _, num := range nums {</span></span>\n<span class="line"><span>        if num &gt; max {</span></span>\n<span class="line"><span>            max = num</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 按照从低位到高位的顺序遍历</span></span>\n<span class="line"><span>    for exp := 1; max &gt;= exp; exp *= 10 {</span></span>\n<span class="line"><span>        // 对数组元素的第 k 位执行计数排序</span></span>\n<span class="line"><span>        // k = 1 -&gt; exp = 1</span></span>\n<span class="line"><span>        // k = 2 -&gt; exp = 10</span></span>\n<span class="line"><span>        // 即 exp = 10^(k-1)</span></span>\n<span class="line"><span>        countingSortDigit(nums, exp)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',7)]))}]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html","title":"桶、计数、基数","lang":"zh-CN","frontmatter":{"title":"桶、计数、基数","author":"navyum","date":"2025-06-15T00:00:00.000Z","article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法","排序算法"],"tag":["桶排序","计数排序","基数排序"],"description":"计数、桶、基数 桶排序（Bucket Sort）： 思想：它通过设置一些具有有限数量、大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并 稳定排序、非原地排序，需要借助k个桶和n个元素的数组 非比较排序算法 算法流程：条件 一个长度为 n 的数组，其元素是范围 [0,1) 内的...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"桶、计数、基数"}],["meta",{"property":"og:description","content":"计数、桶、基数 桶排序（Bucket Sort）： 思想：它通过设置一些具有有限数量、大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并 稳定排序、非原地排序，需要借助k个桶和n个元素的数组 非比较排序算法 算法流程：条件 一个长度为 n 的数组，其元素是范围 [0,1) 内的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b5e1ed580a44cb933621d58303cc112.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"桶排序"}],["meta",{"property":"article:tag","content":"计数排序"}],["meta",{"property":"article:tag","content":"基数排序"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"桶、计数、基数\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b5e1ed580a44cb933621d58303cc112.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e071c5a7c5c6f087fb9dc231bda365b9.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/cf794ca902c36e96b73ed40c04a5040e.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d7632f76603f0840d61e5a380bcbea6c.png\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":5.83,"words":1748},"filePathRelative":"算法数据结构/算法/2.排序/O(n+k)/桶、计数、基数.md","localizedDate":"2025年6月15日","excerpt":"<h2>计数、桶、基数</h2>\\n<h3>桶排序（Bucket Sort）：</h3>\\n<ul>\\n<li>\\n<p><u>思想：它通过设置一些具有有限数量、大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并</u></p>\\n</li>\\n<li>\\n<p>稳定排序、非原地排序，需要借助k个桶和n个元素的数组</p>\\n</li>\\n<li>\\n<p><span style=\\"color: rgb(255, 41, 65);\\"> 非比较排序算法 </span></p>\\n</li>\\n<li>\\n<p>算法流程：条件 一个长度为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\"application/x-tex\\">n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">n</span></span></span></span> 的数组，其元素是范围 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">[</mo><mn>0</mn><mo separator=\\"true\\">,</mo><mn>1</mn><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">[0, 1)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">[</span><span class=\\"mord\\">0</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mclose\\">)</span></span></span></span> 内的浮点数</p>\\n<ol>\\n<li>初始化 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\\"application/x-tex\\">k</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03148em;\\">k</span></span></span></span> 个桶，将 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\"application/x-tex\\">n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">n</span></span></span></span> 个元素分配到 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\\"application/x-tex\\">k</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03148em;\\">k</span></span></span></span> 个桶中。</li>\\n<li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li>\\n<li>按照桶从小到大的顺序合并结果。</li>\\n</ol>\\n</li>\\n<li>\\n<p>桶排序的优化：</p>\\n<ul>\\n<li>将元素均匀分配到各个桶中，时间复杂度趋近于<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>O</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">O(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>。可以借助值的概率分布。\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b5e1ed580a44cb933621d58303cc112.png\\" alt=\\"Img\\" loading=\\"lazy\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>图解：\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e071c5a7c5c6f087fb9dc231bda365b9.png\\" alt=\\"Img\\" loading=\\"lazy\\"></p>\\n</li>\\n<li>\\n<p>代码：</p>\\n<div class=\\"language-golang line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"golang\\" data-title=\\"golang\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/* 桶排序 */</span></span>\\n<span class=\\"line\\"><span>func bucketSort(nums []float64) {</span></span>\\n<span class=\\"line\\"><span>    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span>\\n<span class=\\"line\\"><span>    k := len(nums) / 2</span></span>\\n<span class=\\"line\\"><span>    buckets := make([][]float64, k)</span></span>\\n<span class=\\"line\\"><span>    for i := 0; i &lt; k; i++ {</span></span>\\n<span class=\\"line\\"><span>        buckets[i] = make([]float64, 0)</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    // 1. 将数组元素分配到各个桶中</span></span>\\n<span class=\\"line\\"><span>    for _, num := range nums {</span></span>\\n<span class=\\"line\\"><span>        // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span>\\n<span class=\\"line\\"><span>        i := int(num * float64(k))</span></span>\\n<span class=\\"line\\"><span>        // 将 num 添加进桶 i</span></span>\\n<span class=\\"line\\"><span>        buckets[i] = append(buckets[i], num)</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    // 2. 对各个桶执行排序</span></span>\\n<span class=\\"line\\"><span>    for i := 0; i &lt; k; i++ {</span></span>\\n<span class=\\"line\\"><span>        // 使用内置切片排序函数，也可以替换成其他排序算法</span></span>\\n<span class=\\"line\\"><span>        sort.Float64s(buckets[i])</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    // 3. 遍历桶合并结果</span></span>\\n<span class=\\"line\\"><span>    i := 0</span></span>\\n<span class=\\"line\\"><span>    for _, bucket := range buckets {</span></span>\\n<span class=\\"line\\"><span>        for _, num := range bucket {</span></span>\\n<span class=\\"line\\"><span>            nums[i] = num</span></span>\\n<span class=\\"line\\"><span>            i++</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>","autoDesc":true}')}}]);
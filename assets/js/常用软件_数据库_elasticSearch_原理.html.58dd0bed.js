"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[57305],{36995:(i,l)=>{l.A=(i,l)=>{const e=i.__vccOpts||i;for(const[i,n]of l)e[i]=n;return e}},41161:(i,l,e)=>{e.r(l),e.d(l,{comp:()=>t,data:()=>s});var n=e(6254);const a={},t=(0,e(36995).A)(a,[["render",function(i,l){return(0,n.uX)(),(0,n.CE)("div",null,l[0]||(l[0]=[(0,n.Fv)('<ul><li>基于 lucence 引擎</li><li>通过关键词进行信息检索，搜索场景</li></ul><h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础：</span></a></h3><h4 id="倒排索引" tabindex="-1"><a class="header-anchor" href="#倒排索引"><span>倒排索引：</span></a></h4><ul><li>什么是倒排索引： <ul><li>一个用于搜索的数据结构</li></ul></li><li>倒排索引的核心概念： <ul><li><p>词项 term：</p><ul><li>将文本进行分词（LLM里面叫token化）后得到词项，词项就是一堆</li></ul></li><li><p>词项字典 Term Dictionary：</p><ul><li>将词项进行排序后得到词项字典，词项数量庞大时，可以通过二分法快速查询（此处可类比mysql的Page Dictionary作用也相似）</li><li>词项字典存在磁盘中，数据大</li><li>实际访问时先通过内存中的Term index，找到前缀匹配的词项位置，然后通过少量查找，定位到词项</li></ul></li><li><p>Posting List：</p><ul><li>作用：记录每个词项对应的文本ID的集合和其他信息</li><li>Posting List包含：文本ID的集合、词项在每个文本内的offset、词频 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c151134facc7b3f4784d776dd075895e.png" width="60%"></li></ul></li><li><p>Term Index：</p><ul><li>作用：通过内存加速搜索</li><li>结构：基于词项前缀生成的一个精简的树结构（可对比参考跳表、b+树）</li><li>特点：词项索引存放在内存中，数据小，可以方便的快速查询</li><li>查询：先通过词项索引，找到词项在词项字典的大概位置，然后到词项字典中再查找</li><li>具体实现 FST 有限状态机：（可对比Tire树） <ul><li>FST的特点：（本质是有向图结构） <ul><li>压缩性：FST通过共享公共前缀和后缀，大大减少了存储空间</li><li>高效查找：FST允许在子线性时间内查找词项，非常适合用于大规模的文本搜索</li><li>自动补全：FST还支持前缀查找和自动补全功能，这对于搜索引擎的实现非常有用 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d6b55b19a41c4fd1ce7cff10414833ea.png" width="60%"></li></ul></li></ul></li></ul></li><li><p>Stored Fields：<code>行式存储</code></p><ul><li>作用：存放文件的原始信息</li><li>查询：可以通过文本ID，从Stored Fields，获取出整个文本内容（此处可类比MyISAM引擎） <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e8bad19ce7b3ca3cab2859cf68f5909.png" width="60%"></li></ul></li><li><p>Doc Values：<code>列式存储</code></p><ul><li>作用：用于排序和聚合</li><li>说明：对某个字段排序文档，比如按时间、价格排序场景时，提升查询速度（此处可对比Mysql的二级索引）</li><li>原理：将散落在各个文档的某个字段集中存放在一起， <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/14830fed46856b3b0f571f0aae4c3d42.png" width="60%"></li></ul></li><li><p>segment：</p><ul><li>说明：segment是具备完整搜索功能的最小单元</li><li>组成：inverted index、Term index、stored fields、doc values共同构成一个segment</li><li>segment读写规则： <ul><li>写入： <ul><li>将多个文档生成一个segment，生成后，segment不能再被修改</li><li>如果有新文档，则新生成一个 segment</li></ul></li><li>读取： <ul><li>并发同时读多个segment，并进行聚合操作</li></ul></li></ul></li><li>segment合并： <ul><li>避免segment过多影响性能、避免文件句柄耗尽</li><li>不定期将多个小segment合并</li><li>segment合并过程：待补充</li><li>segment合并中的查询：待补充 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9e2dd79d772f594f9beff0dc14e80f44.png" width="60%"></li></ul></li></ul></li><li><p>lucene：</p><ul><li>单机文本检索库，由多个segment构成</li></ul></li></ul></li></ul><h3 id="高性能" tabindex="-1"><a class="header-anchor" href="#高性能"><span>高性能：</span></a></h3><h4 id="减少资源竞争" tabindex="-1"><a class="header-anchor" href="#减少资源竞争"><span>减少资源竞争：</span></a></h4><ul><li><p>对写入lucene 的数据进行分类：</p><ul><li>每一类是一个独立的 <code>Index Name</code>（此处类比Mysql的分库、消息队列的Topic）</li><li>读取数据时，指定搜索的Index Name <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e5f87a5601d552841305a690b19e4800.png" width="60%"></li></ul></li><li><p>对lucene进行拆分：</p><ul><li>一个lucene拆分为多个<code>shard</code>（此处类比消息队列的分区）</li><li>每个shard分片本质上就是一个独立的 lucene 库 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ff251a830ec2a93a8c26a4741b54a301.png" width="60%"></li></ul></li></ul><h3 id="可扩展" tabindex="-1"><a class="header-anchor" href="#可扩展"><span>可扩展：</span></a></h3><ul><li>横向扩展，从单个节点Node变成多个，提高CPU、内存上限</li><li>如何拆分？ <ul><li>按照shard粒度，将一个lucene对应的多个shard分散到多个Node</li><li>这样一个Node拥有多个lucene的部分shard</li><li><strong>存疑？es集群的扩容如何进行？</strong><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/61ef4ed4d8a167060d6e034de20c2fb4.png" width="60%"></li></ul></li></ul><h3 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用"><span>高可用：</span></a></h3><ul><li><p>replication机制</p><ul><li>按照shard粒度，设置replicas副本，这样shard就有了主分片、副分片的区分</li><li>一个主分片拥有多个副分片</li></ul></li><li><p>Node职责/角色分化：</p><ul><li>主节点 (Master Node) <ul><li>负责管理集群的</li></ul></li><li>数据节点 (Data Node) <ul><li>负责存储管理数据</li></ul></li><li>协调节点 (Coordinate Node) <ul><li>负责接受客户端搜索查询请求，这个协调节点不做选主操作（该协调节点主要做路由转发、聚合操作，类比Mysql的server层） <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4b78ab0d2ece78e149cc2c86dcdbee06.png" width="60%"></li></ul></li></ul></li><li><p>中心化/去中心化：</p><ul><li>中心化：引入中心节点zookeeper，进行协调选主、Node间的通信（7.x版本开始被抛弃）</li><li>去中心化：（主流） <ul><li>在每个Node中加入协调模块，用类似一致性算法 Raft 的方式，在节点间互相同步数据，让所有Node看到的集群数据状态都是一致的。（此处可类比redis的哨兵机制，只不过这个模块是跟Node放在一起的）</li><li>即内置的<code>Zen Discovery</code> 和 <code>Cluster Coordination Module</code></li></ul></li></ul></li></ul><h3 id="去中心化整体架构" tabindex="-1"><a class="header-anchor" href="#去中心化整体架构"><span>去中心化整体架构：</span></a></h3><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8ab6db8d1c2ca78db26ac429ec901e36.png" width="60%"><h3 id="es写入过程" tabindex="-1"><a class="header-anchor" href="#es写入过程"><span>es写入过程：</span></a></h3><ol><li>客户端请求： <ul><li>请求会先发到集群中协调节点</li></ul></li><li>请求路由到主分片： <ul><li><code>协调节点</code>根据文档的ID计算hash，判断数据该写入到哪个哪个分片（Shard），将请求转发到对应的Node节点</li></ul></li><li>主分片处理写请求： <ul><li>分片底层是 lucene，最终是将数据写入到 lucene 库里的 segment 内，将数据固化为倒排索引和 Stored Fields 以及 Doc Values 等多种结构</li></ul></li><li>同步到副本分片： <ul><li>主分片将写操作及其相关的元数据（如版本号和操作序列号）同步发送到所有副本分片。这个过程是并行进行的。</li></ul></li><li>副本分片确认写操作： <ul><li>副本分片接收到写操作后，执行相同的写操作并更新自身的数据，完成写入给主分片确认信号ACK</li></ul></li><li>主分片确认写操作完成： <ul><li>主分片在<code>接收到所有副本分片</code>的确认消息后（同步复制策略下），认为写操作已经成功，给协调节点ACK确认信号</li><li>如果开启异步复制，则不等待副本写入，直接响应协调节点</li><li>quorum 机制</li></ul></li><li>协调节点响应客户端： <ul><li>响应写入成功 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/fb4a5f6decdd3e4961905b47f273f8a3.png" width="60%"></li></ul></li></ol><h3 id="es查询过程" tabindex="-1"><a class="header-anchor" href="#es查询过程"><span>es查询过程：</span></a></h3><ol><li><p>客户端请求：</p><ul><li>请求会先发到集群中协调节点</li></ul></li><li><p>请求路由到主分片：</p><ul><li><code>协调节点</code>根据查询请求的类型（如搜索、聚合等）和索引的元数据，确定需要查询哪些分片</li><li>根据index name，可以知道index被分到哪几个shard，分片在哪些node上</li></ul></li><li><p>查询阶段 Query Phase：</p><ul><li>协调节点将查询请求并行发送到所有相关分片</li><li>搜索请求到达分片后，shard底层的lucene库会并发搜索多个segment，利用每个segment内部的倒排索引获取到对应文档id，并结合doc values获得排序信息</li><li>分片将结果聚合后返回给协调节点 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e8dc886a1c9fff81303c88cca369db5c.png" width="60%"></li></ul></li><li><p>聚合阶段 Fetch Phase：</p><ul><li>协调节点对多个分片中拿到的数据再进行一次排序聚合，判断哪些文档ID对应的数据需要返回客户端</li><li>协调节点再次拿着这些文档ID并发请求数据节点里的分片，分片底层的lucene库会从segment内的<code>Stored Fields</code> 中取出完整文档内容，并返回给协调节点 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c2706ad2945ecf2a3dee6bc24b68f46e.png" width="60%"></li></ul></li><li><p>返回结果给客户端</p><ul><li>协调节点将查询好的数据返回给客户端</li></ul></li></ol><h3 id="es的更新、删除过程" tabindex="-1"><a class="header-anchor" href="#es的更新、删除过程"><span>es的更新、删除过程：</span></a></h3><ul><li>重点： <ul><li>删除和更新也都是写操作</li><li>删除： <ul><li>磁盘上的每个段都有一个相应的.del 文件，当删除请求发送后，在.del文件中标记文档为删除。（delete_mask）</li><li>该文档依然能匹配查询，但是会在结果中被过滤掉。</li><li>当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段，进行真正的删除。（delete）</li></ul></li><li>更新： <ul><li>当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。（add）</li><li>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li><li>当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段，进行真正的删除。（delete）</li></ul></li></ul></li></ul><h3 id="查询举例" tabindex="-1"><a class="header-anchor" href="#查询举例"><span>查询举例</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>PUT /my_index                 // my_index 即index name</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>  &quot;mappings&quot;: {</span></span>\n<span class="line"><span>    &quot;properties&quot;: {</span></span>\n<span class="line"><span>      &quot;title&quot;: {</span></span>\n<span class="line"><span>        &quot;type&quot;: &quot;text&quot;,</span></span>\n<span class="line"><span>        &quot;doc_values&quot;: false, // 是否使用doc_values进行聚合加速</span></span>\n<span class="line"><span>        &quot;store&quot;: true,</span></span>\n<span class="line"><span>      }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>  }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',21)]))}]]),s=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticSearch/%E5%8E%9F%E7%90%86.html","title":"ES原理","lang":"zh-CN","frontmatter":{"title":"ES原理","date":"2025-06-17T15:16:52.000Z","author":"Navyum","tags":["ES"],"categories":["数据库","全文搜索"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"icon":"devicon-plain:elasticsearch","description":"基于 lucence 引擎 通过关键词进行信息检索，搜索场景 基础： 倒排索引： 什么是倒排索引： 一个用于搜索的数据结构 倒排索引的核心概念： 词项 term： 将文本进行分词（LLM里面叫token化）后得到词项，词项就是一堆 词项字典 Term Dictionary： 将词项进行排序后得到词项字典，词项数量庞大时，可以通过二分法快速查询（此处可类...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticSearch/%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"ES原理"}],["meta",{"property":"og:description","content":"基于 lucence 引擎 通过关键词进行信息检索，搜索场景 基础： 倒排索引： 什么是倒排索引： 一个用于搜索的数据结构 倒排索引的核心概念： 词项 term： 将文本进行分词（LLM里面叫token化）后得到词项，词项就是一堆 词项字典 Term Dictionary： 将词项进行排序后得到词项字典，词项数量庞大时，可以通过二分法快速查询（此处可类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-24T03:13:58.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"ES"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:16:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-24T03:13:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ES原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:16:52.000Z\\",\\"dateModified\\":\\"2025-06-24T03:13:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750734838000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":7.24,"words":2173},"filePathRelative":"常用软件/数据库/elasticSearch/原理.md","localizedDate":"2025年6月17日","excerpt":"<ul>\\n<li>基于 lucence 引擎</li>\\n<li>通过关键词进行信息检索，搜索场景</li>\\n</ul>\\n<h3>基础：</h3>\\n<h4>倒排索引：</h4>\\n<ul>\\n<li>什么是倒排索引：\\n<ul>\\n<li>一个用于搜索的数据结构</li>\\n</ul>\\n</li>\\n<li>倒排索引的核心概念：\\n<ul>\\n<li>\\n<p>词项 term：</p>\\n<ul>\\n<li>将文本进行分词（LLM里面叫token化）后得到词项，词项就是一堆</li>\\n</ul>\\n</li>\\n<li>\\n<p>词项字典 Term Dictionary：</p>\\n<ul>\\n<li>将词项进行排序后得到词项字典，词项数量庞大时，可以通过二分法快速查询（此处可类比mysql的Page Dictionary作用也相似）</li>\\n<li>词项字典存在磁盘中，数据大</li>\\n<li>实际访问时先通过内存中的Term index，找到前缀匹配的词项位置，然后通过少量查找，定位到词项</li>\\n</ul>\\n</li>\\n<li>\\n<p>Posting List：</p>\\n<ul>\\n<li>作用：记录每个词项对应的文本ID的集合和其他信息</li>\\n<li>Posting List包含：文本ID的集合、词项在每个文本内的offset、词频\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c151134facc7b3f4784d776dd075895e.png\\" width=\\"60%\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>Term Index：</p>\\n<ul>\\n<li>作用：通过内存加速搜索</li>\\n<li>结构：基于词项前缀生成的一个精简的树结构（可对比参考跳表、b+树）</li>\\n<li>特点：词项索引存放在内存中，数据小，可以方便的快速查询</li>\\n<li>查询：先通过词项索引，找到词项在词项字典的大概位置，然后到词项字典中再查找</li>\\n<li>具体实现 FST 有限状态机：（可对比Tire树）\\n<ul>\\n<li>FST的特点：（本质是有向图结构）\\n<ul>\\n<li>压缩性：FST通过共享公共前缀和后缀，大大减少了存储空间</li>\\n<li>高效查找：FST允许在子线性时间内查找词项，非常适合用于大规模的文本搜索</li>\\n<li>自动补全：FST还支持前缀查找和自动补全功能，这对于搜索引擎的实现非常有用\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d6b55b19a41c4fd1ce7cff10414833ea.png\\" width=\\"60%\\"></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Stored Fields：<code>行式存储</code></p>\\n<ul>\\n<li>作用：存放文件的原始信息</li>\\n<li>查询：可以通过文本ID，从Stored Fields，获取出整个文本内容（此处可类比MyISAM引擎）\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e8bad19ce7b3ca3cab2859cf68f5909.png\\" width=\\"60%\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>Doc Values：<code>列式存储</code></p>\\n<ul>\\n<li>作用：用于排序和聚合</li>\\n<li>说明：对某个字段排序文档，比如按时间、价格排序场景时，提升查询速度（此处可对比Mysql的二级索引）</li>\\n<li>原理：将散落在各个文档的某个字段集中存放在一起，\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/14830fed46856b3b0f571f0aae4c3d42.png\\" width=\\"60%\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>segment：</p>\\n<ul>\\n<li>说明：segment是具备完整搜索功能的最小单元</li>\\n<li>组成：inverted index、Term index、stored fields、doc values共同构成一个segment</li>\\n<li>segment读写规则：\\n<ul>\\n<li>写入：\\n<ul>\\n<li>将多个文档生成一个segment，生成后，segment不能再被修改</li>\\n<li>如果有新文档，则新生成一个 segment</li>\\n</ul>\\n</li>\\n<li>读取：\\n<ul>\\n<li>并发同时读多个segment，并进行聚合操作</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>segment合并：\\n<ul>\\n<li>避免segment过多影响性能、避免文件句柄耗尽</li>\\n<li>不定期将多个小segment合并</li>\\n<li>segment合并过程：待补充</li>\\n<li>segment合并中的查询：待补充\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9e2dd79d772f594f9beff0dc14e80f44.png\\" width=\\"60%\\"></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>lucene：</p>\\n<ul>\\n<li>单机文本检索库，由多个segment构成</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);
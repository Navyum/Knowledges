"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[33524],{18120:(e,n,a)=>{a.d(n,{K:()=>i});const i=JSON.parse('{"encrypt":{"config":{"/encrypt/":{"tokens":["$2b$10$iZ8hl04Fc4bEtV9fRqacCuY7Vnug2XjCsLKW8BrzntPDm6tGuWxqO"],"hint":"从 xxx 获取密码"},"/apps/encrypt03.html":{"tokens":["$2b$10$ptZ..yo9SS0vAtP8umUEW.b9Tdg8SRCjXqBjTLcNypNTQ6ZTbLsSK"],"hint":"从 xxx 获取密码"}}},"author":{"name":"Navyum","url":"https://myblog.camscanner.top"},"logo":"/logo.svg","license":"CC BY-NC-ND 4.0","copyright":"\\n  版权声明：自由转载 - 非商用 - 非衍生 - 保持署名<a href=\\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">（创意共享 4.0 许可证）</a>|\\n  Copyright © 2024-present Navyum</a>\\n  ","displayFooter":true,"breadcrumb":false,"contributors":false,"lastUpdated":true,"editLink":false,"darkmode":"switch","fullscreen":true,"repo":"navyum","repoLabel":"GitHub","repoDisplay":true,"docsDir":"docs","navbarLayout":{"start":["Brand"],"center":["Links"],"end":["Repo","Outlook","Search"]},"pageInfo":["Category","Tag","Word","ReadingTime","PageView"],"blog":{"articleInfo":["Date","PageView","Category","Tag","ReadingTime"],"name":"Navyum","avatar":"avatar_self.jpeg","description":"AI改变世界,边学习、边分享","intro":"/intro.html","medias":{"GitHub":"https://github.com/navyum","Email":"mailto:yhj2433488839@gmail.com","Gmail":"mailto:yhj2433488839@gmail.com"}},"print":false,"locales":{"/":{"lang":"zh-CN","navbarLocales":{"langName":"简体中文","selectLangAriaLabel":"选择语言"},"metaLocales":{"author":"作者","date":"写作日期","origin":"原创","views":"访问量","category":"分类","tag":"标签","readingTime":"阅读时间","words":"字数","toc":"此页内容","prev":"上一页","next":"下一页","lastUpdated":"上次编辑于","contributors":"贡献者","editLink":"编辑此页","print":"打印"},"blogLocales":{"article":"文章","articleList":"文章列表","category":"分类","tag":"标签","timeline":"时间轴","timelineTitle":"昨日不在","all":"全部","intro":"个人介绍","star":"星标","empty":"$text 为空"},"paginationLocales":{"prev":"上一页","next":"下一页","navigate":"跳转到","action":"前往","errorText":"请输入 1 到 $page 之前的页码！"},"outlookLocales":{"themeColor":"主题色","darkmode":"外观","fullscreen":"全屏"},"encryptLocales":{"iconLabel":"文章已加密","placeholder":"输入密码","remember":"记住密码","errorHint":"请输入正确的密码"},"routeLocales":{"skipToContent":"跳至主要內容","notFoundTitle":"页面不存在","notFoundMsg":["这里什么也没有","我们是怎么来到这儿的？","这 是 四 零 四 !","看起来你访问了一个失效的链接"],"back":"返回上一页","home":"带我回家"},"navbar":[{"text":"主页","icon":"meteor-icons:home","link":"/"},{"text":"博客","icon":"fa6-solid:blog","link":"/blog"},{"text":"思考","icon":"icon-park-outline:thinking-problem","children":[{"text":"面试经验","icon":"fluent:people-chat-24-regular","link":"/面试经验/"},{"text":"个人思考","icon":"icon-park-outline:thinking-problem","link":"/个人思考/"},{"text":"我的世界","icon":"streamline-plump:world-remix","link":"/我的世界/"}]},{"text":"读书","icon":"fa6-brands:readme","link":"https://www.notion.so/navyum/1c42fcd1fefa4e948d8514761b2ab8c7?v=0ca5dc6ee29e4c2787dbd0f1055b4ed0"},{"text":"联系","icon":"streamline-plump:contact-phonebook-solid","link":"/intro"},{"text":"导航","icon":"streamline-plump:world-remix","link":"/map"}],"sidebar":{"/计算机网络/":[{"text":"计算机网络","icon":"icon-park-outline:computer","collapsible":true,"children":"structure"}],"/算法数据结构/":[{"text":"算法数据结构","icon":"hugeicons:algorithm","collapsible":true,"children":["0.学习路径.md","1.思维导图.md","2.参考书籍.md",{"text":"数据结构","prefix":"数据结构/","icon":"carbon:data-structured","collapsible":true,"children":"structure"},{"text":"算法","prefix":"算法/","icon":"hugeicons:algorithm","collapsible":true,"children":"structure"}]}],"/编程语言/":[{"text":"编程语言","icon":"codicon:code","collapsible":true,"children":"structure"}],"/常用软件/":[{"text":"常用软件","icon":"fluent:apps-32-filled","collapsible":true,"children":"structure"}],"/架构设计/":[{"text":"架构设计","icon":"carbon:microservices-1","collapsible":true,"children":"structure"}],"/大模型LLM/":[{"text":"大模型LLM","icon":"ri:ai-generate-2","collapsible":true,"children":"structure"}],"/工具武器库/":[{"text":"工具武器库","icon":"entypo:tools","collapsible":true,"children":"structure"}],"/面试经验/":[{"text":"面试经验","icon":"fluent:people-chat-24-regular","collapsible":true,"children":"structure"}],"/个人思考/":[{"text":"个人思考","icon":"icon-park-outline:thinking-problem","collapsible":true,"children":"structure"}],"/我的世界/":[{"text":"我的世界","icon":"streamline-plump:world-remix","collapsible":true,"children":"structure"}],"":[{"text":"计算机网络","icon":"icon-park-outline:computer","prefix":"/计算机网络/","collapsible":true,"children":"structure"},{"text":"算法数据结构","icon":"hugeicons:algorithm","prefix":"/算法数据结构/","collapsible":true,"children":["0.学习路径.md","1.思维导图.md","2.参考书籍.md",{"text":"数据结构","prefix":"数据结构/","icon":"carbon:data-structured","collapsible":true,"children":"structure"},{"text":"算法","prefix":"算法/","icon":"arcticons:algorithms","collapsible":true,"children":"structure"}]},{"text":"编程语言","icon":"codicon:code","prefix":"/编程语言/","collapsible":true,"children":"structure"},{"text":"常用软件","icon":"fluent:apps-32-filled","prefix":"/常用软件/","collapsible":true,"children":"structure"},{"text":"架构设计","icon":"carbon:microservices-1","prefix":"/架构设计/","collapsible":true,"children":"structure"},{"text":"大模型LLM","icon":"ri:ai-generate-2","prefix":"/大模型LLM/","collapsible":true,"children":"structure"},{"text":"工具武器库","icon":"entypo:tools","prefix":"/工具武器库/","collapsible":true,"children":"structure"},{"text":"面试经验","icon":"fluent:people-chat-24-regular","prefix":"/面试经验/","collapsible":true,"children":"structure"},{"text":"个人思考","icon":"icon-park-outline:thinking-problem","prefix":"/个人思考/","collapsible":true,"children":"structure"},{"text":"我的世界","icon":"streamline-plump:world-remix","prefix":"/我的世界/","collapsible":true,"children":"structure"},{"text":"博客文章","icon":"fa6-solid:feather-pointed","prefix":"/_posts/","link":"/blog","collapsible":true,"children":"structure"}]}}}}')},37159:(e,n,a)=>{a.d(n,{B:()=>U});var i={};a.r(i);var t={};a.r(t);var l={};a.r(l);var s={};a.r(s);var E={};a.r(E),a.d(E,{default:()=>g});var r={};a.r(r);var d={};a.r(d);var p={};a.r(p),a.d(p,{default:()=>D});var o={};a.r(o),a.d(o,{default:()=>M});var c={};a.r(c),a.d(c,{default:()=>L});var B={};a.r(B),a.d(B,{default:()=>j});var h={};a.r(h),a.d(h,{default:()=>V});var A=a(52514),m=a(45006);const g={enhance:({app:e})=>{e.component("Mermaid",m.A)}};var u=a(31297),b=a(81011),y=a(89417),k=a(87470),x=a(49523),v=a(6254),F=a(49404);const D={enhance:({app:e})=>{(0,k.L4)("VPIcon")||e.component("VPIcon",(e=>(0,v.h)(F.G,{type:"iconify",prefix:"",...e})))},setup:()=>{(0,x.r9V)("https://cdn.jsdelivr.net/npm/iconify-icon@2")}};var f=a(89566),C=a(68081),w=a(61833),T=a(4837);const M={enhance:({app:e})=>{(0,k.L4)("Badge")||e.component("Badge",C.A),(0,k.L4)("BiliBili")||e.component("BiliBili",w.A),(0,k.L4)("VidStack")||e.component("VidStack",T.A)},setup:()=>{},rootComponents:[]};var S=a(69843),I=a(1213),P=a(44899),N=a(58751),_=a(4773);const L={enhance({app:e}){(0,_.wn)(e),e.component("SearchBox",_.VA)}};var z=a(9125),O=a(16512),G=a(23639),R=a(15031),q=a(58613);(0,G.M_)((e=>{const n=e.title,a=!1!==e.index,i=e.icon;return a?{title:n,content:i?()=>[(0,v.h)((0,v.g2)("VPIcon"),{icon:i}),n]:null,order:e.order,index:e.index}:null}));const j={enhance:({app:e,router:n})=>{const{scrollBehavior:a}=n.options;n.options.scrollBehavior=async(...e)=>(await O.lE.wait(),a(...e)),(0,O.X4)(e),e.component("BloggerInfo",R.tI),e.component("SocialMedias",R.rS),e.component("GlobalEncrypt",q.J),e.component("LocalEncrypt",q.n)},setup:()=>{(0,O.fv)(),(0,O.i$)(),(0,R.su)()},layouts:{Layout:O.PE,NotFound:O.Mk,BlogCategory:R.Pn,BlogHome:R.qX,BlogType:R.z7,Timeline:R.Kf}};var H=a(5673);const W=(0,v.pM)({name:"SocialLink",setup:()=>()=>(0,v.h)("div",{class:"vp-nav-item vp-action"},(0,v.h)("a",{class:"vp-action-link",href:"https://discord.gg/PZTQfJ4GjX",target:"_blank",rel:"noopener noreferrer","aria-label":"discord",innerHTML:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" style="width:1.25rem;height:1.25rem;vertical-align:middle"><path d=\'m534.42,126.58a1.57,1.57 0 0 0 -0.79,-0.73a507.33,507.33 0 0 0 -125.19,-38.81a1.9,1.9 0 0 0 -2.01,0.95a352.96,352.96 0 0 0 -15.58,32.01a468.41,468.41 0 0 0 -140.6,0a323.75,323.75 0 0 0 -15.82,-32.01a1.98,1.98 0 0 0 -2.02,-0.95a505.9,505.9 0 0 0 -125.19,38.81a1.79,1.79 0 0 0 -0.82,0.7c-79.73,119.07 -101.57,235.21 -90.86,349.9a2.11,2.11 0 0 0 0.81,1.44a510.06,510.06 0 0 0 153.56,77.6a1.99,1.99 0 0 0 2.15,-0.71a364.19,364.19 0 0 0 31.42,-51.08a1.95,1.95 0 0 0 -1.07,-2.71a335.92,335.92 0 0 1 -47.98,-22.85a1.98,1.98 0 0 1 -0.19,-3.27c3.22,-2.42 6.44,-4.93 9.53,-7.46a1.9,1.9 0 0 1 1.99,-0.27c100.65,45.94 209.61,45.94 309.07,0a1.89,1.89 0 0 1 2.01,0.24c3.09,2.54 6.31,5.07 9.55,7.49a1.97,1.97 0 0 1 -0.17,3.27a315.25,315.25 0 0 1 -48,22.83a1.97,1.97 0 0 0 -1.05,2.73a409.02,409.02 0 0 0 31.4,51.05a1.95,1.95 0 0 0 2.15,0.73a508.37,508.37 0 0 0 153.81,-77.59a1.97,1.97 0 0 0 0.81,-1.41c12.82,-132.61 -21.48,-247.79 -90.93,-349.9zm-315.91,280.03c-30.3,0 -55.27,-27.81 -55.27,-61.96s24.48,-61.96 55.27,-61.96c31.03,0 55.76,28.05 55.27,61.96c0,34.15 -24.48,61.96 -55.27,61.96zm204.35,0c-30.3,0 -55.27,-27.81 -55.27,-61.96s24.48,-61.96 55.27,-61.96c31.03,0 55.76,28.05 55.27,61.96c0,34.15 -24.23,61.96 -55.27,61.96z\' fill="currentColor"/></svg>'}))}),V=(0,a(4469).re)({enhance:({app:e})=>{e.component("SocialLink",W)}}),U=[i,t,l,A,s,E,r,d,u,b,y,p,f,o,S,I,P,N,c,z,B,H,h].map((e=>e.default)).filter(Boolean)},46159:(e,n,a)=>{a.d(n,{J:()=>t,c:()=>i});const i=JSON.parse('{"/_encrypt/":"/encrypt/","/_posts/samplepage.html":"/posts/samplepage.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09.*%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/10.*%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/10._%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n+k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n%5E2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html"}'),t=Object.fromEntries([["/",{loader:()=>a.e(24470).then(a.bind(a,291)),meta:{title:"互联网爱好者"}}],["/blog.html",{loader:()=>a.e(66632).then(a.bind(a,93187)),meta:{title:"互联网爱好者",icon:"fa6-solid:house-crack"}}],["/intro.html",{loader:()=>a.e(63912).then(a.bind(a,15949)),meta:{title:"关于我",index:!1}}],["/map.html",{loader:()=>a.e(30824).then(a.bind(a,86964)),meta:{date:1749983452e3,excerpt:'<p align="center">\n  <img src="/logo.svg" alt="Navyum\'s blog logo" width="100" height="auto">\n</p>\n<h1 align="center">学习文档</h1>\n<h2>Computer Science</h2>\n<ul>\n<li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">💻 计算机网络</a></li>\n<li><a href="/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html" target="_blank">⛵️ 算法数据结构</a></li>\n<li><a href="/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" target="_blank">📑 编程语言</a></li>\n<li><a href="/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html" target="_blank">📁 常用软件</a>\n<ul>\n<li><a href="/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/01.Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html" target="_blank">Mysql</a></li>\n<li><a href="/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" target="_blank">Redis</a></li>\n<li><a href="/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/docker.html" target="_blank">Docker</a></li>\n</ul>\n</li>\n<li><a href="/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BA%B2.html" target="_blank">🌡️ 架构设计</a></li>\n</ul>',readingTime:{minutes:.74,words:223},title:"",type:"article"}}],["/encrypt/",{loader:()=>a.e(5492).then(a.bind(a,88651)),meta:{date:17376768e5,localizedDate:"2025年1月24日",category:["使用指南"],tag:["页面配置","使用指南"],sticky:!0,isEncrypted:!0,readingTime:{minutes:.59,words:178},title:"加密",type:"article"}}],["/posts/samplepage.html",{loader:()=>a.e(31485).then(a.bind(a,76327)),meta:{title:"页面配置样例",icon:"fa-solid fa-hashtag",order:-1,index:!1}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98.html",{loader:()=>a.e(29047).then(a.bind(a,43887)),meta:{author:"Navyum",date:1750432826e3,localizedDate:"2025年6月20日",category:["个人思考"],tag:["事故复盘","团队管理"],sticky:!1,excerpt:'\n<h2>事故复盘时间线流程图</h2>\n<h2>复盘流程设计与具体方法</h2>\n<h3>一、复盘前准备阶段</h3>\n<h4>信息收集与整理（组织者核心工作）</h4>\n<p><strong>具体方法：</strong></p>\n<ul>\n<li>\n<p><strong>建立事故档案模板</strong></p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>事故基本信息表：</span></span>\n<span class="line"><span>- 事故编号：[自动生成]</span></span>\n<span class="line"><span>- 发生时间：[精确到分钟]</span></span>\n<span class="line"><span>- 发现时间：[精确到分钟]</span></span>\n<span class="line"><span>- 影响范围：[具体业务模块]</span></span>\n<span class="line"><span>- 影响时长：[分钟/小时]</span></span>\n<span class="line"><span>- 涉及人员：[角色+姓名]</span></span>\n<span class="line"><span>- 业务影响：[具体指标]</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>\n<p><strong>核心提问清单（5W2H）</strong></p>\n<ul>\n<li>\n<p><strong>What（发生了什么）</strong>：</p>\n<ul>\n<li>"请描述一下事故的具体表现是什么？"</li>\n<li>"用户看到了什么异常现象？"</li>\n<li>"系统日志显示了什么错误信息？"</li>\n</ul>\n</li>\n<li>\n<p><strong>When（时间节点）</strong>：</p>\n<ul>\n<li>"事故最早出现的时间点是什么时候？"</li>\n<li>"什么时候被发现的？"</li>\n<li>"从发现到解决用了多长时间？"</li>\n<li>"各个处理阶段的时间节点是什么？"</li>\n</ul>\n</li>\n<li>\n<p><strong>Where（影响范围）</strong>：</p>\n<ul>\n<li>"哪些系统/模块受到了影响？"</li>\n<li>"影响的地理区域或用户群体是什么？"</li>\n<li>"依赖的服务是否也出现了问题？"</li>\n</ul>\n</li>\n<li>\n<p><strong>Who（相关人员）</strong>：</p>\n<ul>\n<li>"事故处理过程中涉及了哪些角色？"</li>\n<li>"每个角色的具体职责是什么？"</li>\n<li>"决策链上的关键人物是谁？"</li>\n</ul>\n</li>\n<li>\n<p><strong>Why（根本原因）</strong>：</p>\n<ul>\n<li>"直接触发事故的原因是什么？"</li>\n<li>"为什么会出现这个触发条件？"</li>\n<li>"更深层次的系统性原因是什么？"</li>\n</ul>\n</li>\n<li>\n<p><strong>How（发生过程）</strong>：</p>\n<ul>\n<li>"事故是如何逐步演化的？"</li>\n<li>"处理过程中采取了哪些措施？"</li>\n<li>"哪些措施有效，哪些无效？"</li>\n</ul>\n</li>\n<li>\n<p><strong>How Much（影响程度）</strong>：</p>\n<ul>\n<li>"对业务的具体影响是什么？"</li>\n<li>"用户投诉数量是多少？"</li>\n<li>"经济损失如何量化？"</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:9.75,words:2926},title:"如何事故复盘",icon:"ic:round-rate-review",type:"article"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%B7%A5%E4%BD%9C.html",{loader:()=>a.e(75650).then(a.bind(a,50401)),meta:{author:"Navyum",date:1750170498e3,localizedDate:"2025年6月17日",category:["个人思考"],tag:["积累"],sticky:!1,excerpt:'<h2>关于知识的积累和体系的建立</h2>\n<h3>如何建立三维立体的知识体系：</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/530417ac4888817f1cdfd5ef52c998f1.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<p>理论支撑：RIP阅读、费曼学习法</p>\n<ul>\n<li><strong>单纯阅读</strong>，人容易满足于获取新知识，只迷恋在看的表层。（只有输入）</li>\n<li><strong>通过写作</strong>，逼迫自己把所学的知识关联起来，实现体系和结构。（不断输出）</li>\n</ul>',readingTime:{minutes:12.27,words:3681},title:"如何做好工作",icon:"ic:round-work",type:"article"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92.html",{loader:()=>a.e(93074).then(a.bind(a,97997)),meta:{author:"Navyum",date:1750170583e3,localizedDate:"2025年6月17日",category:["个人思考","职业规划"],tag:["职业规划","个人能力"],sticky:!1,excerpt:'<h3>一、职场能力</h3>\n<h4>职场发展全景图：</h4>\n<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ebc6137dec7a63c7b0eb4a5c4db45606.jpeg" width="80%"></p>\n<h4>发展路线：</h4>\n<ul>\n<li>专业路线(P)（也就是常说的P序列）​\n<ul>\n<li>普通人比较困难</li>\n</ul>\n</li>\n<li>管理路线(M)（也就是常说的M序列）​\n<ul>\n<li>M路线对于大部分人来说，是延长职场生命周期的主要路径、也是提升薪酬和成就感的主要路径；</li>\n</ul>\n</li>\n<li>创业路线(E)（我定义为E-Entrepreneurship序列）\n<ul>\n<li>3要素：认知、资源、心力</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:8.85,words:2654},title:"如何做职业规划",icon:"icon-park-solid:plan",type:"article"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%85%BB%E6%88%90%E5%BE%AE%E4%B9%A0%E6%83%AF.html",{loader:()=>a.e(97490).then(a.bind(a,67809)),meta:{author:"Navyum",date:1750170562e3,localizedDate:"2025年6月17日",category:["个人思考"],tag:["改变","习惯"],sticky:!1,excerpt:"<h2>微习惯养成</h2>\n",readingTime:{minutes:.16,words:47},title:"如何养成微习惯",icon:"ic:sharp-add-reaction",type:"article"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDPPT.html",{loader:()=>a.e(87702).then(a.bind(a,3355)),meta:{author:"Navyum",date:1750170523e3,localizedDate:"2025年6月17日",category:["个人思考"],tag:["职场PPT","PPT美化"],sticky:!1,excerpt:'<p><a href="https://appbHlkwH0P9313.h5.xiaoeknow.com/giftcode/0070090794277500973" target="_blank" rel="noopener noreferrer">link</a></p>\n<h3>目标：</h3>\n<ul>\n<li>信息传递效率高</li>\n<li>视觉呈现美观、大气</li>\n</ul>\n<div class="language-markmap line-numbers-mode" data-highlighter="shiki" data-ext="markmap" data-title="markmap" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>## PPT构成元素</span></span>\n<span class="line"><span>- 文字 </span></span>\n<span class="line"><span>- 图片</span></span>\n<span class="line"><span>- 图表</span></span>\n<span class="line"><span>- 图标</span></span>\n<span class="line"><span>- 形状</span></span>\n<span class="line"><span>- 视频</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:2.7,words:811},title:"如何写好PPT",icon:"teenyicons:ppt-solid",type:"article"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E8%81%8C%E5%9C%BA%E6%96%B9%E6%B3%95%E8%AE%BA.html",{loader:()=>a.e(18685).then(a.bind(a,70655)),meta:{author:"Navyum",date:1739030055e3,localizedDate:"2025年2月8日",category:["个人思考"],tag:["职场","方法论","思维模型","汇报","总结"],sticky:!1,excerpt:'<h2>职场方法论</h2>\n<ul>\n<li class="mindmap">职场能力\n<ul>\n<li>工作（科学成事）</li>\n<li>沟通</li>\n<li>思考</li>\n</ul>\n</li>\n</ul>\n<h3>工作</h3>\n<ul>\n<li class="mindmap">工作指南\n<ul>\n<li>接受工作，只问标准\n<ul>\n<li>SMART 公式，快速确认要求</li>\n</ul>\n</li>\n<li>请示工作，必带方案\n<ul>\n<li>RIDE 说服模型，获得支持</li>\n</ul>\n</li>\n<li>汇报工作，突出结果\n<ul>\n<li>PREP 汇报模型，清晰汇报</li>\n</ul>\n</li>\n<li>分享工作，细说流程\n<ul>\n<li>5W2H 法则，多维度分析</li>\n</ul>\n</li>\n<li>复盘工作，总结SOP\n<ul>\n<li>GRAI 法则，总结工作</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.86,words:557},title:"职场方法论",icon:"tabler:key-filled",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/2025%E6%8F%90%E6%95%88%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html",{loader:()=>a.e(96839).then(a.bind(a,34646)),meta:{author:"Navyum",date:1760548169e3,localizedDate:"2025年10月15日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:'<p>在数字化办公时代，Chrome插件已成为提升工作效率的重要工具。笔者将结合自己的使用，将为您推荐2025年最受欢迎的10款生产力Chrome插件，帮助您打造更高效的浏览器工作环境。</p>\n<h2>1. Infinity 新标签页 (Pro)</h2>\n<figure><img src="https://i-blog.csdnimg.cn/direct/888dcdf7ba8b442497b75e5199422ff0.png#pic_center" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>',readingTime:{minutes:9.23,words:2768},title:"2025提效插件推荐",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/HEIF%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%AE%89%E8%A3%85.html",{loader:()=>a.e(53168).then(a.bind(a,68832)),meta:{author:"Navyum",date:175016038e4,localizedDate:"2025年6月17日",category:["HEIF","图片格式","工具配置"],tag:["HEIF","环境安装","图片格式","编解码器"],sticky:!0,excerpt:'<h2>HEIF编解码器安装与配置指南</h2>\n<p>HEIF（High Efficiency Image Format）是一种高效的图像格式，基于HEVC（H.265）编码标准，相比JPEG格式能够提供更好的压缩率和图像质量。本文详细介绍如何在CentOS 7环境下安装和配置HEIF编解码器，支持多种编码格式的转换。</p>\n<h3>技术背景</h3>\n<h4>HEIF编码解码原理</h4>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/main/IMG/21139a95b55bedab5c5a1eaf9a9c4f0b.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',readingTime:{minutes:7.24,words:2172},title:"HEIF编解码器安装与配置指南",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/ISOBMFF%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE.html",{loader:()=>a.e(25769).then(a.bind(a,11777)),meta:{author:"Navyum",date:1750160422e3,localizedDate:"2025年6月17日",category:["多媒体格式","协议规范"],tag:["ISOBMFF","HEIF","多媒体格式","容器格式"],sticky:!1,excerpt:"<h2>ISOBMFF多媒体文件协议</h2>\n<h3>概述</h3>\n<p>ISOBMFF（ISO Base Media File Format）是ISO/IEC 14496-12标准的具体实现，是一种高度可扩展的容器文件格式，定义了多媒体文件的通用结构。</p>\n<p><strong>主要用途：</strong></p>\n<ul>\n<li>用于视频、音频文件的封装，支持如HEIF图像文件格式</li>\n<li>是现代流媒体技术如DASH（Dynamic Adaptive Streaming over HTTP）和HLS（HTTP Live Streaming）的基础</li>\n</ul>\n",readingTime:{minutes:4.99,words:1498},title:"ISOBMFF多媒体文件协议",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/Mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%8E%A7%E5%88%B6%E8%AF%AD%E6%B3%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.html",{loader:()=>a.e(92999).then(a.bind(a,83207)),meta:{date:1760770607e3,excerpt:"\n<p>时序图（Sequence Diagram）是Mermaid中用于展示对象间交互顺序的核心图表类型，而控制语法则是实现复杂流程逻辑（如分支、循环、并行等）的关键。本文将详细介绍Mermaid时序图的5类核心控制块语法，每类均配套易于理解的典型业务场景案例，帮助快速掌握并应用于实际开发文档中。</p>\n<h2>一、基础概念铺垫</h2>\n<p>在学习控制语法前，先明确时序图的2个基础要素，确保案例可直接运行：</p>\n<ul>\n<li>\n<p><strong>参与者（Participant）</strong>：交互的对象，可用<code>participant</code>定义（普通对象）或<code>actor</code>定义（用户角色），支持别名简化表述。</p>\n</li>\n<li>\n<p><strong>消息流向</strong>：用<code>-&gt;&gt;</code>表示同步消息（实线带箭头），<code>--&gt;&gt;</code>表示异步消息（虚线带箭头），是交互的基础载体。</p>\n</li>\n</ul>",readingTime:{minutes:10.51,words:3153},title:"Mermaid时序图控制语法完全指南",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/electron.html",{loader:()=>a.e(93942).then(a.bind(a,76518)),meta:{author:"Navyum",date:1750160459e3,localizedDate:"2025年6月17日",category:["Electron","应用开发","发布部署"],tag:["Electron","macOS","应用打包","代码签名","发布"],sticky:!0,excerpt:"<h2>Electron macOS应用打包与发布完整指南</h2>\n<p>本文详细介绍如何使用Electron打包和发布macOS应用程序，包括代码签名、公证、分发等完整流程。涵盖从开发环境配置到最终应用商店发布的各个环节。</p>\n<h3>概述</h3>\n<p>Electron应用在macOS上的发布需要经过以下关键步骤：</p>\n<ol>\n<li><strong>代码签名</strong>：使用Apple开发者证书对应用进行签名</li>\n<li><strong>公证</strong>：通过Apple的公证服务验证应用安全性</li>\n<li><strong>分发</strong>：通过App Store或直接分发方式发布应用</li>\n</ol>",readingTime:{minutes:7.49,words:2248},title:"Electron macOS应用打包与发布完整指南",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/github_action.html",{loader:()=>a.e(66444).then(a.bind(a,47175)),meta:{author:"Navyum",date:17501605e5,localizedDate:"2025年6月17日",category:["踩坑记录"],tag:["github工作流","github Action"],sticky:!1,excerpt:'<h3>问题一：工作流互相触发异常的</h3>\n<ul>\n<li>\n<p>主要任务：</p>\n<ol>\n<li>使用【自动生成工作流】通过定时任务触发，生产内容并推送到分支</li>\n<li>使用【构建工作流】通过push事件监听，将新生产的内容构建成待发布内容</li>\n<li>使用【pages发布工作流】将构建好的内容发布到Pages</li>\n</ol>\n</li>\n<li>\n<p>遇到的问题：</p>\n<ul>\n<li>1号工作流执行完成后，不会自动触发2号工作流进行build</li>\n<li>1号工作流的定时触发配置：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 触发机制</span></span>\n<span class="line"><span>name: Generate Daily Markdown</span></span>\n<span class="line"><span>on:</span></span>\n<span class="line"><span>    schedule:</span></span>\n<span class="line"><span>    - cron: \'01 8 * * *\'</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>jobs:</span></span>\n<span class="line"><span>    build:</span></span>\n<span class="line"><span>        ...省略...</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        # 向main分支推送修改</span></span>\n<span class="line"><span>        - name: Push changes</span></span>\n<span class="line"><span>            uses: ad-m/github-push-action@master</span></span>\n<span class="line"><span>            with:</span></span>\n<span class="line"><span>                github_token: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class="line"><span>                branch: ${{ github.ref }}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>2号工作流的push触发配置：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>name: docs build</span></span>\n<span class="line"><span>on:</span></span>\n<span class="line"><span>    push:</span></span>\n<span class="line"><span>        branches:</span></span>\n<span class="line"><span>            - main</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>1号触发任务会向main分支进行推送，理应会触发2号工作流，但是实际无法触发</li>\n</ul>\n</li>\n<li>\n<p>排查过程：</p>\n<ul>\n<li>官方说明：\n<img src="https://raw.staticdn.net/Navyum/imgbed/main/IMG/2bde3c0d77c9beeeaecf5e32b1b3e9c7.png" alt="" width="60%" loading="lazy"></li>\n<li>官方主要是出于防止循环依赖导致资源浪费考虑所以这样设计。(<code>请确保不要创建递归或意外的工作流程</code>)</li>\n</ul>\n</li>\n<li>\n<p>解决方案：</p>\n<ul>\n<li>方案1：使用workflow_run监听【工作流1】\n<ul>\n<li>具体操作，修改2号工作流触发机制：</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>name: docs build</span></span>\n<span class="line"><span>on:</span></span>\n<span class="line"><span>    workflow_run:</span></span>\n<span class="line"><span>    workflows: "Generate Daily Markdown"    # 需要监听的流程名字</span></span>\n<span class="line"><span>    types: completed</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>方案2：使用personal access token，替代GITHUB_TOKEN\n<ul>\n<li>具体操作，修改1号工作流的push方式：</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- name: Push changes</span></span>\n<span class="line"><span>    uses: ad-m/github-push-action@master</span></span>\n<span class="line"><span>    with:</span></span>\n<span class="line"><span>        github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}</span></span>\n<span class="line"><span>        branch: ${{ github.ref }}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.37,words:411},title:"github action 踩坑记录",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/jsdeliver.html",{loader:()=>a.e(92594).then(a.bind(a,94108)),meta:{author:"Navyum",date:1750160556e3,localizedDate:"2025年6月17日",category:["踩坑记录"],tag:["jsdelivr","CDN"],sticky:!1,excerpt:"<h2>jsdelivr CDN 和 GitHub 的关系</h2>\n<p>jsdelivr 是一个免费且可靠的内容分发网络（CDN）服务，允许开发者将静态资源存储在 GitHub 仓库中，并通过 jsdelivr 进行全球加速访问。具体来说，jsdelivr 能够通过提供一个 CDN 地址，将存储在 GitHub 仓库中的资源进行加速，从而使这些资源在全球范围内快速加载。</p>\n<h2>如何将 GitHub 项目与 jsdelivr 对应起来</h2>\n<p>将资源上传到 GitHub 仓库\n首先，开发者需要将静态资源（如图片、JavaScript 文件、CSS 文件等）上传到 GitHub 仓库中的特定目录。例如，你可能有一个名为 my-project 的 GitHub 仓库，里面有一个 images 文件夹，存储了一些图片。</p>",readingTime:{minutes:1.33,words:400},title:"jsdelivr使用",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/mac%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90icns%E5%9B%BE%E6%A0%87.html",{loader:()=>a.e(98012).then(a.bind(a,81574)),meta:{author:"Navyum",date:1750160595e3,localizedDate:"2025年6月17日",category:["踩坑记录"],tag:["icns图标","iconutil"],sticky:!1,excerpt:'<h3>生成合适的icon png图片</h3>\n<ul>\n<li>使用豆包等大模型的文生图功能生成符合需要的icon</li>\n<li>这里推荐尺寸为1024*1024，且需要导出四周透明的png格式，名称修改为<code>icon.png</code></li>\n</ul>\n<h3>通去除背景，抠图操作</h3>\n<ul>\n<li>使用在线工具 https://www.remove.bg/upload</li>\n</ul>\n<h3>在mac上创建icns</h3>\n<ul>\n<li>\n<p>创建icons.iconset文件</p>\n<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">mkdir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> icons.iconset</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li>\n<p>导出各尺寸的png到icons.iconset中（名称后缀必须为.iconset，不要擅自修改，踩了坑就知道了）</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  Sips -z 16 16 icon.png -o icons.iconset/icon_16x16.png</span></span>\n<span class="line"><span>  Sips -z 32 32 icon.png -o icons.iconset/icon_16x16@2x.png</span></span>\n<span class="line"><span>  Sips -z 32 32 icon.png -o icons.iconset/icon_32x32.png</span></span>\n<span class="line"><span>  Sips -z 64 64 icon.png -o icons.iconset/icon_32x32@2x.png</span></span>\n<span class="line"><span>  Sips -z 128 128 icon.png -o icons.iconset/icon_128x128.png</span></span>\n<span class="line"><span>  Sips -z 256 256 icon.png -o icons.iconset/icon_128x128@2x.png</span></span>\n<span class="line"><span>  Sips -z 256 256 icon.png -o icons.iconset/icon_256x256.png</span></span>\n<span class="line"><span>  Sips -z 512 512 icon.png -o icons.iconset/icon_256x256@2x.png</span></span>\n<span class="line"><span>  Sips -z 512 512 icon.png -o icons.iconset/icon_512x512.png</span></span>\n<span class="line"><span>  Sips -z 1024 1024 icon.png -o icons.iconset/icon_512x512@2x.png</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>\n<p>使用iconutil将iconset生成为icns文件</p>\n<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">iconutil</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> icns</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> icons.iconset</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> icon.icns</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:.82,words:247},title:"mac系统生成icns图标",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/markdown%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7.html",{loader:()=>a.e(79353).then(a.bind(a,369)),meta:{date:1749983452e3,excerpt:"<p>/Users/haijun_yang/Downloads/Mermaid时序图控制语法完全指南.md$0---\ntitle: markdown高级技巧\ndate: 2025-06-17 11:43:44\nauthor: Navyum\ntags:</p>\n<ul>\n<li>markdown高级技巧\ncategories:</li>\n<li>技巧</li>\n<li>markdown</li>\n<li>踩坑记录\narticle: true\nindex: true</li>\n</ul>\n<h2>headerDepth: 2\nsticky: false\nstar: true</h2>\n<h3>解决图片居中和大小问题</h3>",readingTime:{minutes:1.44,words:433},title:"",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/paypal%E6%94%AF%E4%BB%98.html",{loader:()=>a.e(32008).then(a.bind(a,21422)),meta:{author:"Navyum",date:1736965768e3,localizedDate:"2025年1月15日",category:["编程","技术方案"],tag:["paypal支付"],excerpt:'<h2>paypal支付</h2>\n<h3>流程图</h3>\n<p><a href="../paypal.drawio" link-type="drawio">Drawio</a></p>\n<ol>\n<li>用户选择点击"信用卡支付"</li>\n<li>PC调用 <code>/api/pay/order/create/card?payway=paypal</code>创建paypal信用卡订单</li>\n<li>用户填写信用卡信息，一般会包含：卡号、有效期，CVV，以及姓名、地址、城市区域码等（第三方sdk）</li>\n<li>PC提交信用卡信息、order_id给paypal，paypal返回对应状态</li>\n<li>上述成功后，PC捕获支付capture_order，调用 <code>/api/pay/order/capture/card?payway=paypal</code>。pending状态：可以loading并提示等待片刻</li>\n<li>同时间，paypal可能通知服务端扣款完成，此处服务端确保订单状态幂等，避免多次扣款。</li>\n<li>PC轮训结果订单状态，调用 <code>/api/pay/order/query?payway=paypal</code>\n<ol>\n<li>查询到订单支付成功，跳转对应成果落地页</li>\n<li>查询到订单支付失败，跳转失败落地页</li>\n</ol>\n</li>\n<li>支付完成</li>\n</ol>',readingTime:{minutes:4.38,words:1313},title:"paypal支付",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/piclist.html",{loader:()=>a.e(87326).then(a.bind(a,97196)),meta:{author:"Navyum",date:1750160713e3,localizedDate:"2025年6月17日",category:["踩坑记录"],tag:["piclist"],sticky:!1,excerpt:"<h2>piclist</h2>\n<p>下载地址：https://github.com/Kuingsmile/PicList</p>\n<h2>食用方法：</h2>\n<p>参考官方文档</p>\n",readingTime:{minutes:.15,words:45},title:"piclist",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%85%B3%E4%BA%8EGEO%E4%BC%98%E5%8C%96.html",{loader:()=>a.e(23866).then(a.bind(a,28687)),meta:{author:"Navyum",date:1759074234e3,localizedDate:"2025年9月28日",category:["AI搜索","内容营销"],tag:["GEO优化","AI搜索","内容营销","生成式引擎优化"],sticky:!1,excerpt:"<h2>GEO优化实战指南：一周内直接让各大AI推荐了我的插件</h2>\n<h3>什么是GEO优化</h3>\n<p><strong>GEO（Generative Engine Optimization）</strong> 即生成式引擎优化，是一种新兴的数字营销策略。与传统SEO相比，SEO目标是在搜索结果页面上为网页排名，以获取流量；而GEO目则是影响AI模型本身，使其在生成的答案中引用、提及或推荐品牌内容</p>\n<h3>GEO的市场背景与机遇</h3>\n<p>随着ChatGPT、Gemini、DeepSeek、豆包等生成式AI助手的普及，用户获取信息的搜索行为正在经历深刻变革。我们越来越习惯从AI聊天软件、AI终端获取我们需要的信息，传统的搜索引擎正在进行AI化升级。</p>",readingTime:{minutes:8.23,words:2468},title:"GEO优化实战指南：从零到AI推荐第二名的成功经验",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html",{loader:()=>a.e(4088).then(a.bind(a,15414)),meta:{author:"Navyum",date:1760548141e3,localizedDate:"2025年10月15日",category:["插件","博客"],tag:["插件","博客"],sticky:!1,excerpt:'\n<div align="center">\n<p><img src="https://cdn.jsdelivr.net/gh/Navyum/imgbed@pic/IMG/4085bbf9332e16a75c8dd322763e9d53.png" alt="TaskMatrix Pro Banner" width="500" loading="lazy"></p>\n<p><em>TaskMatrix Pro - 基于艾森豪威尔矩阵的智能任务管理解决方案</em></p>\n</div>\n<p>在当今快节奏的工作环境中，如何高效管理任务和时间已成为每个职场人士必须面对的挑战。传统的任务管理方法往往效率低下，难以应对复杂多变的工作需求。今天，我们将深入探讨一款基于艾森豪威尔矩阵原理的智能任务管理插件——TaskMatrix Pro，它如何帮助用户实现工作效能的显著提升。</p>',readingTime:{minutes:6.81,words:2043},title:"插件推荐",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%99%BD%E5%AB%96huggingface%E7%9A%84API.html",{loader:()=>a.e(16569).then(a.bind(a,51188)),meta:{author:"Navyum",date:1738870275e3,localizedDate:"2025年2月6日",category:["踩坑记录"],tag:["LLM","hugging face","hf"],excerpt:'<h2>白嫖huggingface的API</h2>\n<h3>背景：</h3>\n<p>众所周知，hugging face中很多space资源都是可以直接使用的，那么如何将这些资源用在自己的项目中呢？</p>\n<h3>经过：</h3>\n<p>在使用Yank Note的 AI Extension时，发现文本转图片的端点是可以免费使用的，我忽然对此产生了兴趣\n免费的配置：</p>\n<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e1e56ea562c1d8593a2bd9842d9d62eb.png" width="40%"></p>',readingTime:{minutes:5.92,words:1776},title:"白嫖huggingface的API",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html",{loader:()=>a.e(11295).then(a.bind(a,38021)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["使用指南"],tag:["页面配置","使用指南"],sticky:!0,excerpt:"<h2>目标、路径</h2>\n<ol>\n<li>该类软件的目标、职责\n<ul>\n<li>为了解决什么问题？</li>\n</ul>\n</li>\n<li>工作原理：\n<ul>\n<li>实现上如何解决这些问题？</li>\n</ul>\n</li>\n<li>最佳使用场景：\n<ul>\n<li>哪些问题得到很好的解决？</li>\n</ul>\n</li>\n<li>架构思想：\n<ul>\n<li>常见的工程问题是如何解决的？\n<ul>\n<li>高可用、扩展性、高性能</li>\n<li>数据一致性</li>\n<li>事务支持</li>\n<li>数据丢失、持久化策略</li>\n</ul>\n</li>\n<li>系统、组件、组件之间的关系，如何协作的？</li>\n</ul>\n</li>\n<li>同类产品之间的架构差异、原因、设计上的取舍：\n<ul>\n<li>理解工程设计如何服务于产品？</li>\n</ul>\n</li>\n<li>设计上的大同之处，提炼核心？\n<ul>\n<li>掌握同类产品的设计核心、融汇贯通</li>\n</ul>\n</li>\n</ol>",readingTime:{minutes:.73,words:218},title:"0.学习路径",order:-1,type:"article"}}],["/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/%E4%BB%A3%E8%B0%A2%E7%B3%BB%E7%BB%9F.html",{loader:()=>a.e(84697).then(a.bind(a,40891)),meta:{author:"Navyum",date:1744889117e3,localizedDate:"2025年4月17日",category:["健身"],tag:["健身"],sticky:!1,excerpt:'<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&amp;display=swap" rel="stylesheet">\n<div style="background: white; border-radius: 16px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 30px; max-width: 1200px; width: 100%; margin: 20px; position: relative; overflow: hidden;">\n  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image: url(\'https://images.unsplash.com/photo-1546069901-ba9599a7e63c?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=2080&amp;q=80\'); background-size: cover; background-position: center; opacity: 0.8; z-index: 0;">\n  </div>\n  <div style="text-align: center; margin-bottom: 30px; position: relative; z-index: 1;">\n    <h1 style="color: #2c3e50; font-size: 28px; font-weight: 600; margin: 0 0 10px 0; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">代谢系统\n    </h1>\n    <p style="color: #7f8c8d; font-size: 16px; margin: 0;">从食物摄入到能量储存的完整代谢路径</p>\n  </div>\n  <div style="background: rgba(255, 255, 255, 0.5); padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); display: flex; justify-content: center; align-items: center; border: 1px solid rgba(255, 255, 255, 0.3); position: relative; z-index: 1;">\n  </div>\n  <div style="margin-top: 30px; text-align: center; color: #2c3e50; font-size: 14px; position: relative; z-index: 1;">\n    <p>基于代谢生理学原理 | 代谢路径可视化</p>\n  </div>\n</div>',readingTime:{minutes:2.22,words:665},title:"代谢系统",type:"article"}}],["/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/%E4%BE%9B%E8%83%BD%E7%B3%BB%E7%BB%9F.html",{loader:()=>a.e(94596).then(a.bind(a,77521)),meta:{author:"Navyum",date:1744889153e3,localizedDate:"2025年4月17日",category:["健身"],tag:["健身"],sticky:!1,excerpt:'<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&amp;display=swap" rel="stylesheet">\n<div style="background: white; border-radius: 16px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 30px; max-width: 1200px; width: 100%; margin: 20px; position: relative; overflow: hidden;">\n  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image: url(\'https://images.unsplash.com/photo-1517836357463-d25dfeac3438?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=2070&amp;q=80\'); background-size: cover; background-position: center; opacity: 0.7; z-index: 0;">\n  </div>\n  <div style="text-align: center; margin-bottom: 30px; position: relative; z-index: 1;">\n    <h1 style="color: #2c3e50; font-size: 28px; font-weight: 600; margin: 0 0 10px 0; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);">运动供能系统</h1>\n    <p style="color: #2c3e50; font-size: 16px; margin: 0;">从磷酸原系统到有氧氧化系统的完整代谢路径</p>\n  </div>\n  <div style="background: rgba(255, 255, 255, 0); padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); display: flex; justify-content: center; align-items: center; border: 1px solid rgba(255, 255, 255, 0.3); position: relative; z-index: 1;">\n  </div>\n  <div style="margin-top: 30px; text-align: center; color: #2c3e50; font-size: 14px; position: relative; z-index: 1;">\n    <p>基于运动生理学原理 | 供能路径可视化</p>\n  </div>\n</div>',readingTime:{minutes:2.49,words:747},title:"供能系统",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/06.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99.html",{loader:()=>a.e(3972).then(a.bind(a,44438)),meta:{author:"Navyum",date:1750171604e3,localizedDate:"2025年6月17日",category:["参考资料"],tag:["架构设计"],sticky:!1,excerpt:'<ul>\n<li><a href="https://freegeektime.com/100002201/10604/" target="_blank" rel="noopener noreferrer">必看耗子叔</a></li>\n<li><a href="https://freegeektime.com/posts/100046101/" target="_blank" rel="noopener noreferrer">极客时间</a></li>\n<li><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener noreferrer">必读 12-factors</a></li>\n<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener noreferrer">coolshell</a></li>\n<li><a href="https://www.infoq.cn/article/every-architect-should-study-conway-law" target="_blank" rel="noopener noreferrer">every-architect-should-study-conway-law</a></li>\n<li><a href="https://xie.infoq.cn/article/633911603a048b9f19c81cf29" target="_blank" rel="noopener noreferrer">https://xie.infoq.cn/article/633911603a048b9f19c81cf29</a></li>\n<li><a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html" target="_blank" rel="noopener noreferrer">eventually_consistent.html</a></li>\n<li><a href="https://microservices.io/patterns/index.html" target="_blank" rel="noopener noreferrer">patterns</a></li>\n<li><a href="https://patterns.arcitura.com/soa-patterns" target="_blank" rel="noopener noreferrer">soa-patterns</a></li>\n</ul>',readingTime:{minutes:.41,words:124},title:"06.参考资料",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html",{loader:()=>a.e(73855).then(a.bind(a,76744)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","数据结构"],tag:["学习路径"],sticky:!0,excerpt:"<h2>学习路径：</h2>\n<h3>阶段一：算法入门</h3>\n<ul>\n<li>我们需要<code>熟悉各种数据结构的特点和用法</code>，学习不同算法的原理、流程、用途和效率等方面的内容。</li>\n</ul>\n<h3>阶段二：刷算法题</h3>\n<ul>\n<li>建议从热门题目开刷，先积累至少 100 道题目，熟悉主流的算法问题。初次刷题时，<code>“知识遗忘”</code>可能是一个挑战，但请放心，这是很正常的。我们可以按照<code>“艾宾浩斯遗忘曲线”</code>来复习题目，通常在进行 3～5 轮的重复后，就能将其牢记在心。</li>\n</ul>\n<h3>阶段三：搭建知识体系</h3>",readingTime:{minutes:.96,words:289},title:"0.学习路径",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",{loader:()=>a.e(66740).then(a.bind(a,3751)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","数据结构"],tag:["思维导图"],sticky:!0,excerpt:"<h2>数据结构和算法</h2>\n<h3>线性表</h3>\n<ul>\n<li>数组</li>\n<li>链表\n<ul>\n<li>单链表</li>\n<li>双向链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n<li>静态链表</li>\n</ul>\n</li>\n<li>栈\n<ul>\n<li>顺序栈</li>\n<li>链式栈</li>\n</ul>\n</li>\n<li>队列\n<ul>\n<li>普通队列</li>\n<li>双端队列</li>\n<li>阻塞队列</li>\n<li>并发队列</li>\n<li>阻塞并发队列</li>\n</ul>\n</li>\n</ul>\n<h3>树</h3>",readingTime:{minutes:1.36,words:408},title:"1.思维导图",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D.html",{loader:()=>a.e(96370).then(a.bind(a,69878)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","数据结构"],tag:["参考书籍"],sticky:!0,excerpt:'<p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener noreferrer">labuladong</a>\n<a href="https://www.hello-algo.com/chapter_data_structure/summary/#2-q-a" target="_blank" rel="noopener noreferrer">hello-algo</a></p>\n',readingTime:{minutes:.15,words:46},title:"2.参考资料",order:-1,type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html",{loader:()=>a.e(42604).then(a.bind(a,62676)),meta:{author:"Navyum",date:1710103464e3,localizedDate:"2024年3月10日",category:["网络"],tag:["TCP/IP 五层"],sticky:!1,excerpt:'<h2>OSI七层：</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3fc3ca333ff5c39f2549e659c4337d40.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n<h2>TCP/IP 五层：</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ca37fd49c4711da68215198126a8de62.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>',readingTime:{minutes:.19,words:57},title:"01.网络模型",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%E5%B1%82%EF%BC%89.html",{loader:()=>a.e(17278).then(a.bind(a,18664)),meta:{author:"Navyum",date:1710262175e3,localizedDate:"2024年3月12日",category:["网络"],tag:["TCP"],sticky:!1,excerpt:"<p>工作原理：无脑广播，不管你需不需要，收到数据包就广播</p>\n",readingTime:{minutes:.19,words:57},title:"02.物理层（一层）",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81MAC%EF%BC%88%E4%BA%8C%E5%B1%82%EF%BC%89.html",{loader:()=>a.e(31253).then(a.bind(a,98315)),meta:{author:"Navyum",date:1710930193e3,localizedDate:"2024年3月20日",category:["网络"],tag:["MAC"],sticky:!1,excerpt:"<h3>数据链路层又叫MAC层</h3>\n<ul>\n<li>MAC：Medium Access Control，即媒体访问控制，存在连接的<code>设备 to 设备</code></li>\n<li>MAC地址 是一个局域网内才有效的地址</li>\n<li>目标MAC地址 只要过网关，就必定会改变</li>\n<li>目标MAC地址 记录的是<code>下一跳的地址</code></li>\n</ul>\n<h3>MAC层 主要解决问题：</h3>\n<ol>\n<li>解决包的接收对象</li>\n<li>解决包的有序、并发问题(多路访问)、制定发送规则</li>\n<li>解决发送失败等故障</li>\n</ol>",readingTime:{minutes:1.94,words:583},title:"03.数据链路层、MAC（二层）",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.%E7%BD%91%E7%BB%9C%E5%B1%82%E3%80%81IP%EF%BC%88%E4%B8%89%E5%B1%82%EF%BC%89.html",{loader:()=>a.e(24959).then(a.bind(a,9134)),meta:{author:"Navyum",date:1711292439e3,localizedDate:"2024年3月24日",category:["网络"],tag:["IP"],sticky:!1,excerpt:'<h2>网络层又叫IP层：</h2>\n<h3>主要的解决问题：</h3>\n<ol>\n<li>数据包的转发，<code>IP to IP</code></li>\n<li>路由选择</li>\n<li>IP地址的分配</li>\n<li>分片和重组</li>\n</ol>\n<h2>IP地址：</h2>\n<h3>分类：</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8fe2a027b29b28f86cae3a200c3219c6.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',readingTime:{minutes:6.76,words:2027},title:"04.网络层、IP（三层）",icon:"bxs:hot",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/05.%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%81TCP%EF%BC%88%E5%9B%9B%E5%B1%82%EF%BC%89.html",{loader:()=>a.e(83130).then(a.bind(a,38744)),meta:{author:"Navyum",date:1711572675e3,localizedDate:"2024年3月27日",category:["网络"],tag:["TCP"],sticky:!1,excerpt:"<h2>传输：</h2>\n<h3>数据传输格式：</h3>\n<ul>\n<li><code>MAC层</code>定义了本地局域网<code>设备</code>的传输行为</li>\n<li><code>IP层</code>定义了整个网络<code>端到端</code>的传输行为</li>\n<li><code>传输层</code>定义<code>应用程序到应用程序</code>的传输，基于端口区分</li>\n<li>这两层基本定义了包的特性：\n<ul>\n<li>网络传输是以包为单位的，<code>MAC层叫帧</code>Frame，<code>IP层叫包</code>Packet，包被分片后叫Fragment，<code>传输层叫段</code>Segment</li>\n<li>MAC层和IP层的我们笼统地称为包。包单独传输，自行选路，在不同的设备封装、解封装，不保证到达</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:17.52,words:5257},title:"05.传输层、TCP（四层）",icon:"bxs:hot",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81HTTP%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89.html",{loader:()=>a.e(15746).then(a.bind(a,2337)),meta:{author:"Navyum",date:1711929131e3,localizedDate:"2024年3月31日",category:["网络"],tag:["HTTP","HTTP2","TLS","QUIC","HTTP3"],sticky:!0,excerpt:'<h2>HTTP</h2>\n<h4>发送格式：</h4>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3e072d70ba9af070642f25856b372028.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n<h4>响应格式：</h4>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/31bc1a1c077cb1ef967ba20d2cda4c55.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>',readingTime:{minutes:15.51,words:4653},title:"08.应用层、HTTP（五层）",icon:"bxs:hot",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.%E7%BD%91%E7%BB%9CIO%E6%8A%80%E6%9C%AF-%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5.html",{loader:()=>a.e(39909).then(a.bind(a,89616)),meta:{author:"Navyum",date:1711740798e3,localizedDate:"2024年3月29日",category:["网络"],tag:["IO","NIO","AIO"],sticky:!1,excerpt:"<h2>简介</h2>\n<ul>\n<li>同步调用、异步调用的说法，是<strong>对于获取数据的过程</strong>而言的。</li>\n<li>例如发生read调用时，内核将数据从内核空间拷贝到应用程序空间。这个过程是在read函数中是<code>同步进行</code>的。如果内核实现的拷贝效率很差，read调用就会在这个同步过程中消耗比较长的时间。</li>\n<li>IO操作分两个阶段：\n<ol>\n<li>等待数据准备好 --读到内核缓存</li>\n<li>将数据从内核读到用户空间 --读到进程空间</li>\n</ol>\n</li>\n<li>一般来说过程1花费的时间远远大于过程2：\n<ul>\n<li><code>BIO</code>：1上阻塞2上也阻塞的是同步阻塞IO</li>\n<li><code>NIO</code>：1上非阻塞2阻塞的是同步非阻塞IO，Reactor就是这种模型</li>\n<li><code>AIO</code>：1上非阻塞2上非阻塞是异步非阻塞IO，Proactor模型就是这种模型</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:4.28,words:1284},title:"09.网络IO-阻塞、同步",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/08.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6IO%E4%BC%98%E5%8C%96.html",{loader:()=>a.e(66990).then(a.bind(a,40886)),meta:{author:"Navyum",date:1713295907e3,localizedDate:"2024年4月16日",category:["网络"],tag:["TCP"],sticky:!1,excerpt:'<h2>本地磁盘中文件发送到网络中：</h2>\n<h3>1. 直接 IO 技术</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/92fdae49b711f79a0d55ddc156359115.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<ul>\n<li>\n<p><code>内核缓冲区</code>又叫做Linux系统的<code>Page Cahe</code>。\n为了加快磁盘的IO，Linux系统会把磁盘上的数据以 Page为单位缓存在操作系统的内存里，这里的Page是 Linux 系统定义的一个逻辑概念，一个Page一般为4K</p>\n</li>\n<li>\n<p>整个过程有四次数据拷贝，读进来两次，写回去又两次：</p>\n<ul>\n<li>磁盘 --&gt; 内核缓冲区 --&gt; 用户态程序</li>\n<li>用户态程序 --&gt; Socket缓冲区--&gt; 网络</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.44,words:431},title:"10.网络文件IO优化",icon:"bxs:hot",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/09.SSH%E5%85%AC%E7%A7%81%E9%92%A5%E9%AA%8C%E8%AF%81.html",{loader:()=>a.e(86846).then(a.bind(a,78962)),meta:{author:"Navyum",date:1747083237e3,localizedDate:"2025年5月12日",category:["网络"],tag:["AES","TLS","非对称加密"],sticky:!1,excerpt:'<h2>SSH是否真的安全</h2>\n<h3>背景</h3>\n<ul>\n<li>\n<p>在配置完git公钥之后，首次使用git从仓库拉取代码时，都会有如下提示：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/88e816257eb222148ea91dfaa62d89d5.png" alt="Img" loading="lazy"></p>\n</li>\n<li>\n<p>问题：</p>\n<ol>\n<li>为什么要验证这个指纹？</li>\n<li>如何验证这个指纹是否正确呢？</li>\n<li>SSH通信、代理服务是否真的安全呢？</li>\n</ol>\n</li>\n</ul>',readingTime:{minutes:7,words:2099},title:"11.SSH公私钥验证",icon:"bxs:hot",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.socket%E7%BC%96%E7%A8%8B.html",{loader:()=>a.e(61985).then(a.bind(a,44315)),meta:{author:"Navyum",date:1713382473e3,localizedDate:"2024年4月17日",category:["网络"],tag:["socket编程"],sticky:!1,excerpt:'<h3>基本信息：</h3>\n<ul>\n<li>\n<p>在内核中，Socket是一个文件，对应一个文件描述符。文件描述符是一个整数，是描述符数组的下标值</p>\n</li>\n<li>\n<p>每一个进程都有一个数据结构 <code>task_struct</code>，里面指向一个<code>文件描述符数组</code>，表示这个进程打开的所有文件的文件描述符</p>\n</li>\n<li>\n<p>socket 对应的 inode 指向了 Socket 在内核中的 <code>socket 结构</code></p>\n</li>\n<li>\n<p><code>socket 结构</code>有两个队列，即发送队列sk_write_queue和接收队列sk_recieve_queue</p>\n</li>\n<li>\n<p>队列里面保存的是若干缓存 <code>sk_buff</code>，即套接字缓冲区</p>\n</li>\n<li>\n<p>套接字缓冲区<code>sk_buf</code>里面存储的是包的信息</p>\n</li>\n<li>\n<p>Socket相关结构：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/5c5c80c3921c536bda3cc814985fba56.png" alt="图片" loading="lazy"></p>\n</li>\n</ul>',readingTime:{minutes:.78,words:234},title:"12.socket编程",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/50.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%98%E7%9B%AE.html",{loader:()=>a.e(7392).then(a.bind(a,64834)),meta:{author:"Navyum",date:1709841288e3,localizedDate:"2024年3月7日",category:["网络"],tag:["TCP"],sticky:!1,excerpt:"<p>内核源码：https://elixir.bootlin.com/linux/latest/source</p>\n<p>★★★ 各层协议的作用，以及 TCP/IP 协议的特点。</p>\n<p>★★☆ 以太网的特点，以及帧结构。</p>\n<p>★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。</p>\n<p>★★☆ IP 数据数据报常见字段的作用。</p>\n<p>★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。</p>\n<p>★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</p>\n<p>★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</p>",readingTime:{minutes:1.32,words:396},title:"50.常见的题目",icon:"zondicons:network",type:"article"}}],["/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",{loader:()=>a.e(82162).then(a.bind(a,48741)),meta:{title:"README",icon:"zondicons:network"}}],["/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/Ready4Interview.html",{loader:()=>a.e(3129).then(a.bind(a,55634)),meta:{author:"Navyum",date:1750159453e3,localizedDate:"2025年6月17日",category:["面试"],tag:["面试"],sticky:!1,excerpt:"<h3>前言</h3>\n<p>由于我做了比较长时间的技术面试官，根据我的面试体会，不少同学收到面试后，什么准备也不会做，到时候问题就来了。</p>\n<p>这样做的后果是：不知彼，不知己，每战必殆。哪怕侥幸面试成，工资一定会被压得很低。</p>\n<p>其实公司肯花时间让你去面试，前提条件一定是通过你的简历，一定发现了你和公司的匹配点，也就是说，一定是有录用意向的。</p>\n<p>在技术面试的时间段里（最长1个小时），你如果能展现你的优势那是最好的，但如果你做不到这点，简单点，让面试官感觉你达到了最低标准即可。这好比在大学里考试，有些同学对某门课的知识点完全不懂，但也有可能通过考前突击和刷题来通过考试（不作弊），而且还有可能考高分。</p>",readingTime:{minutes:15.35,words:4606},title:"面试准备",type:"article"}}],["/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/%E7%AE%80%E5%8E%86%E6%A8%A1%E7%89%88.html",{loader:()=>a.e(32282).then(a.bind(a,93609)),meta:{author:"Navyum",date:1750159487e3,localizedDate:"2025年6月17日",category:["面试"],tag:["简历"],sticky:!1,excerpt:'<h2>工具：</h2>\n<p><a href="https://create.microsoft.com/en-us/templates/resumes" target="_blank" rel="noopener noreferrer">微软resume</a></p>\n<h2>算法：</h2>\n<p>动态规划Top20：<a href="https://www.geeksforgeeks.org/top-20-dynamic-programming-interview-questions/" target="_blank" rel="noopener noreferrer">Top 20 Dynamic Programming Interview Questions</a></p>',readingTime:{minutes:.21,words:63},title:"简历模版",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/01.Transformer.html",{loader:()=>a.e(93201).then(a.bind(a,18757)),meta:{author:"Navyum",date:173072088e4,localizedDate:"2024年11月4日",category:["LLM","AI"],tag:["LLM","概念"],excerpt:'<h2>概念</h2>\n<h2>Transformer</h2>\n<ul>\n<li>Transformer 是 Google 的团队在 2017 年提出的一种 NLP 经典模型，现在比较火热的 Bert 也是基于 Transformer。</li>\n<li>Transformer 模型使用了注意力机制（attention mechanisms），不采用 RNN 的顺序结构，使得模型可以并行化训练，而且能够拥有全局信息</li>\n<li>Transformer 使用的是Encoder + Decoder的结构</li>\n</ul>\n<h2>Transformer 整体结构</h2>\n<ul>\n<li>添加了补充信息（手动修改版）：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4c3e702e3e84a73026ad2f2ab2087d3d.png" alt="Img" loading="lazy"></li>\n</ul>',readingTime:{minutes:9.25,words:2774},title:"01.Transformer",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/02.GPT.html",{loader:()=>a.e(16882).then(a.bind(a,91585)),meta:{author:"Navyum",date:173143006e4,localizedDate:"2024年11月12日",category:["LLM","AI"],tag:["LLM","GPT"],excerpt:'<h2>GPT：</h2>\n<ul>\n<li>Generative Pre-Trained Transformer即生成式预训练转换器，其架构基于原始的 transformer 的<strong>解码器</strong></li>\n</ul>\n<h2>GPT主要训练阶段：</h2>\n<h3>无监督预训练PT（Unsupervised Pre-training）：</h3>\n<p>定义：在未标记的文本上预训练 GPT，从而利用丰富的文本语料库。该阶段又叫做生成式预训练。\n任务：训练模型以了解语言的结构并捕获文本数据集中存在的统计模式。它不是针对特定的语言任务，而是<span style="color: rgb(255, 41, 65);">提高模型对语言本身的理解</span>。\n具体：无监督预训练将一系列标记提供给模型（Transformer 解码器的变体）以预测下一个标记的概率。它在下图中显示为 “Text Prediction” （其中“Task Classifier” 用于监督微调SFT阶段）\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/026b670dec056d8526150d6774badceb.png" alt="Img" loading="lazy"></p>',readingTime:{minutes:3.4,words:1019},title:"02.GPT",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/03.Prompt.html",{loader:()=>a.e(38520).then(a.bind(a,95019)),meta:{author:"Navyum",date:1750170722e3,localizedDate:"2025年6月17日",category:["LLM","AI"],tag:["LLM","Prompt"],sticky:!1,excerpt:'<h2>结构化Prompt：</h2>\n<h3>LangGPT的写法：</h3>\n<div class="language-markdown line-numbers-mode" data-highlighter="shiki" data-ext="markdown" data-title="markdown" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    # Role: &lt;name&gt; : 指定角色会让 GPT 聚焦在对应领域进行信息输出</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    ## Profile author/version/description : Credit 和 迭代版本记录</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    ## Goals: 一句话描述 Prompt 目标, 让 GPT Attention 聚焦起来</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    ## Constrains: 描述限制条件, 其实是在帮 GPT 进行剪枝, 减少不必要分支的计算</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    ## Skills: 描述技能项, 强化对应领域的信息权重</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    ## Workflow: 重点中的重点, 你希望 Prompt 按什么方式来对话和输出</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    # Initialization: 冷启动时的对白, 也是一个强调需注意重点的机会</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:10.94,words:3281},title:"03.Prompt",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/04.Models.html",{loader:()=>a.e(16499).then(a.bind(a,11670)),meta:{author:"Navyum",date:175017075e4,localizedDate:"2025年6月17日",category:["LLM","AI"],tag:["LLM","Prompt"],sticky:!1,excerpt:'<h3>ViT（Google 图像分类模型）</h3>\n<ul>\n<li>ViT是一种没有 CNN（卷积神经网络）的图像分类模型（Vision Transformer），从图像分类任务中消除了 CNN</li>\n<li>ViT 将图像拆分为一系列图像补丁嵌入与位置编码混合，并将它们馈送到 Transformer 编码器中。ViT 有一个分类头 （MLP - 多层感知），它产生最终的预测\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3f10b60a7e8a4b98fece3f16f2e3a2f9.png" alt="Img" loading="lazy"></li>\n<li>注意力可视化\n<ul>\n<li>ViT 可以捕捉图像中的主要对象，忽略图像中的噪声</li>\n</ul>\n</li>\n<li>计算复杂度与输入图像大小呈<strong>二次方关系</strong></li>\n</ul>',readingTime:{minutes:3.23,words:968},title:"04.Models",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/01.%E6%A1%86%E6%9E%B6/eino.html",{loader:()=>a.e(25394).then(a.bind(a,7486)),meta:{author:"Navyum",date:1750760293e3,localizedDate:"2025年6月24日",category:["LLM"],tag:["LLM"],sticky:!1,readingTime:{minutes:.08,words:25},title:"eino",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/01.%E6%A1%86%E6%9E%B6/langchain.html",{loader:()=>a.e(45802).then(a.bind(a,48966)),meta:{author:"Navyum",date:1750760309e3,localizedDate:"2025年6月24日",category:["LLM"],tag:["LLM"],sticky:!1,readingTime:{minutes:.08,words:25},title:"langchain",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/02.RAG/RAG.html",{loader:()=>a.e(23772).then(a.bind(a,90035)),meta:{date:1749983452e3,excerpt:'<h2>图解</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e79d3100989ffdb1827aeceef17832a6.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9c8ef3ccb21f27e9ab8e5646c4ee7723.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',readingTime:{minutes:.03,words:8},title:"",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/03.%E5%BE%AE%E8%B0%83/",{loader:()=>a.e(37710).then(a.bind(a,25806)),meta:{date:1749983452e3,excerpt:"\n<p>TODO</p>\n",readingTime:{minutes:.01,words:2},title:"README",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/04.%E5%BA%94%E7%94%A8/%E5%85%B3%E4%BA%8EGEO%E4%BC%98%E5%8C%96Generative-Engine-Optimization.html",{loader:()=>a.e(32285).then(a.bind(a,57365)),meta:{author:"Navyum",date:1759074234e3,localizedDate:"2025年9月28日",category:["AI搜索","内容营销"],tag:["GEO优化","AI搜索","内容营销","生成式引擎优化"],sticky:!1,excerpt:"<h2>GEO优化实战指南：一周内直接让豆包聊天推荐了我的插件</h2>\n<h3>什么是GEO优化</h3>\n<p><strong>GEO（Generative Engine Optimization）</strong> 即生成式引擎优化，是一种新兴的数字营销策略。与传统SEO相比，SEO目标是在搜索结果页面上为网页排名，以获取流量；而GEO目则是影响AI模型本身，使其在生成的答案中引用、提及或推荐品牌内容</p>\n<h3>GEO的市场背景与机遇</h3>\n<p>随着ChatGPT、Gemini、DeepSeek、豆包等生成式AI助手的普及，用户获取信息的搜索行为正在经历深刻变革。我们越来越习惯从AI聊天软件、AI终端获取我们需要的信息，传统的搜索引擎正在进行AI化升级。</p>",readingTime:{minutes:9.08,words:2725},title:"GEO优化实战指南：从零到AI推荐第二名的成功经验",type:"article"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/04.%E5%BA%94%E7%94%A8/%E7%99%BD%E5%AB%96huggingface%E7%9A%84API.html",{loader:()=>a.e(12233).then(a.bind(a,34323)),meta:{author:"Navyum",date:1738870275e3,localizedDate:"2025年2月6日",category:["LLM","AI"],tag:["LLM","Prompt"],excerpt:'<h2>白嫖huggingface的API</h2>\n<h3>背景：</h3>\n<p>众所周知，hugging face中很多space资源都是可以直接使用的，那么如何将这些资源用在自己的项目中呢？</p>\n<h3>经过：</h3>\n<p>在使用Yank Note的 AI Extension时，发现文本转图片的端点是可以免费使用的，我忽然对此产生了兴趣\n免费的配置：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e1e56ea562c1d8593a2bd9842d9d62eb.png" width="40%"></p>\n<p>带着好奇，我直接打开对应的端点<a href="https://black-forest-labs-flux-1-schnell.hf.space" target="_blank" rel="noopener noreferrer">https://black-forest-labs-flux-1-schnell.hf.space</a>：\n端点地址：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/af902ebd4e64aa4bd9632a6fe14f85f0.png" width="40%"></p>',readingTime:{minutes:5.88,words:1765},title:"白嫖huggingface的API",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/FlameGraph-%E7%81%AB%E7%84%B0%E5%9B%BE.html",{loader:()=>a.e(41309).then(a.bind(a,71266)),meta:{author:"Navyum",date:1750159574e3,localizedDate:"2025年6月17日",category:["工具","性能分析","FlameGraph"],tag:["性能分析","可视化","FlameGraph"],sticky:!1,excerpt:'<p>火焰图是一种分层数据<strong>可视化工具</strong>，用于直观展示程序中时间都花在了哪里。\n栈采样：每秒多次，程序中的线程会被中断，同时记录下代码中的当前位置（基于线程的指令指针），以及到达该位置所调用的函数链。聚合结果。\n说明：\n* y轴表示：堆栈深度，主函数更靠近底部\n* x轴表示：涵盖所有样本，其顺序无意义。<span style="color: rgb(255, 41, 65);">对于CPU火焰图来说，其宽度表示：该函数在 CPU 上运行或处于调用堆栈中的总时间。</span></p>\n<h3>性能数据采集工具介绍</h3>\n<h4>1. 使用 Perf 采集数据</h4>',readingTime:{minutes:2.79,words:837},title:"FlameGraph-火焰图",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/",{loader:()=>a.e(72884).then(a.bind(a,96390)),meta:{author:"Navyum",date:1750159601e3,localizedDate:"2025年6月17日",category:["工具","性能分析"],tag:["性能分析","可视化","trace"],sticky:!1,excerpt:'<h3>动态追踪原理</h3>\n<p>动态追踪工具在逻辑上比较简单：大多是通过类C语言创建一个脚本，通过编译器翻译成探测代码。<strong>通过一个内核地址模块加载探测代码到内核地址空间，然后patch到当前内核的二进制代码中</strong>。探针将收集的数据写到中间缓冲（这些buffers往往是lock-free的，所以他们对内核性能有较少影响，且不需要切换上下文到追踪程序）。另一个独立的实体消费者读取这些buffers，然后输出数据。</p>\n<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8299a9ca33a70fb4ff37387be18a0b2c.png" width="60%"></p>',readingTime:{minutes:1.31,words:394},title:"静态动态追踪原理",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-Beginners-Guide%E4%B8%AD%E6%96%87%E7%89%88.html",{loader:()=>a.e(12221).then(a.bind(a,85207)),meta:{author:"Navyum",date:1744675954e3,localizedDate:"2025年4月15日",category:["英文翻译","工具","性能分析","Systemtap"],tag:["Systemtap新手指南","Systemtap"],excerpt:'\n<hr>\n<p>本文为<a href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide.pdf" target="_blank" rel="noopener noreferrer">《Systemtap-Beginners-Guide》</a>中文版翻译，仅供学习参考使用，如有翻译错误，请及时联系作者<a href="https://github.com/Navyum/Navyum" target="_blank" rel="noopener noreferrer">Navyum</a>更新修正。</p>\n<h2>SystemTap简介</h2>',readingTime:{minutes:110.24,words:33073},title:"Systemtap-Beginners-Guide中文版",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-Language-Reference%E4%B8%AD%E6%96%87%E7%89%88.html",{loader:()=>a.e(8877).then(a.bind(a,50742)),meta:{author:"Navyum",date:1744657028e3,localizedDate:"2025年4月14日",category:["英文翻译","工具","性能分析","Systemtap"],tag:["Systemtap手册","SystemTap语法","Systemtap"],excerpt:'\n<hr>\n<p>本文为<a href="https://sourceware.org/systemtap/langref.pdf" target="_blank" rel="noopener noreferrer">《Systemtap-Language-Reference》</a>中文版翻译，仅供学习参考使用，如有翻译错误，请及时联系作者<a href="https://github.com/Navyum/Navyum" target="_blank" rel="noopener noreferrer">Navyum</a>更新修正。</p>\n<p>原文最终修改时间：2024年11月8日</p>',readingTime:{minutes:73.75,words:22124},title:"Systemtap-Language-Reference中文版",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-tapset.html",{loader:()=>a.e(53244).then(a.bind(a,32807)),meta:{author:"Navyum",date:1750159692e3,localizedDate:"2025年6月17日",category:["工具","性能分析","英文翻译","Systemtap"],tag:["SystemTap"],sticky:!1,excerpt:"<h2>SystemTap</h2>\n<hr>\n<h3>SystemTap Tapset Reference Manual</h3>\n<p>by SystemTap</p>\n<p>Copyright © 2008-2015 Red Hat, Inc. and others</p>\n<p>This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 aspublished by the Free Software Foundation.</p>",readingTime:{minutes:141.05,words:42314},title:"SystemTap Tapset Reference Manual",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/eBPF%E6%8A%80%E6%9C%AF.html",{loader:()=>a.e(96722).then(a.bind(a,82206)),meta:{author:"Navyum",date:1750159773e3,localizedDate:"2025年6月17日",category:["工具","性能分析"],tag:["性能分析","可视化","eBPF"],sticky:!1,excerpt:"<h3>eBPF的原理</h3>\n<p>使用验证器保证安全性，通过BPF映射实现内核-用户空间通信\n所有与用户空间的交互都是通过 eBPF“映射”进行的，这些映射是键值存储。\n每个 eBPF 程序都将在一定的有限执行时间内完成，即非图灵完备</p>\n<h3>bcc</h3>\n<p>BCC适合使用了其他库的复杂脚本、守护进程</p>\n<h3>bpftrace</h3>\n<ul>\n<li>\n<p>优点：\nbpftrace基于内置Linux技术，不用追赶内核版本改动，稳定性更高\n脚本执行速度比systemtap快（使用llvm编译成BPF）</p>\n</li>\n<li>\n<p>缺点：\nbpftrace语言特性上没有systemtap丰富，不太能进行复杂的探测操作\n探针附到函数一定偏移处不方便\n无法直接获取函数的局部变量\n无法直接获取结构体信息\n内核版本要求较高，在较旧的发行版上难以安装</p>\n</li>\n</ul>",readingTime:{minutes:.97,words:291},title:"eBPF技术",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%88%86%E6%9E%90.html",{loader:()=>a.e(99048).then(a.bind(a,17715)),meta:{author:"Navyum",date:1744383178e3,localizedDate:"2025年4月11日",category:["工具","性能分析","Systemtap"],tag:["SystemTap","nginx源码","性能分析","TCP FIN","TCP RST"],excerpt:'<h2>systemTap分析</h2>\n<p>本文主要通过案例演示的方式，介绍个人在使用systemtap对nginx（openresty）进行网络相关的探测的使用过程、使用感受以及过程中遇到的问题</p>\n<h3>背景介绍：</h3>\n<p>问题： 分析openresty（nginx）在出现abort时，为什么FIN正常关闭TCP连接，而不是使用RST？</p>\n<h3>第一步：需要知道如何添加探测点</h3>\n<ul>\n<li>探测点跟断点的概念类似，就是在指定位置，进行debug信息的输出</li>\n<li><strong>重要！</strong> 查看对应程序的所有function，以nginx为例<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">  # 查看Nginx可用的探针点</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> stap</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -L</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> \'process("/usr/local/openresty/nginx/sbin/nginx").function("*")\'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">还有一种方式是：使用nm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> ./sbin/nginx，但是看不到参数和文件位置</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">  # 看到的输出如下：</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2">  ...</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_variables_add_core_vars@src/http/ngx_http_variables.c:2592"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$cf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_conf_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_variables_init_vars@src/http/ngx_http_variables.c:2635"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$cf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_conf_t* </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$hash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_hash_init_t</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_wait_request_handler@src/http/ngx_http_request.c:375"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$rev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_event_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_weak_etag@src/http/ngx_http_core_module.c:1703"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_http_request_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_write_filter@src/http/ngx_http_write_filter_module.c:48"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_http_request_t* </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_chain_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_write_filter_init@src/http/ngx_http_write_filter_module.c:362"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$cf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_conf_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_write_request_body@src/http/ngx_http_request_body.c:484"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_http_request_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_writer@src/http/ngx_http_request.c:2786"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_http_request_t*</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">  process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_http_xss_body_filter@../xss-nginx-module-0.06/src/ngx_http_xss_filter_module.c:264"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_http_request_t* </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_chain_t* </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$ll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_chain_t**</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>找到需要添加探测点的函数、结构体、变量\n<ul>\n<li>假设我们需要找nginx中，某个URI的函数调用栈信息</li>\n<li>添加探测点之前，我们需要一些基础知识。nginx关闭连接的标准函数为：<code>ngx_close_connection</code></li>\n<li>通过如下命令，查看当前版本是否可以添加相应探测点<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> stap</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> -L</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> \'process("/usr/local/openresty/nginx/sbin/nginx").function("*")\'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> ngx_close_connection</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">process(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"/usr/local/openresty/nginx/sbin/nginx"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">).function(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">"ngx_close_connection@src/core/ngx_connection.c:1179"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">:ngx_connection_t*</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>这样我们确认当前的nginx版本存在函数，且得到该函数的第一个参数为<code>$c</code>，属于结构体指针<code>ngx_connection_t*</code></li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:4,words:1199},title:"systemTap分析",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(99811).then(a.bind(a,6070)),meta:{author:"Navyum",date:1743676376e3,localizedDate:"2025年4月3日",category:["工具","性能分析","Systemtap"],tag:["SystemTap","性能分析"],excerpt:'<h2>systemTap原理</h2>\n<ul>\n<li>将stp文件编译为C文件，再将C文件编译为内核模块.ko文件，将.ko文件加载到内核中，最终利用内核提供的 <code>kprobes 机制</code>来设置探测点，采集数据存储到<code>probe.out</code>，从而进行系统性能分析。</li>\n</ul>\n<h3>一、systemTap运行流程</h3>\n<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/031aa72127709b2fa27f4e1fda97d28a.png"></p>',readingTime:{minutes:2.05,words:616},title:"systemTap原理",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%AE%89%E8%A3%85.html",{loader:()=>a.e(51116).then(a.bind(a,89112)),meta:{author:"Navyum",date:1743676337e3,localizedDate:"2025年4月3日",category:["工具","性能分析","Systemtap"],tag:["SystemTap","性能分析"],excerpt:'<h2>systemTap安装</h2>\n<h2>当前环境：cenos7</h2>\n<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$cat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> /etc/redhat-release</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> CentOS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> Linux</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> release</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> 7.9.2009</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> (Core) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic"># 查看操作系统版本</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">$uname</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> -r</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> 3.10.0-1160.53.1.el7.x86_64</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">      # 查看内核版本</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:1.39,words:418},title:"systemTap安装",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemtap%E7%AC%94%E8%AE%B0.html",{loader:()=>a.e(52478).then(a.bind(a,36954)),meta:{author:"Navyum",date:1744914454e3,localizedDate:"2025年4月17日",category:["工具","性能分析","Systemtap"],tag:["SystemTap","性能分析"],excerpt:"<h2>笔记</h2>\n<ul>\n<li>SystemTap的语法基础跟C语言类似，这里只记录存在差异的点和systemtap特有的语法</li>\n<li>SystemTap的语言是<code>强类型、无声明的过程式语言</code>，受dtrace和awk的启发</li>\n</ul>\n<hr>\n<h2>一、命令行参数</h2>\n<p>以下列举几个常用的参数</p>\n<h3>-x PID</h3>\n<p>-x用于传递PID参数给systemtap脚本，程序内部可以通过内置函数<code>target()</code>获取到\ne.g.：<code>target() == pid()</code></p>",readingTime:{minutes:21.15,words:6345},title:"systemtap笔记",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHTTP%E7%8A%B6%E6%80%81%E7%A0%81200%E7%9A%84%E5%BC%82%E5%B8%B8.html",{loader:()=>a.e(52565).then(a.bind(a,75931)),meta:{author:"Navyum",date:1744134936e3,localizedDate:"2025年4月8日",category:["wireshark","工具"],tag:["wireshark","抓包","chunk格式"],sticky:!0,excerpt:'<h2>wireshark抓包</h2>\n<h3>nginx server 以 content-type chunk格式返回的程序异常</h3>\n<hr>\n<h3>背景：</h3>\n<p>业务需要通过脚本跑一批数据，数据有很多条，每条数据需要进行一次数据库查询、一次OSS下载，最终才能确定该记录的输出</p>\n<div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输出举例：</span></span>\n<span class="line"><span>记录A： DB记录1 + OSS记录1</span></span>\n<span class="line"><span>记录B： DB记录2 + OSS记录2</span></span>\n<span class="line"><span>...</span></span>\n<span class="line"><span>记录N： DB记录N + OSS记录N</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:6.7,words:2009},title:"wireshark抓包之HTTP状态码200的异常",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHost%E6%A0%A1%E9%AA%8C%E7%9A%84%E5%BC%82%E5%B8%B8.html",{loader:()=>a.e(71882).then(a.bind(a,80645)),meta:{author:"Navyum",date:1743174671e3,localizedDate:"2025年3月28日",category:["wireshark","工具"],tag:["wireshark","抓包","tomcat"],sticky:!0,excerpt:'<h2>wireshark抓包</h2>\n<h3>nginx 负载均衡导致的400错误</h3>\n<hr>\n<h3>背景：</h3>\n<p>因为转换服务比较耗CPU等资源，业务层针对pdf转offcie服务做负载均衡</p>\n<h3>出现问题：</h3>\n<p>未做负载均衡前，一切正常；添加负载均衡之后反而失败了</p>\n<h3>出错的nginx配置</h3>\n<div class="language-nginx.conf line-numbers-mode" data-highlighter="shiki" data-ext="nginx.conf" data-title="nginx.conf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>location /aspose_sdk/</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    client_body_buffer_size 30M;</span></span>\n<span class="line"><span>    client_max_body_size 30M;</span></span>\n<span class="line"><span>    proxy_pass http://aspose_sdk/;</span></span>\n<span class="line"><span>    proxy_set_header Connection "";</span></span>\n<span class="line"><span>    proxy_http_version 1.0;</span></span>\n<span class="line"><span>    proxy_connect_timeout 10;</span></span>\n<span class="line"><span>    proxy_send_timeout 30;</span></span>\n<span class="line"><span>    proxy_read_timeout 300;</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:2.21,words:662},title:"wireshark抓包-Host校验的异常",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHost%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE.html",{loader:()=>a.e(96017).then(a.bind(a,9550)),meta:{author:"Navyum",date:1750275632e3,localizedDate:"2025年6月18日",category:["wireshark","工具"],tag:["wireshark","抓包","host错误"],sticky:!0,excerpt:'<h2>wireshark抓包</h2>\n<h3>Sling 请求k8s负载均衡器，导致的404错误</h3>\n<hr>\n<h3>背景：</h3>\n<p>在一次业务开发中，业务中需要请求k8s服务地址。但是业务逻辑中的请求总是提示HTTP 404错误，使用curl 命令又是正确的。</p>\n<h3>出现问题：</h3>\n<p>在golang项目中，使用<a href="https://github.com/dghubble/sling" target="_blank" rel="noopener noreferrer">Sling库</a>作为clinet，进行网络请求以获取服务响应结果</p>',readingTime:{minutes:4.14,words:1241},title:"wireshark抓包之Host设置不正确",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BSSL%E6%8F%A1%E6%89%8B%E9%97%AE%E9%A2%98.html",{loader:()=>a.e(73517).then(a.bind(a,97180)),meta:{author:"Navyum",date:1743174685e3,localizedDate:"2025年3月28日",category:["wireshark","工具"],tag:["抓包","网络分析","TSL握手失败","wireshark"],sticky:!0,excerpt:'<h2>wireshark抓包</h2>\n<h3>SNI问题导致的网关层返回502错误</h3>\n<hr>\n<h3>背景：</h3>\n<p>最近攻防等原因，运维将测试环境部分域名上了cloudflare（主要是海外）</p>\n<h3>业务方出现的问题：</h3>\n<p>在nginx中，这些域名被用做反向代理的upstream，在添加cloudflare之后，访问出现 http 502，具体配置如下</p>\n<h3>出错的nginx配置</h3>\n<div class="language-nginx.conf line-numbers-mode" data-highlighter="shiki" data-ext="nginx.conf" data-title="nginx.conf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>location /proxy/cn/</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    proxy_pass https://user_cs_cn_backend/;</span></span>\n<span class="line"><span>    proxy_http_version 1.1;</span></span>\n<span class="line"><span>    proxy_set_header Host "api-cs-cn-sandbox.intsig.net";</span></span>\n<span class="line"><span>    proxy_set_header Connection "keep-alive";</span></span>\n<span class="line"><span>    proxy_connect_timeout 5;</span></span>\n<span class="line"><span>    proxy_send_timeout 10;</span></span>\n<span class="line"><span>    proxy_read_timeout 10;</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:2.29,words:688},title:"wireshark抓包-SSL握手",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BSSL%E6%8F%A1%E6%89%8B%E9%97%AE%E9%A2%98%E4%BA%8C.html",{loader:()=>a.e(63345).then(a.bind(a,67256)),meta:{author:"Navyum",date:1743174685e3,localizedDate:"2025年3月28日",category:["wireshark","工具"],tag:["抓包","网络问题分析","TSL握手失败","wireshark抓包"],sticky:!0,excerpt:'<h2>wireshark抓包</h2>\n<h3>证书过期问题导致的网关层返回502错误</h3>\n<hr>\n<h3>背景：</h3>\n<p>新对接的新服务，在nginx上配置为反向代理upstream进行访问</p>\n<h3>业务方出现的问题：</h3>\n<p>访问时稳定复现502错误，但是使用curl则正常。nginx配置如下：</p>\n<h3>出错的nginx配置</h3>\n<div class="language-nginx.conf line-numbers-mode" data-highlighter="shiki" data-ext="nginx.conf" data-title="nginx.conf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>location /test</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    proxy_pass https://middleground_workonly_backend/xxx/xxx;</span></span>\n<span class="line"><span>    proxy_http_version 1.1;</span></span>\n<span class="line"><span>    proxy_set_header Host "xxx-sandbox-workonly.xxx.xxx";</span></span>\n<span class="line"><span>    proxy_set_header Connection "keep-alive";</span></span>\n<span class="line"><span>    proxy_connect_timeout 5;</span></span>\n<span class="line"><span>    proxy_send_timeout 10;</span></span>\n<span class="line"><span>    proxy_read_timeout 10;</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:1.74,words:522},title:"wireshark抓包-SSL握手",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85.html",{loader:()=>a.e(85404).then(a.bind(a,69883)),meta:{author:"Navyum",date:1754933158e3,localizedDate:"2025年8月11日",category:["wireshark","工具"],tag:["抓包","wireshark抓包","网络分析","故障排查"],sticky:!0,excerpt:'<h2>wireshark抓包之如何抓包</h2>\n<p>Wireshark是世界上最流行的网络协议分析器，它能够深入检查网络流量，帮助开发者、网络管理员和安全专家诊断网络问题、分析协议行为、排查安全事件。本文将详细介绍Wireshark的使用方法，从基础配置到高级分析技巧。</p>\n<h3>环境准备与配置</h3>\n<h4>Linux环境配置（需要进行HTTPS解析时）</h4>\n<p>在进行HTTPS流量分析时，需要配置SSL/TLS密钥日志文件，以便Wireshark能够解密HTTPS流量。</p>\n<p><strong>1. 创建SSL密钥日志文件</strong></p>\n<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic"># 创建密钥日志文件</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">touch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> /data/sslkeylogfile</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic"># 确保文件权限正确</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">chmod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> 644</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> /data/sslkeylogfile</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:6.16,words:1847},title:"wireshark抓包之如何抓包",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE.html",{loader:()=>a.e(19849).then(a.bind(a,74089)),meta:{author:"Navyum",date:1760541071e3,localizedDate:"2025年10月15日",category:["wireshark","工具"],tag:["wireshark","抓包","icmp"],sticky:!0,excerpt:"<h2>wireshark抓包</h2>\n<h3>wireshark抓包之目标主机不可达 Destination unreachable (3)</h3>\n<hr>\n<h3>背景：</h3>\n<p>最近自己新购买了一台虚拟机，想要搭建一些web服务到这台机器上并通过互联网访问</p>\n<h3>出现问题：</h3>\n<p>机器购买后，添加了nginx对应的web服务，本地测试curl 'localhost' 正常，但是通过互联网的公网IP访问curl 'server-ip'则请求一直Pending直到超时。\n另外该服务器上还有一个不依赖nginx直接暴露8000端口在公网的docker镜像服务，使用curl 'server-ip:8000/route'可以正常访问。</p>",readingTime:{minutes:4.63,words:1390},title:"wireshark抓包之目标主机不可达",icon:"lucide-lab:shark",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/strongbox.html",{loader:()=>a.e(91431).then(a.bind(a,70591)),meta:{date:1754120087e3,excerpt:"<p>Appstore最新可用的破解版:  https://apps.apple.com/us/app/strongbox-non-universal/id1270075435?mt=12</p>\n",readingTime:{minutes:.05,words:15},title:"",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/API%E5%8E%8B%E6%B5%8B%E6%A1%86%E6%9E%B6%E4%B9%8Blocust.html",{loader:()=>a.e(79034).then(a.bind(a,76971)),meta:{author:"Navyum",date:174249246e4,localizedDate:"2025年3月20日",category:["工具","压测"],tag:["压力测试","瓶颈分析","P99X","Locust","性能测试","API测试"],sticky:!0,excerpt:"<h2>概述</h2>\n<p>性能测试是软件开发生命周期中的一个关键阶段，旨在识别潜在的瓶颈，并确保应用程序在预期的用户负载下满足其性能标准。本文详细介绍如何使用Locust进行API压力测试，包括性能测试指标、可视化工具、测试案例和最佳实践。</p>\n<hr>\n<h2>一、性能测试指标</h2>\n<ul>\n<li>响应时间\n<ul>\n<li>❌ 平均响应时间（ART）意义不大</li>\n<li>✅ 最大响应时间（MRT）</li>\n<li>✅ 百分位响应时间：P50、P90、P99</li>\n</ul>\n</li>\n<li>吞吐量\n<ul>\n<li>✅ 请求速率（RPS）</li>\n<li>✅ 网络吞吐量（MB/s）</li>\n<li>❌ 事务速率（TPS）</li>\n</ul>\n</li>\n<li>容量指标\n<ul>\n<li>✅ 最大并发用户数（MCU）</li>\n<li>✅ 系统承载峰值</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:6.04,words:1812},title:"API压测框架-locust",type:"article"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/todo.html",{loader:()=>a.e(33815).then(a.bind(a,88605)),meta:{title:"todo"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%9D%99%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFGDB/python%E8%BF%90%E8%A1%8Cgdb.html",{loader:()=>a.e(94239).then(a.bind(a,74876)),meta:{author:"Navyum",date:1750160309e3,localizedDate:"2025年6月17日",category:["工具","性能分析","GDB"],tag:["性能分析","可视化","GDB","luajit","btrace"],sticky:!0,excerpt:'<h2>GDB（GNU Debugger）</h2>\n<p>GDB是UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。\n可以查看程序在执行过程中的内部</p>\n<p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/" target="_blank" rel="noopener noreferrer">gdb 官方文档</a></p>\n<h3>Python-gdb</h3>\n<hr>\n<p>通过python来运行gdb命令，其本质是利用python语言的灵活性和便利。GDB提供了一套python API，方便用户使用python脚本编写更复杂的GDB脚本\n<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python.html#Python" target="_blank" rel="noopener noreferrer">gdb python api 官方文档</a></p>',readingTime:{minutes:6.04,words:1812},title:"python运行gdb",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/docker.html",{loader:()=>a.e(38862).then(a.bind(a,8727)),meta:{author:"Navyum",date:1750173532e3,localizedDate:"2025年6月17日",category:["容器技术"],tag:["Docker"],sticky:!1,excerpt:'<ul>\n<li>client-server 架构</li>\n<li><code>docker client</code>使用REST API，通过UDS或者network，与<code>dockerd</code>进行通信\n<img src="https://raw.staticdn.net/Navyum/imgbed/main/IMG/a2959a6248c161ea2a84e671c8a5d38d.png" alt="Img" loading="lazy"></li>\n</ul>\n<h2>Docker Registries</h2>\n<ul>\n<li>用来存储Docker Images</li>\n<li>默认使用Docker Hub Registries</li>\n<li>常用的registries：\n<ul>\n<li><a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub</a></li>\n<li><a href="https://aws.amazon.com/ecr/" target="_blank" rel="noopener noreferrer">ECR</a></li>\n<li><a href="https://cloud.google.com/artifact-registry" target="_blank" rel="noopener noreferrer">GCR</a></li>\n<li><a href="https://azure.microsoft.com/en-in/products/container-registry" target="_blank" rel="noopener noreferrer">ACR</a></li>\n<li>自建：Harbor, JFrog Artifactory, GitLab Container registry</li>\n</ul>\n</li>\n<li>相关命令：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> search</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> IMAGE_NAME</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">  //</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> 从registies查找镜像</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> pull</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> DOCKER_USERNAME/IMAGE_NAME</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> //</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> 从registries拉镜像到本地</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> tag</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> YOUR_DOCKER_USERNAME/IMAGE_NAME</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> YOUR_DOCKER_USERNAME/IMAGE_NAME:1.0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> //将本地镜像重命名</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> push</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> YOUR_DOCKER_USERNAME/IMAGE_NAME:1.0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> //</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> 将镜像推送到registries</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:11.84,words:3551},title:"docker",icon:"simple-icons:docker",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/k8s.html",{loader:()=>a.e(63984).then(a.bind(a,65592)),meta:{author:"Navyum",date:1750762918e3,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,readingTime:{minutes:.11,words:32},title:"k8s",icon:"lineicons:kubernetes",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/minikube.html",{loader:()=>a.e(50312).then(a.bind(a,58435)),meta:{author:"Navyum",date:1750173551e3,localizedDate:"2025年6月17日",category:["踩坑笔记","容器技术"],tag:["minikube"],sticky:!1,excerpt:'\n<ul>\n<li><strong>步骤一</strong>：minikube 执行文件下载（linux x86-64为例子）：\n<ul>\n<li>官方地址：(https://minikube.sigs.k8s.io/docs/start/?arch=%2Flinux%2Fx86-64%2Fstable%2Fbinary+download)´</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span></span>\n<span class="line"><span>    sudo install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; rm minikube-linux-amd64</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li><strong>步骤二</strong> minikube 运行：\n<ul>\n<li>官方命令： <code>minikube start</code></li>\n<li>我们需要做如下改动：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>minikube start --vm-driver=docker --base-image="anjone/kicbase" --force --kubernetes-version=1.23.0</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li><strong>问题一</strong>：因为政策等原因，dokcer-hub无法拉取到base镜像\n<ul>\n<li>错误信息（阻塞在镜像下载）：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Pending：   Pulling base image v0.0.44 ...</span></span>\n<span class="line"><span>            &gt; index.docker.io/kicbase/sta...:  0 B</span></span>\n<span class="line"><span>            E0811 15:29:59.503923   16810 cache.go:189] Error downloading kic artifacts:  failed to download kic base image or any fallback image</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>解决方案1：\n<ul>\n<li>使用命令行参数修改镜像源为阿里云</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> minikube start --image-mirror-country=\'cn\' --image-repository=\'registry.cn-hangzhou.aliyuncs.com/google_containers</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><ul>\n<li>测试结果：❌未通过，猜测大部分云厂商的源站失效</li>\n</ul>\n</li>\n<li>解决方案2：\n<ul>\n<li>修改镜像源，并将 base-image <code>anjone/kicbase</code> 拉到本地</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    $ sudo vi /etc/docker/daemon.json</span></span>\n<span class="line"><span>    $ 修改registry-mirrors：</span></span>\n<span class="line"><span>    {</span></span>\n<span class="line"><span>        "registry-mirrors": [</span></span>\n<span class="line"><span>            "https://hub.uuuadc.top",</span></span>\n<span class="line"><span>            "https://dockerpull.com",</span></span>\n<span class="line"><span>            "https://docker.1panel.live"</span></span>\n<span class="line"><span>        ]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    $ sudo systemctl restart docker</span></span>\n<span class="line"><span>    $ docker pull anjone/kicbase</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>\n<li>测试结果：✅ 通过</li>\n<li>源站来源：https://github.com/Navyum/CF-Workers-docker.io\n<ul>\n<li>自己搭建</li>\n<li>使用别人搭建好的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>问题二</strong>：默认会使用最新版kubernetes（测试时为v1.30.0），不支持docker\n<ul>\n<li>错误信息（提示需要使用cri-docker）：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>❌  Exiting due to RT_DOCKER_MISSING_CRI_DOCKER_NONE: sudo systemctl enable cri-docker.socket: Process exited with status 1</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li>解决方案1：\n<ul>\n<li>使用ci-dockerd<a href="https://github.com/Mirantis/cri-dockerd/releases" target="_blank" rel="noopener noreferrer">github地址</a></li>\n<li>测试结果：未测试</li>\n</ul>\n</li>\n<li>解决方案2:\n<ul>\n<li>使用支持docker的低版本kubernetes，例如1.23.0</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> --kubernetes-version=1.23.0</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><ul>\n<li>测试结果：✅ 通过</li>\n</ul>\n</li>\n<li>--vm-driver 参数说明：\n<ul>\n<li>指定为docker，即通过docker运行minikube环境。我是在EC2环境中使用</li>\n</ul>\n</li>\n<li>--force 参数说明：\n<ul>\n<li>使用root运行，不推荐</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>运行成功截图：\n*</li>\n</ul>\n</li>\n<li><strong>步骤三</strong> 检查minikube 运行状态：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ kubectl get nodes</span></span>\n<span class="line"><span>    NAME       STATUS   ROLES                  AGE   VERSION</span></span>\n<span class="line"><span>    minikube   Ready    control-plane,master   16h   v1.23.0</span></span>\n<span class="line"><span>$ minikube status</span></span>\n<span class="line"><span>    minikube</span></span>\n<span class="line"><span>    type: Control Plane</span></span>\n<span class="line"><span>    host: Running</span></span>\n<span class="line"><span>    kubelet: Running</span></span>\n<span class="line"><span>    apiserver: Running</span></span>\n<span class="line"><span>    kubeconfig: Configured</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li><strong>步骤四</strong> 安装kubectl、kubeadm、kubelet：\n<ul>\n<li>解决方案1：\n<ul>\n<li>使用官方地址下载可执行文件：\n<ul>\n<li>本例子使用的kubenetes版本为1.23.0，需要下载对应版本的kubectl</li>\n<li>KUBERNETES_VERSION 替换为你需要的版本，本例子为1.23.0</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ curl -LO https://dl.k8s.io/release/KUBERNETES_VERSION/bin/linux/amd64/kubectl</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li>测试结果：❌ 未通过，速度太慢</li>\n</ul>\n</li>\n<li>解决方案2：\n<ul>\n<li>\n<p>使用yum源下载指定版本（centos）</p>\n<ul>\n<li>添加k8s仓库源</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>cat &lt;&lt; EOF &gt; /etc/yum.repos.d/kubernetes.repo </span></span>\n<span class="line"><span>    [kubernetes]</span></span>\n<span class="line"><span>    name=Kubernetes</span></span>\n<span class="line"><span>    baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span>\n<span class="line"><span>    enabled=1</span></span>\n<span class="line"><span>    gpgcheck=1</span></span>\n<span class="line"><span>    repo_gpgcheck=1</span></span>\n<span class="line"><span>    gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span>\n<span class="line"><span>EOF</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>\n<li>下载1.23.0 版本kubectl</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ yum install -y kubectl-1.23.0</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li>\n<p>测试结果：✅通过</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>步骤四</strong> 创建Deployment：\n<ul>\n<li>官方推荐的yaml，拉取image太慢，使用阿里云的测试即可</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ kubectl create deployment hello-minikube --image=registry.aliyuncs.com/google_containers/echoserver:1.10</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div></li>\n<li><strong>步骤五</strong> expose到外网：\n<ul>\n<li>如果使用的是阿里云、腾讯云主机，需要在控制台开启对应端口号，否则可能无法访问，本例子需要手动开启Port 8080</li>\n<li>expose 到8080端口</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ kubectl expose deployment hello-minikube --type=NodePort --port=8080</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div><ul>\n<li>查看服务：</li>\n</ul>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ kubectl get pod -o wide</span></span>\n<span class="line"><span>    NAME                              READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span></span>\n<span class="line"><span>    hello-minikube-6899fcbcf5-qdb2p   1/1     Running   0          2m28s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>$ kubectl get svc -o wide</span></span>\n<span class="line"><span>    NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE     SELECTOR</span></span>\n<span class="line"><span>    hello-minikube   NodePort    10.109.145.31   &lt;none&gt;        8080:32484/TCP   100s    app=hello-minikube</span></span>\n<span class="line"><span>    kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          2m38s   &lt;none&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:2.63,words:790},title:"minikube",icon:"lineicons:kubernetes",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/QA.html",{loader:()=>a.e(73714).then(a.bind(a,54034)),meta:{date:1749983452e3,excerpt:"\n<p>★★☆ 手写 SQL 语句，特别是连接查询与分组查询。</p>\n<p>★★☆ 连接查询与子查询的比较。</p>\n<p>★★☆ drop、delete、truncate 比较。</p>\n<p>★★☆ 视图的作用，以及何时能更新视图。</p>\n<p>★☆☆ 理解存储过程、触发器等作用。</p>\n<h2>系统原理</h2>\n<p>★★★ ACID 的作用以及实现原理。</p>\n<p>★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。</p>\n<p>★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。</p>\n<p>★★★ 乐观锁与悲观锁。</p>\n<p>★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。</p>",readingTime:{minutes:.91,words:272},title:"QA",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8.html",{loader:()=>a.e(645).then(a.bind(a,55558)),meta:{author:"Navyum",date:1750173285e3,localizedDate:"2025年6月17日",category:["常用软件","消息队列"],tag:["消息队列"],sticky:!1,excerpt:"<h3>系统解耦：</h3>\n<ul>\n<li>系统内的多个组件可以通过消息系统进行解耦</li>\n</ul>\n<h3>异步处理：</h3>\n<ul>\n<li>发送方可以立即继续执行，而不必等待接收方处理完成</li>\n</ul>\n<h3>负载均衡：</h3>\n<ul>\n<li>通过分发机制实现消费者的负载均衡</li>\n</ul>\n<h3>可靠性：</h3>\n<ul>\n<li>比进程内存模型的数组、链表更可靠</li>\n<li>可以实现持久化，避免消息丢失</li>\n<li>通过多副本方式避免单机故障</li>\n<li>通过协调机制确保服务不停机</li>\n</ul>\n<h3>流量控制：</h3>",readingTime:{minutes:.98,words:294},title:"消息队列的作用",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BA%B2.html",{loader:()=>a.e(76806).then(a.bind(a,6406)),meta:{author:"Navyum",date:1750170982e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:'<h2>关键技术点：</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9c7f9a9c5fefa9e7b316d71adb535ae0.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<h2>如何提高性能：</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f48aad6a9dc4e2f59cb9dea2b634cfc9.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',readingTime:{minutes:.21,words:64},title:"01.分布式设计总纲",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.html",{loader:()=>a.e(46848).then(a.bind(a,81019)),meta:{author:"Navyum",date:1750171093e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:'<h3>SOA：基于服务的架构思想</h3>\n<ul>\n<li>开发、维护和使用 SOA 要遵循以下几条基本原则：\n（ 可重用，粒度合适，模块化，可组合，构件化以及有互操作性。</li>\n<li>符合开放标准（通用的或行业的）。服务的识别和分类，提供和发布，监控和跟踪。\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1dd7e13a1931da98bd451312dc51b594.png" alt="图片" loading="lazy"></li>\n</ul>\n<h3>使用分布式系统主要有两方面原因:</h3>\n<h4>增大系统容量</h4>',readingTime:{minutes:1.65,words:496},title:"02.分布式系统概念",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA.html",{loader:()=>a.e(89838).then(a.bind(a,54363)),meta:{author:"Navyum",date:1750171105e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","基础理论","CAP定理","ACID","BASE"],sticky:!1,excerpt:"<h2>CAP定理：（主要应用于分布式系统）</h2>\n<h3>定义：</h3>\n<ul>\n<li>C <code>一致性</code>（Consistency）：每次读取要么获得最近写入的数据，要么获得一个错误</li>\n<li>A <code>可用性</code>（Availability）：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据</li>\n<li>P <code>分区容忍</code>（Partition tolerance）：在网络分区的情况下，系统仍继续运行。即使存在网络延迟等分区带来的问题。</li>\n</ul>\n<h3>CAP的目标和核心：</h3>\n",readingTime:{minutes:3.91,words:1172},title:"03.分布式基础理论",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/04.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html",{loader:()=>a.e(74869).then(a.bind(a,12908)),meta:{author:"Navyum",date:1750171144e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","分布式事务"],sticky:!0,excerpt:"<h2>分布式事务相关算法：</h2>\n<h3>角色：</h3>\n<ul>\n<li>协调者</li>\n<li>参与者</li>\n</ul>\n<h3>XA模式、AT模式：</h3>\n<ul>\n<li>XA模式：2PC，使用回滚</li>\n<li>AT模式：TCC，利用补偿</li>\n</ul>\n<h3>2PC ：</h3>\n<ul>\n<li><code>准备阶段</code>：\n<ul>\n<li><code>协调者</code>向<code>所有参与者</code>发送准备请求，参与者执行<code>预操作</code>并记录日志，<code>但不提交</code>，进入<code>准备阶段</code>。</li>\n</ul>\n</li>\n<li><code>提交阶段</code>：\n<ul>\n<li>如果<code>所有参与者</code>都<code>准备就绪</code>，协调者发送提交请求，参与者提交操作；</li>\n<li>否则，<code>协调者</code>发送<code>回滚请求</code>，参与者回滚操作。</li>\n</ul>\n</li>\n<li>存在的问题：\n<ul>\n<li>协调者单点故障问题</li>\n<li>参与者等待指令期间阻塞</li>\n<li>延迟问题</li>\n</ul>\n</li>\n<li>适用场景：\n<ul>\n<li>在某些需要强一致性的分布式事务管理系统</li>\n<li>MySQL、ZooKeeper</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:2.95,words:886},title:"04.分布式事务",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/05.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(13105).then(a.bind(a,11490)),meta:{author:"Navyum",date:1750171156e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","一致性算法"],sticky:!0,excerpt:"\n<h2>分布式一致性：</h2>\n<h3>定义：</h3>\n<ul>\n<li>分布式一致性是指在分布式系统中，确保所有节点对数据的视图是一致的，即所有节点在某个时间点上看到的数据状态是一致的。</li>\n<li>分布式系统的核心目标：确保所有节点的数据和状态一致</li>\n</ul>\n<h3>强一致性：</h3>\n<ul>\n<li>所有读操作都能看到最新的写操作结果</li>\n<li>强一致性模型：\n<ul>\n<li>线性一致性</li>\n<li>顺序一致性</li>\n</ul>\n</li>\n</ul>\n<h3>弱一致性：</h3>\n<ul>\n<li>读操作可能不会立即看到最新的写操作结果</li>\n<li>弱一致性模型：\n<ul>\n<li>最终一致性</li>\n<li>会话一致性</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:6.29,words:1888},title:"05.分布式一致性算法",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/06.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E5%8F%AF%E4%BF%A1.html",{loader:()=>a.e(88722).then(a.bind(a,28558)),meta:{author:"Navyum",date:1750171165e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","共识算法"],sticky:!0,excerpt:"<h2>基本概念：</h2>\n<ul>\n<li>容错：代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常）</li>\n<li>共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒）</li>\n</ul>\n<h2>Paxos：</h2>\n<h3>角色：</h3>\n<ul>\n<li>提议者（proposer）：<code>提出提案</code>的节点</li>\n<li>接收者（acceptor）：<code>接受并投票</code>提案的节点</li>\n<li>学习者（learner）：接收来自接受者的Accept通知，了解<code>最终被接受的提案</code></li>\n</ul>",readingTime:{minutes:10.49,words:3146},title:"06.分布式共识算法-可信",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/07.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E9%9D%9E%E5%8F%AF%E4%BF%A1.html",{loader:()=>a.e(38484).then(a.bind(a,92676)),meta:{author:"Navyum",date:1750171193e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","共识算法"],sticky:!1,excerpt:"\n<h2>基本概念：</h2>\n<ul>\n<li>拜占庭问题：</li>\n</ul>\n<h1>PBFT：</h1>\n<p>https://freegeektime.com/100046101/209450/</p>\n<h2>具体应用场景：</h2>\n<h2>角色：</h2>\n<h2>核心思想：</h2>\n<h2>达成共识过程：</h2>\n<h1>POW：工作量证明</h1>\n<p>https://freegeektime.com/100046101/210887/</p>\n<h2>具体应用场景：区块链</h2>\n<h1>角色：</h1>\n<h1>核心思想：</h1>\n<h1>达成共识过程：</h1>",readingTime:{minutes:.55,words:164},title:"07.分布式共识算法-非可信",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/08.%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.html",{loader:()=>a.e(56481).then(a.bind(a,88684)),meta:{author:"Navyum",date:1750171206e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","分布式通信"],sticky:!1,excerpt:"<h2>汇总：</h2>\n<table>\n<thead>\n<tr>\n<th>协议名称</th>\n<th>定义</th>\n<th>特性</th>\n<th>应用场景</th>\n<th>常见实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RPC</td>\n<td>允许程序调用远程服务器上的函数或过程，就像调用本地函数一样</td>\n<td>- 透明性<br>- 同步调用</td>\n<td>- 微服务架构中的服务间通信<br>- 分布式系统中的远程函数调用</td>\n<td>- gRPC<br>- Thrift</td>\n</tr>\n<tr>\n<td>REST</td>\n<td>基于HTTP协议的分布式系统通信风格，使用标准的HTTP方法进行操作</td>\n<td>- 资源导向<br>- 无状态</td>\n<td>- Web服务和API<br>- 微服务架构中的服务间通信</td>\n<td>- Spring Boot<br>- Express.js</td>\n</tr>\n<tr>\n<td>WebSockets</td>\n<td>全双工通信协议，允许客户端和服务器之间建立持久连接，实现实时双向通信</td>\n<td>- 全双工通信<br>- 低延迟</td>\n<td>- 实时聊天应用<br>- 实时数据推送（如股票行情、在线游戏）</td>\n<td>- Socket.IO<br>- SignalR</td>\n</tr>\n<tr>\n<td>MQTT</td>\n<td>轻量级的发布/订阅消息传递协议，设计用于低带宽、高延迟或不可靠网络环境</td>\n<td>- 轻量级<br>- 发布/订阅模式</td>\n<td>- 物联网（IoT）设备通信<br>- 移动消息推送</td>\n<td>- Eclipse Mosquitto<br>- HiveMQ</td>\n</tr>\n<tr>\n<td>Gossip</td>\n<td><code>去中心化的通信协议</code>，用于在分布式系统中的各个节点之间传播信息和状态</td>\n<td>- 去中心化<br>- 容错性高<br>- 渐进一致性<br>- 简单和高效</td>\n<td>- 分布式数据库（如Cassandra、Riak）<br>- 分布式文件系统（如Amazon Dynamo）<br>- 分布式协调服务（如Consul）<br>- 分布式监控系统（如Prometheus）</td>\n<td>- Cassandra<br>- Riak<br>- Amazon Dynamo<br>- Consul<br>- Prometheus</td>\n</tr>\n<tr>\n<td>AMQP</td>\n<td>高级消息队列协议，支持消息的发布/订阅、点对点和事务性消息传递</td>\n<td>- 可靠性（支持消息确认、持久化和事务）<br>- 灵活性（支持多种消息传递模式）</td>\n<td>- 企业级消息传递系统<br>- 分布式系统中的消息队列</td>\n<td>- RabbitMQ<br>- Apache Qpid</td>\n</tr>\n</tbody>\n</table>",readingTime:{minutes:1.68,words:503},title:"08.分布式通信协议",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html",{loader:()=>a.e(12019).then(a.bind(a,57776)),meta:{author:"Navyum",date:1750171224e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","高性能设计"],sticky:!0,excerpt:"<h2>零拷贝技术：</h2>\n<ul>\n<li>避免从内核态到用户态的数据拷贝</li>\n</ul>\n<h2>多路复用技术：</h2>\n<ul>\n<li>避免阻进程/线程阻塞在io上，而是等内核在io准备好(同步)或者io已完成(异步)时通知进程/线程。这样的好处：将进程/线程切换权限交给操作系统，可以让出CPU执行其他事情。</li>\n</ul>\n<h2>写时复制（copy on write）：</h2>\n<h2>线程池技术：</h2>\n<ul>\n<li>因为线程并不会一直占用CPU，所以为了避免线程无限创建和销毁的开销，预先创建一批线程（CPU * 2）。</li>\n</ul>\n<h2>无锁编程技术（lock-free）：</h2>",readingTime:{minutes:2.06,words:619},title:"09.*高性能核心技术",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/10._%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",{loader:()=>a.e(20631).then(a.bind(a,49332)),meta:{author:"Navyum",date:1750171246e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:"<h2>0）基础概念：</h2>\n<h4>系统与子系统：</h4>\n<ul>\n<li>\n<p>关联：一群有关联的个体</p>\n</li>\n<li>\n<p>规则：个体之间按照规则运作</p>\n</li>\n<li>\n<p>能力：系统能力超越个体能力</p>\n</li>\n<li>\n<p>分层：自顶向下逐层分解</p>\n</li>\n<li>\n<p>子系统的定义和系统定义是一样的，只是观察的角度有差异。一个系统可能是另外一个更大系统的子系统。</p>\n</li>\n<li>\n<p>举例：微信系统和微信的支付系统</p>\n</li>\n<li>\n<p>顶层的理解(L0~L4)：一个系统的架构，只包括顶层这一个层级的架构，而不包括下属子系统层级的架构。所以微信架构，就是指微信系统这个层级的架构。当然，微信的子系统，比如支付系统，也有它自己的架构，同样只包括顶层。</p>\n</li>\n</ul>",readingTime:{minutes:8.49,words:2548},title:"10.*如何做架构设计",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/11.%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF.html",{loader:()=>a.e(58226).then(a.bind(a,43074)),meta:{author:"Navyum",date:175017145e4,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","序列化"],sticky:!1,excerpt:"<table>\n<thead>\n<tr>\n<th>序列化技术</th>\n<th>定义</th>\n<th>特性</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n<th>常见应用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Protobuf</td>\n<td>Google 开发的语言中立、平台中立的序列化格式</td>\n<td>- 紧凑性<br>- 高性能<br>- 强类型</td>\n<td>- 紧凑的二进制格式<br>- 高效传输和存储<br>- 支持多种语言</td>\n<td>- 需要编译 proto 文件<br>- 不易读</td>\n<td>- 高效数据传输<br>- 分布式系统</td>\n<td>- gRPC<br>- 分布式数据库</td>\n</tr>\n<tr>\n<td>JSON</td>\n<td>JavaScript 对象表示法</td>\n<td>- 可读性<br>- 灵活性<br>- 广泛支持</td>\n<td>- 可读性强<br>- 易于调试和测试<br>- 广泛支持</td>\n<td>- 文本格式较大<br>- 性能较低</td>\n<td>- Web 服务<br>- 配置文件</td>\n<td>- RESTful API<br>- 配置管理</td>\n</tr>\n<tr>\n<td>XML</td>\n<td>可扩展标记语言</td>\n<td>- 可读性<br>- 灵活性<br>- 自描述性</td>\n<td>- 可读性强<br>- 自描述性<br>- 广泛支持</td>\n<td>- 文本格式较大<br>- 性能较低<br>- 解析复杂</td>\n<td>- 配置文件<br>- 文档交换</td>\n<td>- SOAP<br>- 配置管理</td>\n</tr>\n<tr>\n<td>MessagePack</td>\n<td>高效的二进制序列化格式</td>\n<td>- 紧凑性<br>- 高性能<br>- 灵活性</td>\n<td>- 紧凑的二进制格式<br>- 高效传输和存储<br>- 易于使用</td>\n<td>- 不如 JSON 可读</td>\n<td>- 高效数据传输<br>- 移动应用</td>\n<td>- Redis<br>- ZeroMQ</td>\n</tr>\n<tr>\n<td>Thrift</td>\n<td>Apache 开发的跨语言序列化和 RPC 框架</td>\n<td>- 高性能<br>- 支持多种语言<br>- RPC 支持</td>\n<td>- 高效传输和存储<br>- 跨语言支持<br>- 内置 RPC 支持</td>\n<td>- 需要编译 IDL 文件<br>- 不易读</td>\n<td>- 分布式系统<br>- 多语言通信</td>\n<td>- Facebook<br>- Twitter</td>\n</tr>\n<tr>\n<td>Kryo</td>\n<td>Java 的高性能序列化库</td>\n<td>- 高性能<br>- 紧凑性<br>- 易用性</td>\n<td>- 高效传输和存储<br>- 支持复杂对象<br>- 易于使用</td>\n<td>- 主要支持 Java<br>- 需要注册类</td>\n<td>- Java 应用<br>- 分布式计算</td>\n<td>- Apache Spark<br>- Akka</td>\n</tr>\n<tr>\n<td>Apache Avro</td>\n<td>Apache Hadoop 的数据序列化系统</td>\n<td>- 紧凑性<br>- 动态模式<br>- JSON 格式模式</td>\n<td>- 紧凑的二进制格式<br>- 动态模式支持<br>- 与 Hadoop 生态系统集成</td>\n<td>- 需要模式文件<br>- 不易读</td>\n<td>- 大数据处理<br>- 数据存储</td>\n<td>- Hadoop<br>- Kafka</td>\n</tr>\n</tbody>\n</table>",readingTime:{minutes:1.81,words:543},title:"11.序列化技术",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/12.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B.html",{loader:()=>a.e(94227).then(a.bind(a,61580)),meta:{author:"Navyum",date:1750171469e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","分布式故障模型"],sticky:!1,excerpt:'<h2>模型：</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/16baf817c09d527137f3568b6ab565a9.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<ul>\n<li>\n<p>Crash-stop Failures：</p>\n<ul>\n<li>一旦发生故障，节点就停止提供服务，并且不会恢复。</li>\n<li>这种故障模型中的节点都按照正确的逻辑运行，可能宕机，可能网络中断，可能延迟增加，但<code>结果总是正确</code>的；</li>\n</ul>\n</li>\n<li>\n<p>Crash-recovery Failures：</p>\n<ul>\n<li>相对于crash-stop failures，这种故障模型允许节点在故障发生后恢复，恢复时可能需要一些持久化的数据恢复状态（Omission Failures）；</li>\n<li>常见容错算法：Paxos、Raft</li>\n</ul>\n</li>\n<li>\n<p>Byzantine Failures：</p>\n<ul>\n<li>这种故障模型需要处理拜占庭问题，因此也是最难应对的，存在可信问题</li>\n<li>不仅仅节点宕机或网络故障会发生，节点还有可能返回随机或恶意的结果，甚至有可能影响其他节点的正常运行</li>\n<li>常见容错算法：PBFT（Practical Byzantine Fault Tolerance）、POW（工作量证明Proof-of-Work，区块链）</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:.92,words:275},title:"12.分布式故障模型",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/13.%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(23624).then(a.bind(a,59018)),meta:{author:"Navyum",date:1750171493e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计","唯一ID"],sticky:!1,excerpt:"<h3>自增ID：</h3>\n<ul>\n<li>具体实现：\n<ul>\n<li>mysql 自增ID</li>\n<li>redis incr</li>\n</ul>\n</li>\n</ul>\n<h3>UUID：</h3>\n<h3>snow flake雪花算法：</h3>\n<h3>Leaf算法：</h3>\n",readingTime:{minutes:.22,words:66},title:"13.分布式唯一ID生成算法",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99.html",{loader:()=>a.e(53226).then(a.bind(a,87245)),meta:{author:"Navyum",date:1750171507e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:"<h2>合适原则</h2>\n<p><strong>合适原则宣言：“合适优于业界领先”</strong></p>\n<h2>简单原则</h2>\n<p><strong>简单原则宣言：“简单优于复杂”</strong></p>\n<h2>演化原则</h2>\n<p><strong>演化原则宣言：“演化优于一步到位”</strong></p>\n",readingTime:{minutes:.3,words:89},title:"架构设计-三个原则",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84.html",{loader:()=>a.e(57224).then(a.bind(a,45534)),meta:{author:"Navyum",date:1750171521e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:"<h2>分层架构：</h2>\n<p>也叫N层架构，例如C/S架构、B/S架构。常见的是3层架构（例如，MVC、MVP架构）、4层架构，5层架构的比较少见，一般是比较复杂的系统才会达到或者超过5层，比如操作系统内核架构。</p>\n<p><strong>SOA:</strong></p>\n<h2>分布式协调服务</h2>\n<p>能在分布式环境下，让多个实例同时获取到同一份信息的服务，就是所谓的分布式协调服务</p>\n",readingTime:{minutes:.53,words:159},title:"架构设计-可扩展架构",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1.html",{loader:()=>a.e(79223).then(a.bind(a,9227)),meta:{author:"Navyum",date:1750171532e3,localizedDate:"2025年6月17日",category:["分布式"],tag:["架构设计"],sticky:!1,excerpt:"<p>应用场景：\n分布式锁、配置中心、服务发现与注册</p>\n<p>zookeeper\netcd\nconsul\nnacos</p>\n",readingTime:{minutes:.2,words:61},title:"分布式协调服务",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/dubbo.html",{loader:()=>a.e(54077).then(a.bind(a,10388)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"dubbo",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/flask.html",{loader:()=>a.e(30070).then(a.bind(a,29790)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"flask",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/gin.html",{loader:()=>a.e(55827).then(a.bind(a,91584)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"gin",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/netty.html",{loader:()=>a.e(42229).then(a.bind(a,55864)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"netty",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/openresty.html",{loader:()=>a.e(21744).then(a.bind(a,88373)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"openresty",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/springboot.html",{loader:()=>a.e(6888).then(a.bind(a,43223)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"springboot",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/05.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%91%E5%8E%9F%E7%94%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F.html",{loader:()=>a.e(54469).then(a.bind(a,4289)),meta:{author:"Navyum",date:175017158e4,localizedDate:"2025年6月17日",category:["微服务"],tag:["架构设计"],sticky:!1,excerpt:"<h3>云原生概括为4个要点：</h3>\n<ul>\n<li>DevOps</li>\n<li>持续交付（CI/CD）</li>\n<li>微服务（Micro service）</li>\n<li>容器（Docker、K8s）</li>\n</ul>\n",readingTime:{minutes:.2,words:60},title:"微服务、云原生",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/00.%E5%AE%9A%E4%B9%89.html",{loader:()=>a.e(85937).then(a.bind(a,69643)),meta:{author:"Navyum",date:1750172137e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["基础定义"],sticky:!1,excerpt:"<h2>定义</h2>\n<h3>算法（algorithm）</h3>\n<ul>\n<li>是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性：\n<ul>\n<li>问题是明确的，包含清晰的输入和输出定义。</li>\n<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>\n<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>\n</ul>\n</li>\n</ul>\n<h3>数据结构（data structure）</h3>\n<ul>\n<li>是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标：\n<ul>\n<li>空间占用尽量少，以节省计算机内存。</li>\n<li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li>\n<li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:4.22,words:1267},title:"00.定义",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/CSP%E3%80%81channel.html",{loader:()=>a.e(71056).then(a.bind(a,25739)),meta:{author:"Navyum",date:1750677612e3,localizedDate:"2025年6月23日",category:["golang"],tag:["golang"],sticky:!1,readingTime:{minutes:.09,words:26},title:"CSP、channel",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/Error.html",{loader:()=>a.e(93590).then(a.bind(a,44293)),meta:{title:"Error",index:!1}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/array%E3%80%81slice.html",{loader:()=>a.e(85662).then(a.bind(a,40624)),meta:{author:"navyum",date:1750544594e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:'<ol>\n<li>数组和切片的区别和联系：\n<ol>\n<li>slice 的底层数据是数组，slice 是对数组的封装</li>\n<li>数组是定长的，长度定义好之后，不能再更改;而切片则非常灵活，它可以动态地扩容</li>\n<li>数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组</li>\n</ol>\n</li>\n<li>slice结构体：</li>\n</ol>\n<div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// runtime/slice.go</span></span>\n<span class="line"><span>type slice struct {</span></span>\n<span class="line"><span>\tarray unsafe.Pointer // 元素指针</span></span>\n<span class="line"><span>\tlen   int // 长度 </span></span>\n<span class="line"><span>\tcap   int // 容量，容量大小一般指从切片的开始位置到底层数据的结尾位置的长度</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:1.93,words:579},title:"array、slice",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/gc.html",{loader:()=>a.e(49892).then(a.bind(a,80169)),meta:{author:"navyum",date:1750544631e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:'<p><a href="https://segmentfault.com/a/1190000022030353" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000022030353</a></p>\n<ol>\n<li>常见GC方式\n<ol>\n<li>引用计数</li>\n<li>标记清除</li>\n</ol>\n</li>\n<li>三色标记清除过程、阶段和触发时机：</li>\n<li>内存屏障</li>\n<li>STW</li>\n<li>强、弱清除</li>\n<li>发生内存逃逸如何清除</li>\n</ol>',readingTime:{minutes:.29,words:86},title:"gc",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",{loader:()=>a.e(74382).then(a.bind(a,80461)),meta:{author:"navyum",date:175054465e4,localizedDate:"2025年6月21日",category:["笔记","踩坑笔记"],tag:["笔记"],sticky:!1,excerpt:'<h3>omitempty踩坑</h3>\n<ul>\n<li>场景：json、struct转换</li>\n<li>描述：在http response结构体中不要随意使用</li>\n<li>陷阱：\n<ul>\n<li>无法忽略掉嵌套结构体</li>\n<li>给它赋的值恰好等于默认空值,会被忽略</li>\n</ul>\n</li>\n<li>补充：因为go的变量有默认值，int为0，会导致业务定义的正常值0不返回</li>\n<li>举例：</li>\n</ul>\n<div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> PdfResponse</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Ret</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  uint8</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">    `json:"ret,omitempty"`</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Data</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD"> *</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">RetData</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> `json:"data,omitempty"`</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Msg</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  string</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">   `json:"msg"`</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    resp</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B"> :=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD"> &amp;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">PdfResponse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">{</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Ret</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66">0</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">️</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">,</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Msg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"success"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">,</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">        Data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">: </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD">&amp;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">RetData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">{},</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">    c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">JSON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">http</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">StatusOK</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">resp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    //result:</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic">    //{"data":null,"msg":"success"}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:18.62,words:5587},title:"golang学习笔记",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/goroutine.html",{loader:()=>a.e(13826).then(a.bind(a,64061)),meta:{author:"navyum",date:1750544677e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>G、P、M</p>\n<p>Goroutine                                                       Machine</p>\n<p>Goroutine                     Processor                         Machine</p>\n<p>Goroutine                                                       Machine</p>\n<p>Goroutine                                                       Machine</p>",readingTime:{minutes:.69,words:207},title:"goroutine",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/gpm.html",{loader:()=>a.e(77318).then(a.bind(a,17892)),meta:{title:"gpm",index:!1}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface.html",{loader:()=>a.e(87139).then(a.bind(a,11014)),meta:{author:"navyum",date:1750544693e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<ol>\n<li>\n<p>接口的作用：</p>\n<ol>\n<li>隐藏细节：通过接口可以对对象进行必要的抽象</li>\n<li>解耦：      通过接口，我们能够以模块化的方式构建起复杂、庞大的系统</li>\n<li>权限控制：通过接口来控制接入方式和接入方的行为，降低安全风险</li>\n</ol>\n</li>\n<li>\n<p>使用接口的成本：\na. 内存逃逸：接口的动态数据类型对应的数据大小难以预料，所以接口中使用指针来存储数据。为了方便数据被寻址，平时分配在栈中的值一旦赋值给接口后，Go 运行时会在堆区为接口开辟内存（内存逃逸意味着堆内存分配时的时间消耗）</p>\n</li>\n</ol>",readingTime:{minutes:7.16,words:2147},title:"interface",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface%E5%92%8Cstruct%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",{loader:()=>a.e(65448).then(a.bind(a,76978)),meta:{author:"navyum",date:1750544704e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>在 Go 中，interface 和 struct 都是非常重要的类型，但它们的使用场景有所不同。</p>\n<p>使用 interface 的场景：</p>\n<ol>\n<li>\n<p>抽象类型：当我们需要定义一个抽象类型时，可以使用 interface。抽象类型是指只定义了方法集合，但没有具体实现的类型。</p>\n</li>\n<li>\n<p>多态：当我们需要实现多态时，可以使用 interface。多态是指同一种类型的对象，在不同的情况下表现出不同的行为。</p>\n</li>\n<li>\n<p>解耦：当我们需要解耦时，可以使用 interface。解耦是指将两个或多个模块之间的耦合度降低，从而提高代码的复用性和可维护性。</p>\n</li>\n<li>\n<p>主要用来约束协议和实现多态\n使用 struct 的场景：</p>\n</li>\n<li>\n<p>封装数据：当我们需要封装数据时，可以使用 struct。封装数据是指将数据和相关的操作封装在一起，从而提高代码的可读性和可维护性。</p>\n</li>\n<li>\n<p>定义数据结构：当我们需要定义一种数据结构时，可以使用 struct。数据结构是指一种数据的组织方式，可以用来表示实际问题中的对象。</p>\n</li>\n<li>\n<p>定义对象：当我们需要定义一种对象时，可以使用 struct。对象是指一种具有状态和行为的实体，可以用来表示实际问题中的对象。</p>\n</li>\n</ol>",readingTime:{minutes:2.38,words:715},title:"interface和struct的使用场景",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/map.html",{loader:()=>a.e(2046).then(a.bind(a,68634)),meta:{author:"navyum",date:1750544718e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:'<ol>\n<li>map的结构体：</li>\n</ol>\n<div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// A header for a Go map.</span></span>\n<span class="line"><span>type hmap struct {</span></span>\n<span class="line"><span>    // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span></span>\n<span class="line"><span>    // Make sure this stays in sync with the compiler\'s definition.</span></span>\n<span class="line"><span>    count     int // # live cells == size of map.  Must be first (used by len() builtin)</span></span>\n<span class="line"><span>    flags     uint8</span></span>\n<span class="line"><span>    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span>\n<span class="line"><span>    noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span></span>\n<span class="line"><span>    hash0     uint32 // hash seed,哈希函数</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span></span>\n<span class="line"><span>    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span></span>\n<span class="line"><span>    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    extra *mapextra // optional fields</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:3.1,words:930},title:"map",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/options%E5%87%BD%E6%95%B0%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F.html",{loader:()=>a.e(31897).then(a.bind(a,46312)),meta:{author:"navyum",date:1750544729e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<ol>\n<li>作用：解决多参数配置问题</li>\n<li>优点：\n<ol>\n<li>API 具有可扩展性，高度可配置化，新增参数不会破坏现有代码；</li>\n<li>参数列表非常简洁，并且可以使用默认的参数；</li>\n<li>option 函数使参数的含义非常清晰，易于开发者理解和使用；</li>\n<li>如果将 options 结构中的参数设置为小写，还可以限制这些参数的权限，防止这些参数在 package 外部使用。</li>\n</ol>\n</li>\n<li>具体实施：\n<ol>\n<li>我们要对 schedule 结构进行改造，把可以配置的参数放入到options 结构中。定义options 支持的配置的功能模块。</li>\n</ol>\n</li>\n</ol>",readingTime:{minutes:1.27,words:382},title:"options函数选项模式",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/panic%E3%80%81recover%E3%80%81defer.html",{loader:()=>a.e(40103).then(a.bind(a,20872)),meta:{author:"navyum",date:1750544745e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<h2>panic从引发到终止的过程：</h2>\n<p>某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻的停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。这里的最外层函数指的是go函数，对于主 goroutine 来说就是main函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。</p>",readingTime:{minutes:1.16,words:347},title:"panic、recover、defer",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/select.html",{loader:()=>a.e(32606).then(a.bind(a,91837)),meta:{author:"navyum",date:1750544761e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<ul>\n<li>对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。</li>\n<li>select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。</li>\n<li>对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。</li>\n<li>仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。</li>\n<li>如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使select语句是在被唤醒时发现的这种情况，也会这样做。</li>\n<li>一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。</li>\n<li>select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了。</li>\n</ul>",readingTime:{minutes:2.71,words:814},title:"select",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",{loader:()=>a.e(58926).then(a.bind(a,42608)),meta:{title:"数据类型"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%B3%9B%E5%9E%8B.html",{loader:()=>a.e(25104).then(a.bind(a,5686)),meta:{title:"泛型",index:!1}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80.html",{loader:()=>a.e(23505).then(a.bind(a,36478)),meta:{title:"类型转换和断言"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/",{loader:()=>a.e(63146).then(a.bind(a,90632)),meta:{author:"Navyum",date:1750761526e3,localizedDate:"2025年6月24日",category:["java"],tag:["java"],sticky:!1,readingTime:{minutes:.08,words:25},title:"JAVA",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/",{loader:()=>a.e(28004).then(a.bind(a,31226)),meta:{date:1749983452e3,excerpt:"\n<p>TODO</p>\n",readingTime:{minutes:.01,words:2},title:"Lua",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/",{loader:()=>a.e(552).then(a.bind(a,82510)),meta:{date:1749983452e3,excerpt:"\n<p>TODO</p>\n",readingTime:{minutes:.01,words:2},title:"Python",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/chubby/",{loader:()=>a.e(49679).then(a.bind(a,96048)),meta:{author:"Navyum",date:175076283e4,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:"<p>TODO</p>\n",readingTime:{minutes:.1,words:30},title:"chubby",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/consul/",{loader:()=>a.e(55358).then(a.bind(a,14493)),meta:{author:"Navyum",date:1750762838e3,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:"<p>TODO</p>\n",readingTime:{minutes:.1,words:30},title:"consul",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/etcd/",{loader:()=>a.e(72172).then(a.bind(a,61217)),meta:{author:"Navyum",date:1750762846e3,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:"<p>TODO</p>\n",readingTime:{minutes:.1,words:30},title:"etcd",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/nacos/",{loader:()=>a.e(91034).then(a.bind(a,86706)),meta:{author:"Navyum",date:1750762853e3,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:"<p>TODO</p>\n",readingTime:{minutes:.1,words:30},title:"nacos",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/zookeeper/%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(72971).then(a.bind(a,64444)),meta:{author:"Navyum",date:1750762859e3,localizedDate:"2025年6月24日",category:["分布式"],tag:["分布式"],sticky:!1,excerpt:"<h3>原理</h3>\n",readingTime:{minutes:.1,words:31},title:"zoookeeper",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse/%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(14558).then(a.bind(a,2138)),meta:{author:"Navyum",date:1750763023e3,localizedDate:"2025年6月24日",category:["数据库"],tag:["数据库"],sticky:!1,excerpt:'<h3>架构：</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1ee76fe0b74975c9777ee5ca9b6c462e.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n',readingTime:{minutes:.13,words:39},title:"原理",icon:"simple-icons:clickhouse",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticSearch/%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(57305).then(a.bind(a,41161)),meta:{author:"Navyum",date:1750173412e3,localizedDate:"2025年6月17日",category:["数据库","全文搜索"],tag:["ES"],sticky:!1,excerpt:'<ul>\n<li>基于 lucence 引擎</li>\n<li>通过关键词进行信息检索，搜索场景</li>\n</ul>\n<h3>基础：</h3>\n<h4>倒排索引：</h4>\n<ul>\n<li>什么是倒排索引：\n<ul>\n<li>一个用于搜索的数据结构</li>\n</ul>\n</li>\n<li>倒排索引的核心概念：\n<ul>\n<li>\n<p>词项 term：</p>\n<ul>\n<li>将文本进行分词（LLM里面叫token化）后得到词项，词项就是一堆</li>\n</ul>\n</li>\n<li>\n<p>词项字典 Term Dictionary：</p>\n<ul>\n<li>将词项进行排序后得到词项字典，词项数量庞大时，可以通过二分法快速查询（此处可类比mysql的Page Dictionary作用也相似）</li>\n<li>词项字典存在磁盘中，数据大</li>\n<li>实际访问时先通过内存中的Term index，找到前缀匹配的词项位置，然后通过少量查找，定位到词项</li>\n</ul>\n</li>\n<li>\n<p>Posting List：</p>\n<ul>\n<li>作用：记录每个词项对应的文本ID的集合和其他信息</li>\n<li>Posting List包含：文本ID的集合、词项在每个文本内的offset、词频\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c151134facc7b3f4784d776dd075895e.png" width="60%"></li>\n</ul>\n</li>\n<li>\n<p>Term Index：</p>\n<ul>\n<li>作用：通过内存加速搜索</li>\n<li>结构：基于词项前缀生成的一个精简的树结构（可对比参考跳表、b+树）</li>\n<li>特点：词项索引存放在内存中，数据小，可以方便的快速查询</li>\n<li>查询：先通过词项索引，找到词项在词项字典的大概位置，然后到词项字典中再查找</li>\n<li>具体实现 FST 有限状态机：（可对比Tire树）\n<ul>\n<li>FST的特点：（本质是有向图结构）\n<ul>\n<li>压缩性：FST通过共享公共前缀和后缀，大大减少了存储空间</li>\n<li>高效查找：FST允许在子线性时间内查找词项，非常适合用于大规模的文本搜索</li>\n<li>自动补全：FST还支持前缀查找和自动补全功能，这对于搜索引擎的实现非常有用\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d6b55b19a41c4fd1ce7cff10414833ea.png" width="60%"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Stored Fields：<code>行式存储</code></p>\n<ul>\n<li>作用：存放文件的原始信息</li>\n<li>查询：可以通过文本ID，从Stored Fields，获取出整个文本内容（此处可类比MyISAM引擎）\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/1e8bad19ce7b3ca3cab2859cf68f5909.png" width="60%"></li>\n</ul>\n</li>\n<li>\n<p>Doc Values：<code>列式存储</code></p>\n<ul>\n<li>作用：用于排序和聚合</li>\n<li>说明：对某个字段排序文档，比如按时间、价格排序场景时，提升查询速度（此处可对比Mysql的二级索引）</li>\n<li>原理：将散落在各个文档的某个字段集中存放在一起，\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/14830fed46856b3b0f571f0aae4c3d42.png" width="60%"></li>\n</ul>\n</li>\n<li>\n<p>segment：</p>\n<ul>\n<li>说明：segment是具备完整搜索功能的最小单元</li>\n<li>组成：inverted index、Term index、stored fields、doc values共同构成一个segment</li>\n<li>segment读写规则：\n<ul>\n<li>写入：\n<ul>\n<li>将多个文档生成一个segment，生成后，segment不能再被修改</li>\n<li>如果有新文档，则新生成一个 segment</li>\n</ul>\n</li>\n<li>读取：\n<ul>\n<li>并发同时读多个segment，并进行聚合操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>segment合并：\n<ul>\n<li>避免segment过多影响性能、避免文件句柄耗尽</li>\n<li>不定期将多个小segment合并</li>\n<li>segment合并过程：待补充</li>\n<li>segment合并中的查询：待补充\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9e2dd79d772f594f9beff0dc14e80f44.png" width="60%"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>lucene：</p>\n<ul>\n<li>单机文本检索库，由多个segment构成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:7.24,words:2173},title:"ES原理",icon:"devicon-plain:elasticsearch",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/01.Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html",{loader:()=>a.e(80150).then(a.bind(a,59691)),meta:{author:"Navyum",date:1750173623e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","逻辑架构"],sticky:!1,excerpt:'<h3>mysql逻辑架构图</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/2ef23a6d2026c74ef182788fb9ff7ccc.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n<h3>MySQL从架构角度可以分为：</h3>\n<ul>\n<li><code>Server层</code>：\n<ol>\n<li>该层实现所有跨存储引擎的功能。e.g. 存储过程、触发器、视图等</li>\n<li><code>连接器</code>：\n<ul>\n<li>职责：连接器负责跟客户端建立连接、获取权限、维持和管理连接</li>\n<li>查看当前的连接状态: show processlist</li>\n<li>连接：\n<ul>\n<li>生命周期：一个用户成功建立tcp连接后，该连接生效直到连接断开（修改用户权限，也不会影响已经存在连接的权限）</li>\n<li>长连接：连接成功后，多个请求，使用同一个连接</li>\n<li>短连接：每次执行完很少的几次查询就断开连接，下次查询再重建</li>\n</ul>\n</li>\n<li>MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，如果连接长时间不释放，可能导致OOM</li>\n</ul>\n</li>\n<li><code>查询缓存</code>（不建议开启）：\n<ul>\n<li>原理：MySQL拿到一个查询请求后，会先去查询缓存查询。key 是查询的语句，value 是查询的结果。命中直接返回，否则继续后面的执行阶段。</li>\n<li>不建议开启查询缓存的原因：\n<ul>\n<li>查询缓存失效非常频繁，命中率非常低（只要表有更新，则该表所有查询缓存失效）</li>\n<li>除非该表是静态的配置表，改动频率非常低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>分析器</code>（词法、语法分析）：\n<ul>\n<li>词法分析： 将sql 拆解成单词</li>\n<li>语法分析： 根据语法规则判断sql是否满足语法要求</li>\n</ul>\n</li>\n<li><code>优化器</code>（优化sql，确定执行方案）：\n<ul>\n<li>存在多个索引时，决定使用哪个索引</li>\n<li>多个表join时，决定各个表的连接顺序</li>\n<li>优化器阶段完成后，这个语句的执行方案就确定下来</li>\n</ul>\n</li>\n<li><code>执行器</code>（检查表权限，与引擎交互）：\n<ul>\n<li>先权限检查，检查对这个表 T 有没有执行查询的权限</li>\n<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>\n</ul>\n</li>\n<li>内置函数：\n<ul>\n<li>例如:<code>sum</code>、<code>distinct</code>等函数</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><code>存储引擎层</code>：\n<ul>\n<li>插件式设计，存储引擎层负责数据的存储和提取</li>\n<li>常见的引擎：\n<ul>\n<li>InnoDB</li>\n<li>MyISAM</li>\n<li>Memory</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:2.11,words:633},title:"01.Mysql逻辑架构",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/02.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html",{loader:()=>a.e(59365).then(a.bind(a,83641)),meta:{author:"Navyum",date:1750173641e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","日志系统"],sticky:!1,excerpt:'<h2><code>bin log 备份日志</code></h2>\n<ul>\n<li>作用：<code>Server层</code>生成的日志，主要<strong>用于数据备份和主从复制</strong></li>\n</ul>\n<h4>bin log刷盘时机：</h4>\n<ul>\n<li>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到操作系统的内核缓冲区<code>page cache</code>，最后通过<code>系统调用fsync</code>刷盘。\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/92cb834d86e534ceb9327162eab1dac2.png" alt="Img" loading="lazy"></li>\n</ul>',readingTime:{minutes:12.8,words:3839},title:"02.日志系统",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html",{loader:()=>a.e(29973).then(a.bind(a,10758)),meta:{author:"Navyum",date:1750173649e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","事务隔离级别"],sticky:!1,excerpt:"<h3>事务：</h3>\n<ul>\n<li>事务：就是要保证一组数据库操作，要么全部成功，要么全部失败</li>\n<li>事务的特性：ACID，原子性、一致性、隔离性、持久性</li>\n<li><strong>mysql事务是由引擎提供的支持</strong>，MyISAM 引擎就不支持事务</li>\n<li>多事务同时执行可能会出现的问题：脏写、脏读、不可重复读、幻读\n<ul>\n<li>脏读：在一个事务内读到了另一个未提交事务修改过的数据</li>\n<li>不可重复读：在一个事务内多次读取同一个<code>数据</code>，<strong>由于其他事务的提交</strong>，导致出现前后两次读到的<code>数据</code>不一样的情况</li>\n<li>幻读：在一个事务内多次查询某个符合查询条件的<code>记录数量</code>，<strong>由于其他事务的提交</strong>，出现前后两次查询到的<code>记录数量</code>不一样的情况</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:8.08,words:2423},title:"03.事务隔离级别",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06.%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81.html",{loader:()=>a.e(54736).then(a.bind(a,24649)),meta:{author:"Navyum",date:1750173656e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","锁"],sticky:!1,excerpt:"<h2>Mysql中的锁</h2>\n<h3><code>全局锁</code>：对整个数据库实例加锁</h3>\n<ul>\n<li>全库逻辑备份：\n<ol>\n<li>针对<code>MyISAM</code>做全库逻辑备份，只能用<code>FTWRL</code>方式，在备份时不能更新\n<ul>\n<li>补充：MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，破坏了数据一致性</li>\n</ul>\n</li>\n<li>针对<code>innodb</code>备份，可以使用<code>mysqldump –single-transaction</code> 在备份时可以更新\n<ul>\n<li>补充：通过启动一个事务来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>全库只读设置：\n<ol>\n<li><code>Flush tables with read lock</code>\n<ul>\n<li>FTWRL，连接周期内有效，如果连接断开会自动释放库锁</li>\n</ul>\n</li>\n<li><code>set global readonly=true</code>\n<ul>\n<li>全局生效，连接断开也不会自动修改readonly状态</li>\n<li>常用来做主从库判断</li>\n<li>备份操作不建议使用，如果备份客户端断开连接，整个库会一直维持不可写状态</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>备份补充说明：\n<ul>\n<li>物理备份：使用binlog\n<ul>\n<li>binlog记录了对数据库执行的所有更改，增量数据</li>\n<li>日志格式是二进制</li>\n</ul>\n</li>\n<li>逻辑备份：使用mysqldump\n<ul>\n<li>提供数据库对应时间点的完整的数据快照，当前时间点的全量数据</li>\n<li>格式是快照形式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:11.58,words:3475},title:"06.全局锁、表锁、行锁",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/07.%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.html",{loader:()=>a.e(93064).then(a.bind(a,42003)),meta:{author:"Navyum",date:1750173663e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","行记录"],sticky:!1,excerpt:'<h3>行记录分类：</h3>\n<ul>\n<li><code>Compact</code></li>\n<li><code>Redundant</code>（ &lt; 5.0`）</li>\n<li><code>Dynamic</code> （默认）</li>\n<li><code>Compressed</code></li>\n</ul>\n<h3>Compact 行记录结构：</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b2478b80165fe95ae801cd4d5982c04.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>',readingTime:{minutes:5.12,words:1536},title:"07.行记录结构",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/08.%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.html",{loader:()=>a.e(491).then(a.bind(a,11208)),meta:{author:"Navyum",date:1750173671e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","数据页"],sticky:!1,excerpt:'<h3>基础：</h3>\n<ul>\n<li>页是InnoDB管理存储空间的基本单位，一个页的大小一般是<code>16KB</code></li>\n<li>数据页（索引页）是页的一种，用来组织和和存放用户数据</li>\n<li>索引页之间通过双向链表连接，数据页的物理结构不连续</li>\n</ul>\n<h3>数据页的详细结构：</h3>\n<p><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f1ccac71f2562f6a1e904a67c0a34d51.png" alt="图片" loading="lazy">\n数据页组成：</p>',readingTime:{minutes:6.58,words:1975},title:"08.数据页结构",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/09.%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html",{loader:()=>a.e(29898).then(a.bind(a,84368)),meta:{author:"Navyum",date:175017368e4,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","索引"],sticky:!1,excerpt:'<h3>基础：</h3>\n<ol>\n<li>索引中的数据页的编号不一定连续，也就是说这些页在存储空间里可能并不挨着</li>\n<li>B+树中<code>相同层次</code>的数据页通过页结构的File Header 中的FIL_PAGE_PREV和FIL_PAGE_NEXT，组成双向循环链表</li>\n<li>每个数据页内部会维护<code>页目录</code>，通过分组的方式将所有用户记录分组</li>\n<li>每个数据页内部记录之间通过next_record连接，next_record记录的是下一个记录的偏移位置</li>\n<li>存储用户记录的页和存储索引的页结构FIL_PAGE_TYPE都是"FIL_PAGE_INDEX"</li>\n<li>存储索引的页里面的记录叫做<code>目录项记录</code>，即索引的非叶子结点</li>\n<li>存储用户记录的页里面的记录做<code>用户记录</code>，即索引的叶子节点</li>\n<li>存储<code>目录项记录</code>页中的主键值最小的那个记录的<code>min_rec_mask</code>值为<code>1</code></li>\n</ol>',readingTime:{minutes:8.04,words:2411},title:"09.索引结构",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10.%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.html",{loader:()=>a.e(7733).then(a.bind(a,95120)),meta:{author:"Navyum",date:1750173688e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","表空间"],sticky:!1,excerpt:"<h2>独立表空间：</h2>\n<ul>\n<li>表空间的是由<code>若干个区</code>组成的</li>\n<li><code>区（extent）</code>： <code>连续的64个页</code>就是一个<code>区extent</code>，默认占用1MB空间大小。\n<ul>\n<li><code>为什么要有区</code>：同层的索引页之间以链表组织，物理距离可能会比较远，这样就会引起<code>随机IO</code>。使用区可以保证64个页的连续）</li>\n</ul>\n</li>\n<li><code>段（segment）</code>：\n<ul>\n<li>定义：某些<code>零散的页</code>以及<code>一些完整的区</code>的集合</li>\n<li>innodb段分类：\n<ul>\n<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>\n<li>数据段：存放 B + 树的叶子节点的区的集合；</li>\n<li>回滚段：存放的是回滚数据的区的集合</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>碎片区(fragment)</code>：\n<ul>\n<li>背景：以完整的区为单位分配给某个段，对于数据量较小的表太浪费存储空间</li>\n<li>在一个碎片区中的页可以给不同的段分配页</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:5.39,words:1617},title:"10.表空间结构",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/11.%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5.html",{loader:()=>a.e(619).then(a.bind(a,71311)),meta:{author:"Navyum",date:1750173696e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","索引"],sticky:!1,excerpt:"<h3>索引：</h3>\n<ol>\n<li>作用：提高查询效率</li>\n<li><code>索引不止存在内存中，还要写到磁盘上</code></li>\n</ol>\n<h3>常见的索引模型：</h3>\n<ul>\n<li>哈希表：适用于只有等值查询的场景（kv键值对）</li>\n<li>有序数组：等值查询和范围查询场景（redis的有序集合）</li>\n<li>搜索树：二叉树是搜索效率最高，大多数的数据库存储却并不使用二叉树\n<blockquote>\n<p>[!TIP] 索引不止存在内存中，还要写到磁盘上。N 叉树（B+树）由于在读写上的性能优点，以及适配磁盘的访问模式</p>\n</blockquote>\n</li>\n</ul>",readingTime:{minutes:4.31,words:1292},title:"11.索引概念",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/12.%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6-indexMerge.html",{loader:()=>a.e(61492).then(a.bind(a,87131)),meta:{author:"Navyum",date:1750173703e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","索引合并"],sticky:!1,excerpt:"<h3>索引合并 index merge：</h3>\n<ul>\n<li>含义：使用到<code>多个索引</code>来完成一次查询的执行方法</li>\n<li>explain 中 <code>type</code> 会显示<code>index merge</code></li>\n</ul>\n<h3>核心思想：</h3>\n<ul>\n<li>读多个二级索引的操作是顺序IO（索引是有序的），只用一个索引，但是做回表操作是随机IO</li>\n<li>索引合并优点：\n<ul>\n<li>可以减少回表次数</li>\n<li>基于有序的主键回表 Rowid Ordered Retrieval，简称ROR。</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:1.4,words:419},title:"12.索引合并-indexMerge",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/13.%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2-join.html",{loader:()=>a.e(52125).then(a.bind(a,29564)),meta:{author:"Navyum",date:1750173712e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","连表查询"],sticky:!1,excerpt:'<h3>连接的本质：</h3>\n<ul>\n<li>把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户</li>\n</ul>\n<h3>示意图：</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0be1fc0637e1a70c9d00ff71c0af9af6.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n<h3>连接的类型：</h3>\n<ul>\n<li>\n<p>根据驱动表中的记录在被驱动表中无匹配时，是否加入到最后的结果集分为：</p>\n<ul>\n<li>内连接<code>INNER JOIN</code>：不加入结果集</li>\n<li>外连接：加入结果集</li>\n</ul>\n</li>\n<li>\n<p>根据驱动表选择分为：</p>\n<ul>\n<li>左外连接 <code>LEFT JOIN</code>：选取左侧的表为驱动表</li>\n<li>右外连接 <code>RIGHT JOIN</code>：选取右侧的表为驱动表</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:2.15,words:646},title:"13.连表查询-join",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/14.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-explain%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E7%BB%93%E6%9E%9C.html",{loader:()=>a.e(11216).then(a.bind(a,97764)),meta:{author:"Navyum",date:175017372e4,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","explain","性能优化"],sticky:!1,excerpt:'<h3>explain结果列说明：</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left"><code>explain</code> 列名</th>\n<th style="text-align:left">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">id</td>\n<td style="text-align:left">在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>select_type</code></td>\n<td style="text-align:left">SELECT关键字对应的那个查询的类型</td>\n</tr>\n<tr>\n<td style="text-align:left">table</td>\n<td style="text-align:left">表名</td>\n</tr>\n<tr>\n<td style="text-align:left">partitions</td>\n<td style="text-align:left">匹配的分区信息</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>type</code></td>\n<td style="text-align:left">针对单表的访问方法</td>\n</tr>\n<tr>\n<td style="text-align:left">possible_keys</td>\n<td style="text-align:left">可能用到的索引</td>\n</tr>\n<tr>\n<td style="text-align:left">key</td>\n<td style="text-align:left">实际上使用的索引</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>key_len</code></td>\n<td style="text-align:left">实际使用到的索引长度</td>\n</tr>\n<tr>\n<td style="text-align:left">ref</td>\n<td style="text-align:left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>\n</tr>\n<tr>\n<td style="text-align:left">rows</td>\n<td style="text-align:left">预估的需要读取的记录条数</td>\n</tr>\n<tr>\n<td style="text-align:left">filtered</td>\n<td style="text-align:left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>Extra</code></td>\n<td style="text-align:left">一些额外的信息</td>\n</tr>\n</tbody>\n</table>',readingTime:{minutes:8.58,words:2574},title:"14.性能优化-explain优化器决策结果",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/15.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-optimizeTrace%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.html",{loader:()=>a.e(87819).then(a.bind(a,81990)),meta:{author:"Navyum",date:1750173729e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","optimize","性能优化"],sticky:!1,excerpt:"<h3>成本计算：</h3>\n<h3></h3>\n",readingTime:{minutes:.16,words:49},title:"15.性能优化-optimizeTrace优化器决策过程",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/16.%E7%BC%93%E5%86%B2%E6%B1%A0-BufferPool.html",{loader:()=>a.e(43062).then(a.bind(a,53256)),meta:{author:"Navyum",date:1750173739e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","缓冲池","BufferPool"],sticky:!1,excerpt:"<h3>buffer pool</h3>\n<h4>常识：</h4>\n<ul>\n<li>Buffer Pool 是一片<code>连续</code>的内存空间，通过<code>innodb_buffer_pool_size</code>在服务器运行过程中调整buffer pool大小，默认为128MB</li>\n<li><code>Free Page</code>（空闲页），此页未被使用，位于 <code>Free 链表</code>；</li>\n<li><code>Clean Page</code>（干净页），此页已被使用，但是页面<code>未发生修改</code>，位于 <code>LRU 链表</code>。</li>\n<li><code>Dirty Page</code>（脏页），表示此页<code>已被使用</code>且<code>已经被修改</code>，其数据和磁盘上的数据已经不一致。</li>\n<li>当<code>脏页</code>上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了<code>干净页</code>。脏页同时存在于LRU链表和Flush链表。</li>\n<li><code>提高读性能</code>: 读取数据的时候，先从buffer pool LRU链表（干净页）读取数据，如果没有从磁盘读取并把它相邻的数据页一并加载进来。</li>\n<li><code>提高写性能</code>: 更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘</li>\n</ul>",readingTime:{minutes:5.46,words:1637},title:"16.缓冲池-BufferPool",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/17.Sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html",{loader:()=>a.e(21416).then(a.bind(a,93669)),meta:{author:"Navyum",date:1750173747e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","SQL"],sticky:!1,excerpt:"<h3>UPDATE t_user SET name = 'x' WHERE id = 1</h3>\n<ol>\n<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：\n<ul>\n<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新(id非唯一索引的前提下)；</li>\n<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>\n</ul>\n</li>\n<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\n<ul>\n<li>如果一样的话就不进行后续更新流程；</li>\n<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>\n</ul>\n</li>\n<li>开启事务，InnoDB 层更新记录前，首先要记录相应的 <code>undo log</code>，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 <code>undo log</code>，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>\n<li>InnoDB 层开始更新记录，先生成对应<code>redo log</code>，并存入redo log buffer里面。当事务提交时，将该语句生成的redo log按组为单位，写入redo log file。然后更新buffer pool中的数据页，将其插入<code>flush 链表</code>（如果不在其中），标记为脏页、记录当前redo log对应的lsn到该页的oldest_modification。这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。（这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。但事务提交时必须要将redo log持久化）</li>\n<li>至此，一条记录更新完了。</li>\n<li>在一条更新语句执行完成后，然后开始记录该语句对应的 <code>binlog</code>，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘，然后进行第二阶段的提交。</li>\n<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：\n<ul>\n<li>prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>\n<li>commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>\n</ul>\n</li>\n<li>至此，一条更新语句执行完成。</li>\n</ol>",readingTime:{minutes:2.54,words:763},title:"17.Sql是如何执行的",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/18.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html",{loader:()=>a.e(3020).then(a.bind(a,55072)),meta:{author:"Navyum",date:1750173757e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","主从同步"],sticky:!1,excerpt:'<h2>主从复制</h2>\n<ul>\n<li>\n<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>\n<ol>\n<li>写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>\n<li>同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>\n<li>回放 Binlog：回放 binlog，并更新存储引擎中的数据。</li>\n</ol>\n</li>\n<li>\n<p>具体详细过程如下：</p>\n<ol>\n<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>\n<li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>\n<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7075278aaa241d1c84bdc5fd59fe9077.png" alt="Img" loading="lazy"></li>\n</ol>\n</li>\n</ul>',readingTime:{minutes:1.02,words:306},title:"18.主从同步",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/19.%E5%B8%B8%E8%A7%81%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B.html",{loader:()=>a.e(40298).then(a.bind(a,12843)),meta:{author:"Navyum",date:1750173764e3,localizedDate:"2025年6月17日",category:["Mysql"],tag:["Mysql","数据库选型"],sticky:!1,excerpt:'\n<table>\n<thead>\n<tr>\n<th style="text-align:left">数据库</th>\n<th style="text-align:left">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">mysql</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">TiDB</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">Aurora</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">PolarDB</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">TDSQL</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">MongoDB</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">OpenSearch</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">clickhouse</td>\n<td style="text-align:left"></td>\n</tr>\n<tr>\n<td style="text-align:left">RocksDB</td>\n<td style="text-align:left"></td>\n</tr>\n</tbody>\n</table>',readingTime:{minutes:1.43,words:430},title:"19.常见云数据库选型",icon:"fontisto:mysql",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/opensearch/",{loader:()=>a.e(83395).then(a.bind(a,67734)),meta:{date:1749983452e3,excerpt:"\n<p>TODO</p>\n",readingTime:{minutes:.01,words:2},title:"openSearch",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",{loader:()=>a.e(33364).then(a.bind(a,29423)),meta:{author:"Navyum",date:1750174661e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","数据类型","底层数据结构"],sticky:!1,excerpt:'<h2>Redis 对象类型和编码：</h2>\n<p>Redis键和值都是由<code>redisObject</code>定义</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct redisObiect{</span></span>\n<span class="line"><span>\t//类型</span></span>\n<span class="line"><span>\tunsigned type:4;</span></span>\n<span class="line"><span>\t//编码</span></span>\n<span class="line"><span>\tunsigned encoding:4;</span></span>\n<span class="line"><span>\t//指向底层数据结构的指针</span></span>\n<span class="line"><span>\tvoid *ptr;</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:9.65,words:2895},title:"01.数据类型、底层数据结构",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02.%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.html",{loader:()=>a.e(59704).then(a.bind(a,92914)),meta:{author:"Navyum",date:1750174671e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","全局哈希表","键值对结构"],sticky:!1,excerpt:'<h3>使用全局哈希表存储所有键值对</h3>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/687eba5e392ba487e475247ed1244460.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n<ul>\n<li>哈希表的优点：\n<ul>\n<li>用 O(1) 的时间复杂度来快速查找到键值对</li>\n<li>只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.21,words:363},title:"02.全局哈希表",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/03.%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html",{loader:()=>a.e(49993).then(a.bind(a,44571)),meta:{author:"Navyum",date:1750174678e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","线程模型"],sticky:!1,excerpt:"<h3>误解：redis只有一个线程</h3>\n<ul>\n<li>Redis 的<code>网络IO</code>和<code>键值对读写</code>是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型）</li>\n<li>Redis的其他功能，比如<code>持久化</code>、<code>异步删除</code>、<code>集群数据同步</code>等，其实是由额外的线程执行的。</li>\n</ul>\n<h3>为什么用单线程：</h3>\n<ol>\n<li>多线程开销问题</li>\n<li>多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作）\n（此处没有很好解释原因，而是用多线程缺点来阐述，不够严谨）</li>\n</ol>",readingTime:{minutes:2.4,words:719},title:"03.线程模型",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/04.%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html",{loader:()=>a.e(82149).then(a.bind(a,4502)),meta:{author:"Navyum",date:1750174685e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","淘汰策略","删除策略"],sticky:!1,excerpt:'<h2>过期删除策略：</h2>\n<ul>\n<li>\n<p>场景：针对业务使用，key如果设置了有效期，过期后会进行删除</p>\n</li>\n<li>\n<p>过期时间的存储结构：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct redisDb {</span></span>\n<span class="line"><span>    dict *dict;    /* 数据库键空间，存放着所有的键值对 */</span></span>\n<span class="line"><span>    dict *expires; /* 键的过期时间 */</span></span>\n<span class="line"><span>    ....</span></span>\n<span class="line"><span>} redisDb;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n<li>\n<p>删除过程：</p>\n<ol>\n<li>查询key时，先从<code>expires</code>过期哈希表中查找</li>\n<li>如果过期哈希表中存在该key，则比较存储的时间和系统时间确定是否过期。</li>\n<li>如果不存在、或者key未过期，则返回key对应value</li>\n<li>如果key存在，且已过期，则返回null</li>\n</ol>\n</li>\n<li>\n<p>图解：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3bd65bf45ac843e5e929c68a78f2a1e7.png" alt="Img" loading="lazy"></p>\n</li>\n<li>\n<p>一般的过期删除策略：</p>\n<ul>\n<li>定时删除：\n<ul>\n<li>定义：给key创建定时删除事件，时间达到则删除</li>\n<li>优点：删除更实时，内存释放更快</li>\n<li>缺点：内存不紧张时，也会耗费CPU资源</li>\n</ul>\n</li>\n<li>惰性删除：\n<ul>\n<li>定义：不主动删除过期键，仅当key被访问时，判断是否过期，从而决定是否（同步/异步）删除。</li>\n<li>优点：占用CPU相对更少</li>\n<li>缺点：读少、写多时，内存可能得不到释放</li>\n</ul>\n</li>\n<li>定期删除：\n<ul>\n<li>定义：每隔一段时间<code>随机</code>从expires哈希表取出一定数量的 key进行检查，删除其中的过期key</li>\n<li>优点：折中方案，通过检查频率，限制CPU的使用，并且能相对及时清理内存</li>\n<li>缺点：删除操作的时长和频率无法把控，频率太低或者太高都不好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Redis过期删除策略：</p>\n<ul>\n<li><code>惰性删除</code> + <code>定期删除</code>组合使用</li>\n<li>同步 or 异步删除，Redis&gt;=4.0 通过<code>lazyfree-lazy-expire</code>配置</li>\n<li>频率：默认每秒进行10次过期检查</li>\n<li>随机数量：20个</li>\n<li>额外逻辑：\n<ul>\n<li>一次检查中，如果超过25%的key过期，则再次获取20个key</li>\n<li>一次检查的最大时间限制：默认25ms。防止因为有大量key过期，一直陷在检查中，导致程序卡死。</li>\n</ul>\n</li>\n<li>疑问？：频率*最大时间限制超过了1s</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:3.06,words:919},title:"04.淘汰策略",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/06.%E6%8C%81%E4%B9%85%E5%8C%96-AOF.html",{loader:()=>a.e(76823).then(a.bind(a,69216)),meta:{author:"Navyum",date:1750174692e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","持久化","AOF"],sticky:!1,excerpt:'<h3>写日志的方式：</h3>\n<ul>\n<li>\n<p>WAL：写前日志（Write Ahead Log, WAL）在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复（mysql 先把数据写到redo log，再落盘）。</p>\n</li>\n<li>\n<p>AOF：写后日志， Redis 是先执行命令，把数据写入内存，然后才记录日志。（所以AOF不是crash-safe的）</p>\n</li>\n</ul>\n<h3>AOF：</h3>\n<ul>\n<li>AOF 里记录的是 Redis 收到的<code>每一条写操作</code>。以文本形式保存的。</li>\n<li>优点：\n<ul>\n<li>AOF是<code>顺序写</code>，不需要检查和索引操作，避免了额外检查的开销</li>\n<li>不会阻塞<code>当前</code>的写入操作</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>未写入AOF的那部分数据可能会丢失</li>\n<li>因为些操作和写AOF都是在主进程中，所以写AOF时，可能会阻塞后一个<code>写操作</code></li>\n</ul>\n</li>\n<li>刷盘时机：\n<ul>\n<li>\n<p>配置<code>appendfsync</code>：</p>\n<ul>\n<li>Always：每次执行命令后，通过系统调用fsync刷盘</li>\n<li>Everysec：创建异步，每隔1秒，调用一次fsync刷盘</li>\n<li>No：由操作系统控制，不主动调用fsync</li>\n</ul>\n</li>\n<li>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f82ece977374ec72eca3b92d1d068d57.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n</li>\n</ul>\n</li>\n<li><code>AOF 缓冲区</code>：\n<ul>\n<li>将命令刷盘前，先放入 AOF 缓冲区，然后通过fsync刷盘。服务于AOF 文件刷盘，提高刷盘效率。</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:2.87,words:860},title:"06.持久化-AOF",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/07.%E6%8C%81%E4%B9%85%E5%8C%96-RDB.html",{loader:()=>a.e(32502).then(a.bind(a,94574)),meta:{author:"Navyum",date:1750174699e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","持久化","RDB"],sticky:!1,excerpt:"<h3>RDB（Redis DataBase）：</h3>\n<ul>\n<li>含义：RDB 快照就是记录Redis<code>某一个瞬间的全部内存数据</code>，记录的是实际数据。这个文件就是RDB快照文件。</li>\n</ul>\n<h3>跟AOF对比：</h3>\n<ul>\n<li>文件内容：\n<ul>\n<li>RDB 文件的内容是二进制数据（状态数据）</li>\n<li>AOF文件内容是命令数据（操作数据）</li>\n</ul>\n</li>\n<li>数据恢复效率：\n<ul>\n<li>RDB 文件直接读入内存完成恢复，效率更高</li>\n<li>AOF 需要执行操作命令，通过逐个重放命令实现恢复，效率低</li>\n</ul>\n</li>\n<li>执行的进程：\n<ul>\n<li>RDB 是在bgsave子进程，因为RDB需要对全量数据做写入，不能在主进程做</li>\n<li>AOF 是在主进程，因为AOF每次只有少量命令，并且是追加写（顺序写），在主进程影响不大</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:2.98,words:894},title:"07.持久化-RDB",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/08.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5-Slave.html",{loader:()=>a.e(30268).then(a.bind(a,5808)),meta:{author:"Navyum",date:1750174709e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","主从同步","repl_backlog_buffer"],sticky:!1,excerpt:"<h3>为什么使用主、从架构：</h3>\n<ol>\n<li>单机下如果宕机，通过AOF、RDB恢复需要时间。服务会出现中断，为了<code>高可用性</code></li>\n<li>单机性能存在瓶颈上限，主、从可以提升读操作的瓶颈上限，为了<code>高性能</code></li>\n</ol>\n<h3>主、从模式特点：</h3>\n<ul>\n<li>主、从之间的数据同步操作是异步进行的，属于弱一致性（最终一致）</li>\n<li>通过冗余解决可用性问题：\n<ul>\n<li>数据冗余（每个节点都存数据）</li>\n<li>服务冗余（每个节点都可以提供读服务，不支持写）</li>\n</ul>\n</li>\n<li>冗余带来的新问题：\n<ul>\n<li>主、从数据的一致性问题：\n<ul>\n<li>Redis提供了主从复制模式，避免数据不一致</li>\n</ul>\n</li>\n<li>多服务的通信问题：\n<ul>\n<li>主、从心跳监测</li>\n<li>哨兵机制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>读、写分离：\n<ul>\n<li>读操作：主、从都可以接收命令</li>\n<li>写操作：仅主库接收命令，执行后同步给从库</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:3.54,words:1063},title:"08.主从同步-Slave",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/09.%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-Sentinel.html",{loader:()=>a.e(12063).then(a.bind(a,18200)),meta:{author:"Navyum",date:1750174716e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","哨兵机制","Sentinel"],sticky:!1,excerpt:'<h2>哨兵（观察者）</h2>\n<h3>哨兵特征：</h3>\n<ul>\n<li>哨兵是一个运行在特殊模式下的 Redis 进程</li>\n<li>每个哨兵都需要和所有的主、从库建立连接</li>\n<li>哨兵相当于"观察者节点"，观察的对象是主、从节点</li>\n<li>哨兵之间互相发现：\n<ul>\n<li><code>主库的发布/订阅 机制</code>：通过主库的<code>__sentinel__:hello</code></li>\n<li>哨兵在主库发布自己的信息、订阅其他哨兵信息</li>\n</ul>\n</li>\n<li>哨兵如何发现从库：\n<ul>\n<li>哨兵会每<code>10秒一次的频率</code>向主库发送<code>INFO</code>命令，获取从库列表</li>\n</ul>\n</li>\n<li>哨兵如何通知客户端：\n<ul>\n<li>每个哨兵对外提供<code>发布/订阅机制</code></li>\n<li>客户端从哨兵订阅消息，关注主、从故障转移中的关键事件</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:3.31,words:994},title:"09.哨兵机制-Sentinel",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/10.%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-Sharding.html",{loader:()=>a.e(27275).then(a.bind(a,44461)),meta:{author:"Navyum",date:1750174721e3,localizedDate:"2025年6月17日",category:["Redis"],tag:["Redis","分片集群","Sharding"],sticky:!1,excerpt:"<h2>分片集群：</h2>\n<h4>分片集群作用：</h4>\n<ul>\n<li>单机内存存在上限，通过横向扩展来突破存储的上限</li>\n</ul>\n<h4>主从集群作用：</h4>\n<ul>\n<li>提升可用性，避免单点故障</li>\n</ul>\n<h4>分片集群方案：</h4>\n<ul>\n<li>官方的<code>redis cluster</code></li>\n<li>更早更稳定的<code>codis</code></li>\n</ul>\n<h2>redis cluster：</h2>\n<h4>特性：</h4>\n<ol>\n<li>采用无中心化的模式（无proxy，客户端与服务端直连）</li>\n<li>cluster 使用<code>哈希槽（Hash Slot）</code>处理数据和实例之间的映射关系</li>\n<li>默认有16384个槽，需要把所有的槽分配给实例，否则 Redis 集群无法正常工作。（一个实例会对应多个槽位）</li>\n<li>每个redis实例都有所有哈希槽的映射关系</li>\n<li>如果集群中Redis实例的内存大小不一样，可以使用cluster addslots进行手动分配哈希槽</li>\n<li><code>hash slot</code>简化了节点扩缩容的难度，便于集群的维护和管理，但是增加了客户端<code>映射表的维护成本</code>，客户端需要支持重定向机制带来的新的协议。</li>\n</ol>",readingTime:{minutes:5.83,words:1750},title:"10.分片集群-Sharding",icon:"devicon-plain:redis",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/kafka%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(11066).then(a.bind(a,39822)),meta:{author:"Navyum",date:1750173367e3,localizedDate:"2025年6月17日",category:["消息队列","常用软件"],tag:["kafka"],sticky:!1,excerpt:'<h3>整体架构：</h3>\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/09d7819af5b62fff56e36721d01d7c4f.png" width="60%">\n<h3>高性能：</h3>\n<h4>减少资源竞争：</h4>\n<ul>\n<li>将消息按照业务拆分到多个<code>topic</code>。减少生产者和消费者对topic的读、写竞争</li>\n<li>将topic再拆分为多个<code>partition</code>。每个消费者负责一个partition\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f8284857339d397d22154713ddd2a9ae.png" width="60%">\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/4e5f3f34a51e479142bca13f96b9c579.png" width="60%"></li>\n</ul>',readingTime:{minutes:2.6,words:779},title:"kafka原理",icon:"logos:kafka-icon",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/nsq/",{loader:()=>a.e(47129).then(a.bind(a,18550)),meta:{author:"Navyum",date:1750763109e3,localizedDate:"2025年6月24日",category:["消息队列"],tag:["消息队列","nsq"],sticky:!1,excerpt:"<p>TODO</p>\n",readingTime:{minutes:.11,words:34},title:"README",type:"article"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/RocketMQ%E5%8E%9F%E7%90%86.html",{loader:()=>a.e(16492).then(a.bind(a,77670)),meta:{author:"Navyum",date:1750173324e3,localizedDate:"2025年6月17日",category:["常用软件","消息队列"],tag:["消息队列","RocketMQ"],sticky:!1,excerpt:'<h2>整体架构：</h2>\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/dd4853b7ddf4ae9a421ff728ccaad2c4.png" width="60%">\n<h2>与kafka对比：</h2>\n<ul>\n<li>和Kafka相比，RocketMQ在架构上做了<code>减法</code>，在功能上做了<code>加法</code></li>\n</ul>\n<h3>架构上的差异：做减法，对kafka做精简</h3>\n<h4>nameserver替换zookeeper：</h4>\n<ul>\n<li>用一种更轻量的方式，管理消息队列的集群信息</li>\n<li>生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现服务发现和负载均衡的效果\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/aa624423f7fc2f3d143f192230a4e034.png" width="60%"></li>\n</ul>',readingTime:{minutes:2.33,words:698},title:"RocketMQ原理",icon:"simple-icons:apacherocketmq",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E7%BA%B2.html",{loader:()=>a.e(25190).then(a.bind(a,36626)),meta:{author:"Navyum",date:1738942259e3,localizedDate:"2025年2月7日",category:["架构设计"],tag:["设计模式"],sticky:!1,excerpt:'<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a2062c3944538ca5b4992ee515c27aa5.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<p>https://kiosk007.top/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fdesign-pattern/</p>\n',readingTime:{minutes:.18,words:54},title:"设计模式大纲",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB.html",{loader:()=>a.e(66677).then(a.bind(a,61002)),meta:{author:"Navyum",date:1738942259e3,localizedDate:"2025年2月7日",category:["架构设计"],tag:["设计模式"],sticky:!1,excerpt:'<h2>设计模式大纲</h2>\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a2062c3944538ca5b4992ee515c27aa5.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure>\n<hr>\n<h2>设计原则：（SOLID原则）</h2>\n<table>\n<thead>\n<tr>\n<th>简写</th>\n<th>原则名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SRP</td>\n<td>单一职责原则</td>\n<td>每个模块或类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。它的所有服务都应严格遵守这一职责。</td>\n</tr>\n<tr>\n<td>OCP</td>\n<td>开闭原则</td>\n<td>软件中的对象（类、模块、函数等）对扩展是开放的，对修改是封闭的。</td>\n</tr>\n<tr>\n<td>LSP</td>\n<td>里氏替换原则</td>\n<td>所有使用基类的地方必须能透明地使用其子类的对象。</td>\n</tr>\n<tr>\n<td>ISP</td>\n<td>接口隔离原则</td>\n<td>客户端不应该依赖它不需要的接口。</td>\n</tr>\n<tr>\n<td>DIP</td>\n<td>依赖倒转原则</td>\n<td>是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</td>\n</tr>\n<tr>\n<td>LoD/PoLK</td>\n<td>迪米特法则/最少知识原则</td>\n<td>1. 每个对象应该对其他对象尽可能最少的知道 2. 每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</td>\n</tr>\n</tbody>\n</table>',readingTime:{minutes:25.56,words:7668},title:"设计模式汇总",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%A4%A7%E7%BA%B2%E5%9B%BE%E8%A7%A3.html",{loader:()=>a.e(4732).then(a.bind(a,23588)),meta:{date:1749983452e3,excerpt:'\n<figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d16b7a198326068ff3c9e36d2a4da2a0.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>\n',readingTime:{minutes:.03,words:8},title:"大纲图解",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1-Idempotency.html",{loader:()=>a.e(46339).then(a.bind(a,76610)),meta:{date:1749983452e3,excerpt:"\n<p>概念：</p>\n<p>幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x) = f(f(x))。<strong>注解：不强调获取的结果一致，而是对资源副作用是否一致。</strong></p>\n<p>存在的原因：</p>\n<p>系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。</p>\n<p>解决方案：</p>\n<p>a. 下游系统提供相应的查询接口。上游系统在 timeout 后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。</p>",readingTime:{minutes:1.04,words:312},title:"幂等性设计-Idempotency",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1-Asynchronous.html",{loader:()=>a.e(18022).then(a.bind(a,97536)),meta:{date:1749983452e3,excerpt:"\n<p>同步的优点：</p>\n<ul>\n<li>\n<p>系统间只耦合于接口</p>\n</li>\n<li>\n<p>实时性也会比异步调用要高\n同步的缺点：</p>\n</li>\n<li>\n<p>同步调用需要被调用方的吞吐不低于调用方的吞吐。同步调用链的性能会由最慢的那个服务所决定。</p>\n</li>\n<li>\n<p>同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。</p>\n</li>\n<li>\n<p>同步调用只能是一对一的，很难做到一对多。</p>\n</li>\n<li>\n<p>同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。\n异步调用的优点：</p>\n</li>\n<li>\n<p>增加吞吐量之外</p>\n</li>\n<li>\n<p>让服务间的解耦更为彻底，系统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力\n异步通讯的三种方式：</p>\n</li>\n</ul>",readingTime:{minutes:3.61,words:1083},title:"异步通讯设计-Asynchronous",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81-State.html",{loader:()=>a.e(22915).then(a.bind(a,68745)),meta:{date:1749983452e3,excerpt:"\n<p>含义：</p>\n<pre><code>为了保留程序的一些数据或是上下文。\n\n程序调用的结果。\n\n服务组合下的上下文。\n\n服务的配置。\n\ne.g 每一次请求的状态，用户登录Session\n</code></pre>\n<p>无状态实现方式：</p>\n<pre><code>特点：可以随意扩展或删除节点\n\n本质：转移责任\n\n把状态保存到其他的地方。e.g. Redis ，MySQL ，高可用的强一致性的存储ZooKeeper/Etcd ，分布式文件系统\n</code></pre>\n<p>拓展：</p>\n<p>面向对象是将数据和方法放一起，无状态是将数据和方法分离。（存算分离）</p>\n<p>无状态的服务需要我们把数据同步到不同的节点上，而有状态的服务通过 Sticky Session 做数据分片。</p>",readingTime:{minutes:.62,words:187},title:"服务的状态",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%86%94%E6%96%AD%E8%AE%BE%E8%AE%A1-Circuit-Breaker.html",{loader:()=>a.e(62927).then(a.bind(a,94562)),meta:{date:1749983452e3,excerpt:"\n<p>含义：</p>\n<pre><code>类比电路中的保险丝。熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定是继续操作，还是立即返回错误。\n</code></pre>\n<p>注意点：</p>\n<ul>\n<li>\n<pre><code>当重试无法解决问题，即故障不是暂时的。使用熔断可以保护后端业务不会过载。\n</code></pre>\n</li>\n<li>\n<pre><code>避免资源浪费，防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。\n</code></pre>\n</li>\n<li>\n<pre><code>熔断器模式基本功能：诊断服务是否出现长时间故障，自动熔断。诊断错误是否已经修正，自动恢复服务。\n</code></pre>\n</li>\n</ul>",readingTime:{minutes:3.04,words:912},title:"熔断设计-Circuit-Breaker",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1-CompensatingTransaction.html",{loader:()=>a.e(68375).then(a.bind(a,82624)),meta:{date:1749983452e3,excerpt:"\n<p>含义：</p>\n<pre><code>为了保证业务上一致性（或者说努力将业务流程执行完成，达到最终状态）。如果业务流中某个步骤失败了（即执行不下去的时候），那么需要启动业务补偿。要么回滚到以前的服务调用（revert/cancel），要么不断重试保证所有的步骤都成功（retry）。\n</code></pre>\n<p>ACID(酸)  和  BASE(碱)</p>\n<p>ACID:</p>\n<ul>\n<li>\n<p>原子性：整个事务中的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n</li>\n<li>\n<p>一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n</li>\n<li>\n<p>隔离性：两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时中间某一时刻的数据。两个事务不会发生交互。</p>\n</li>\n<li>\n<p>持久性：在事务完成以后，该事务对数据库所做的更改便持久地保存在数据库之中，并不会被回滚。</p>\n</li>\n<li>\n<p>强调 C\nBASE:</p>\n</li>\n<li>\n<p>Basic Availability：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。</p>\n</li>\n<li>\n<p>Soft-state：软状态。它是我们前面的“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。</p>\n</li>\n<li>\n<p>Eventual Consistency：最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。</p>\n</li>\n<li>\n<p>强调 A</p>\n</li>\n</ul>",readingTime:{minutes:2.79,words:836},title:"补偿事务",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1-Retry.html",{loader:()=>a.e(5170).then(a.bind(a,44360)),meta:{date:1749983452e3,excerpt:"\n<p>定义：</p>\n<pre><code> “重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。\n</code></pre>\n<p>重试设计重点：</p>\n<ul>\n<li>\n<p>确定重试场景，即什么样的错误下需要重试。\n可重试：调用超时、返回已知的可以重试的错误（如繁忙中、流控中、维护中、资源不足等）</p>\n<pre><code>不可重试：业务级错误，无权限等，技术级错误，bug，500\n</code></pre>\n</li>\n<li>\n<p>重试的时间和重试的次数。即重试策略。\n引入“指数级退避”策略，即每次重试，时间间隔成倍增加。类似：TCP拥塞控制</p>\n</li>\n<li>\n<p>服务长期故障的处理。如果超过重试次数，或是重试时间，那么重试没有意义。触发熔断，对新请求直接返回错误直到服务恢复。</p>\n</li>\n<li>\n<p>调用方需要做幂等设计，否则会不安全。</p>\n</li>\n<li>\n<p>重试代码设计比较通用和简单。两种模式：<br>\n1. java annotation 2. service mesh</p>\n</li>\n<li>\n<p>对于有事务相关的操作，我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。此时需要保存上下文。\n拓展：</p>\n</li>\n</ul>",readingTime:{minutes:2.51,words:753},title:"重试设计-Retry",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%99%8D%E7%BA%A7%E8%AE%BE%E8%AE%A1-degradation.html",{loader:()=>a.e(71770).then(a.bind(a,93468)),meta:{date:1749983452e3,excerpt:"\n<p>含义：</p>\n<pre><code>本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。\n</code></pre>\n<p>降级待牺牲清单：</p>\n<ul>\n<li>\n<p>降低一致性： 从强一致性变为最终一致性。\na. 使用异步方式，简化流程一致性</p>\n<p>b. 使用缓存，降低数据一致性</p>\n</li>\n<li>\n<p>停止次要功能：停止访问不重要的功能，从而释放出更多的资源。</p>\n</li>\n<li>\n<p>简化功能或流程。把一些功能简化掉，比如不再返回全量数据，只返回部分数据。对计算等资源需求比较高的，不重要的逻辑简化掉。</p>\n</li>\n</ul>",readingTime:{minutes:1.85,words:555},title:"降级设计-degradation",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1-Throttle.html",{loader:()=>a.e(79661).then(a.bind(a,61989)),meta:{date:1749983452e3,excerpt:"\n<p>含义：</p>\n<p>进行流量控制，以保护系统不会在过载的情况下出现问题。</p>\n<p>场景：</p>\n<p>数据库访问的连接池；线程池；Nginx  并发连接限制 limit_conn 模块，每秒平均速率限制 limit_req 模块；MQ 的生产速</p>\n<p>策略：</p>\n<p>限流的目的是通过对并发访问进行限速。</p>\n<p>相关的策略一般是，一旦达到<strong>限制的速率</strong>，那么就会触发相应的限流行为。</p>\n<p>触发条件：</p>\n<ul>\n<li>\n<p>拒绝服务：拒绝恶意、高并发请求</p>\n</li>\n<li>\n<p>服务降级：后端服务、功能做降级</p>\n</li>\n<li>\n<p>特权请求：在多租户内将有限资源分配给重要租户</p>\n</li>\n<li>\n<p>延迟处理：使用队列缓冲、削峰</p>\n</li>\n<li>\n<p>弹性伸缩：自动伸缩无状态服务\n实现方式：</p>\n</li>\n<li>\n<p>计数器：\n维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。</p>\n</li>\n<li>\n<p>队列：\n普通队列：流速波动，处理速度固定，类似FIFO</p>\n</li>\n</ul>",readingTime:{minutes:4.12,words:1237},title:"限流设计-Throttle",type:"article"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1-Bulkheads.html",{loader:()=>a.e(48588).then(a.bind(a,30891)),meta:{date:1749983452e3,excerpt:'<p>隔离设计-Bulkheads</p>\n<p>定义：</p>\n<pre><code>在分布式软件架构中，使用隔离设计让我们的故障得到隔离。这就需要我们对系统进行分离。\n</code></pre>\n<p>隔离方式：</p>\n<ol>\n<li>\n<p>按服务种类<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a8213062e2f9c10c4d208eda7a8ce6fd.png" alt="图片" loading="lazy"></p>\n</li>\n<li>\n<p>按租户<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/c5bc6a096b25a16fad5fe9f7d53d4589.png" alt="图片" loading="lazy"></p>\n</li>\n</ol>',readingTime:{minutes:.22,words:67},title:"",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/0.%E7%BA%BF%E6%80%A7%E8%A1%A8.html",{loader:()=>a.e(52348).then(a.bind(a,38634)),meta:{author:"Navyum",date:1750171668e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["线性表"],sticky:!1,excerpt:"<h2>线性表</h2>\n<h3>特点：</h3>\n<ul>\n<li>由N个具有<code>相同特性</code>的数据元素组成的有限序列</li>\n<li>线性表中的数据元素之间呈现一对一的关系，除了第一个和最后一个数据元素之外，<code>其他数据元素都是首尾相接的</code></li>\n<li>线性表上的数据最多<code>只有前和后</code>两个方向</li>\n</ul>\n<h3>举例：</h3>\n<ul>\n<li>数组</li>\n<li>链表</li>\n<li>栈</li>\n<li>队列</li>\n</ul>\n<h3>个人理解</h3>\n<ul>\n<li>线性、非线性的区别\n<ul>\n<li>数学坐标系：\n<ul>\n<li>线性表元素之间相互连接，类比<code>线段</code></li>\n<li>非线性表之间不相关，类比<code>散落的点</code></li>\n</ul>\n</li>\n<li>统计学：\n<ul>\n<li>线性表类比<code>线性分布</code></li>\n<li>非线性表类比<code>离散分布</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:.75,words:226},title:"0.线性表",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.%E6%95%B0%E7%BB%84.html",{loader:()=>a.e(45749).then(a.bind(a,3345)),meta:{author:"Navyum",date:1750171691e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["数组"],sticky:!1,excerpt:"<h2>数组 Array：</h2>\n<h3>概念：</h3>\n<ul>\n<li>数组（Array）是一种线性表数据结构</li>\n<li>用一组<code>连续的内存空间</code>，来存储一组具有<code>相同类型的数据</code></li>\n<li>数组中的元素可以通过索引直接访问</li>\n</ul>\n<h3>特点：</h3>\n<ul>\n<li>随机访问：可以快速地通过索引访问任何元素</li>\n<li>固定大小：一旦声明，数组的大小就固定了</li>\n<li>空间效率：因为申明时需要预留空间，在空间上可能不是最优的</li>\n</ul>\n<h3>优缺：</h3>\n<ul>\n<li>优点：查询、更新</li>\n<li>缺点：插入、删除</li>\n</ul>",readingTime:{minutes:.77,words:231},title:"1.数组",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/2.1%E5%88%97%E8%A1%A8.html",{loader:()=>a.e(83664).then(a.bind(a,95449)),meta:{author:"Navyum",date:1750171792e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["列表"],sticky:!1,excerpt:"<h2>列表 List</h2>\n<h3>概念：</h3>\n<ul>\n<li>列表 List 是一种抽象的数据结构概念</li>\n<li>表示元素的<code>有序</code>集合</li>\n<li>无须使用者考虑容量限制的问题</li>\n</ul>\n<h3>如何实现列表：</h3>\n<ul>\n<li>链表本身就是列表</li>\n<li>动态数组实现列表，需要实现动态扩容</li>\n</ul>\n",readingTime:{minutes:.35,words:104},title:"2.1列表",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/2.%E9%93%BE%E8%A1%A8.html",{loader:()=>a.e(52988).then(a.bind(a,5016)),meta:{author:"Navyum",date:1750171849e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["链表"],sticky:!1,excerpt:"<h2>链表 Linked List：</h2>\n<h3>概念：</h3>\n<ul>\n<li>数组（Array）是一种线性表数据结构</li>\n<li>用<code>非连续的内存空间</code>，来存储具有<code>相同类型的数据</code>的数据结构</li>\n<li>每个节点包含<code>数据部分</code>和<code>指针</code>，指针指向下一个（或上一个，对于双向链表）节点</li>\n</ul>\n<h3>特点：</h3>\n<ul>\n<li>动态大小：链表的大小可以在运行时改变</li>\n<li>不连续的内存：节点可以在内存中分散存储，通过指针相连</li>\n</ul>",readingTime:{minutes:1.05,words:315},title:"2.链表",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/3.%E6%A0%88.html",{loader:()=>a.e(86483).then(a.bind(a,5270)),meta:{author:"Navyum",date:1750171871e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["栈"],sticky:!1,excerpt:"<h2>栈 Stack：</h2>\n<h3>概念：</h3>\n<ul>\n<li>栈（Stack）是一种线性表数据结构</li>\n<li>遵循<code>后进先出</code>（LIFO，Last In First Out）原则，<code>只能在栈顶进行添加和删除操作</code></li>\n</ul>\n<h3>操作：</h3>\n<ul>\n<li>push  （入栈）</li>\n<li>pop   （出栈）</li>\n<li>peek  （仅查看）</li>\n</ul>\n<h3>栈的应用：</h3>\n<ul>\n<li>函数调用栈</li>\n<li>表达式求值</li>\n<li>回溯算法</li>\n</ul>",readingTime:{minutes:.37,words:110},title:"3.栈",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/4.%E9%98%9F%E5%88%97.html",{loader:()=>a.e(39582).then(a.bind(a,53620)),meta:{author:"Navyum",date:1750171884e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["队列"],sticky:!1,excerpt:"<h2>队列 Queue：</h2>\n<h3>概念：</h3>\n<ul>\n<li>队列 Queue 是一种线性表数据结构</li>\n<li>遵循<code>先进先出</code>（FIFO，First In First Out）原则，<code>在队列的尾部添加元素，在头部移除元素</code></li>\n</ul>\n<h3>操作：</h3>\n<ul>\n<li>enqueue（入队）</li>\n<li>dequeue（出队）</li>\n<li>front  （仅查看）</li>\n</ul>\n<h3>应用：</h3>\n<ul>\n<li>任务调度</li>\n<li>广度优先搜索算法</li>\n</ul>",readingTime:{minutes:.58,words:173},title:"4.队列",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/1.%E6%95%A3%E5%88%97%E8%A1%A8.html",{loader:()=>a.e(40452).then(a.bind(a,68534)),meta:{author:"Navyum",date:1750171895e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["散列表"],sticky:!1,excerpt:'<h2>散列表/哈希表</h2>\n<h3>特点：</h3>\n<ul>\n<li>通过建立键 key 与值 value 之间的映射，实现<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间复杂度的高效的元素查询</li>\n<li></li>\n</ul>',readingTime:{minutes:1.71,words:512},title:"1.散列表",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/2.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.html",{loader:()=>a.e(67518).then(a.bind(a,84339)),meta:{author:"Navyum",date:1750171913e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["哈希函数"],sticky:!1,excerpt:"<h2>哈希函数</h2>\n<h3>目标：</h3>\n<ul>\n<li>极快且稳定</li>\n</ul>\n<h3>特点：</h3>\n<ul>\n<li>确定性/<code>幂等性</code>：\n<ul>\n<li>对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。</li>\n</ul>\n</li>\n<li><code>效率高</code>：\n<ul>\n<li>计算哈希值的过程应该足够快，哈希表的实用性越高。</li>\n</ul>\n</li>\n<li><code>均匀分布</code>：\n<ul>\n<li>哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:.66,words:199},title:"2.哈希函数",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/3.%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86.html",{loader:()=>a.e(97825).then(a.bind(a,30738)),meta:{author:"Navyum",date:1750171925e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["冲突处理"],sticky:!1,excerpt:"\n",readingTime:{minutes:.13,words:40},title:"3.冲突处理",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/4.%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9.html",{loader:()=>a.e(77264).then(a.bind(a,52611)),meta:{author:"Navyum",date:1750171935e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["动态扩容"],sticky:!1,excerpt:"\n",readingTime:{minutes:.13,words:40},title:"4.动态扩容",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/5.%E4%BD%8D%E5%9B%BE.html",{loader:()=>a.e(58039).then(a.bind(a,65697)),meta:{author:"Navyum",date:1750171952e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["位图"],sticky:!1,excerpt:"\n",readingTime:{minutes:.11,words:34},title:"5.位图",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/1.%E6%A0%91.html",{loader:()=>a.e(94185).then(a.bind(a,96935)),meta:{author:"Navyum",date:1750171966e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["树"],sticky:!1,excerpt:"<h2>树</h2>\n<ul>\n<li>在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系</li>\n<li>树结构是一种非线性存储结构，存储的是具有<code>一对多</code>关系的数据元素</li>\n</ul>\n<h3>树的分类：</h3>\n<ul>\n<li>树\n<ul>\n<li>二叉树\n<ul>\n<li>按树的结构：\n<ul>\n<li>满二叉树</li>\n<li>完满二叉树</li>\n<li>完全二叉树</li>\n</ul>\n</li>\n<li>按搜索功能：\n<ul>\n<li>查找：（索引）\n<ul>\n<li>二叉查找树（BST）\n<ul>\n<li>非平衡查找树</li>\n<li>平衡树二叉树 AVL树：\n<ul>\n<li>红黑树</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>排序：（优先队列）\n<ul>\n<li>堆（完全二叉树的应用）\n<ul>\n<li>大顶堆</li>\n<li>小顶堆</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多叉树\n<ul>\n<li>B树（多叉 Balance Tree）\n<ul>\n<li>2-3树（无实际作用）</li>\n<li>2-3-4树（无实际作用）</li>\n<li>B+ 树\n<ul>\n<li>B* 树</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>其他：\n<ul>\n<li>Trie树、字典树</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:.73,words:220},title:"1.树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/2.%E4%BA%8C%E5%8F%89%E6%A0%91.html",{loader:()=>a.e(65581).then(a.bind(a,67269)),meta:{author:"Navyum",date:1750171977e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["二叉树"],sticky:!1,excerpt:'<h2>二叉树 Binary Tree：</h2>\n<h3>1.特点：</h3>\n<ul>\n<li>一种非线性数据结构，代表“祖先”与“后代”之间的派生关系</li>\n<li>二叉树的基本单元是节点，每个节点至少包含<code>值</code>、<code>左子节点引用</code>和<code>右子节点引用</code></li>\n<li>二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</li>\n</ul>\n<h3>2.概念：</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">名词</th>\n<th style="text-align:left">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">根节点（root node）</td>\n<td style="text-align:left">位于二叉树顶层的节点，没有父节点。</td>\n</tr>\n<tr>\n<td style="text-align:left">叶节点（leaf node）</td>\n<td style="text-align:left">没有子节点的节点，其两个指针均指向 None 。</td>\n</tr>\n<tr>\n<td style="text-align:left">边（edge）</td>\n<td style="text-align:left">连接两个节点的线段，即节点引用（指针）。</td>\n</tr>\n<tr>\n<td style="text-align:left">二叉树的高度（height）</td>\n<td style="text-align:left">从根节点到最远叶节点所经过的边的数量。</td>\n</tr>\n<tr>\n<td style="text-align:left">节点所在的层（level）</td>\n<td style="text-align:left">从顶至底递增，根节点所在层为 1 。</td>\n</tr>\n<tr>\n<td style="text-align:left">节点的度（degree）</td>\n<td style="text-align:left">节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</td>\n</tr>\n<tr>\n<td style="text-align:left">节点的深度（depth）</td>\n<td style="text-align:left">从根节点到该节点所经过的边的数量。</td>\n</tr>\n<tr>\n<td style="text-align:left">节点的高度（height）</td>\n<td style="text-align:left">从距离该节点最远的叶节点到该节点所经过的边的数量。</td>\n</tr>\n</tbody>\n</table>',readingTime:{minutes:3.52,words:1055},title:"2.二叉树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/3.AVL%E5%B9%B3%E8%A1%A1%E6%A0%91.html",{loader:()=>a.e(35502).then(a.bind(a,73675)),meta:{author:"Navyum",date:1750171986e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["AVL平衡树"],sticky:!1,excerpt:'<h2>AVL平衡树</h2>\n<h3>特征：</h3>\n<ul>\n<li>AVL 树既是<code>二叉搜索树</code>，也是<code>平衡二叉树</code>，同时满足这两类二叉树的所有性质</li>\n<li>AVL 树是一种平衡二叉搜索树</li>\n</ul>\n<h3>属性：</h3>\n<ul>\n<li>节点高度</li>\n<li>节点平衡因子：节点左子树的高度减去右子树的高度，空节点的平衡因子为0</li>\n</ul>\n<h3>AVL 树旋转：</h3>\n<ul>\n<li>作用：\n<ul>\n<li>AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡</li>\n<li>旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”</li>\n</ul>\n</li>\n<li>旋转：\n<ul>\n<li>左旋</li>\n<li>右旋</li>\n<li>先左旋再右旋</li>\n<li>先右旋再左旋\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/eb66fb8a5f881c7e85d89566f55bec6b.png" width="60%"></li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.33,words:398},title:"3.AVL平衡树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/4.%E7%BA%A2%E9%BB%91%E6%A0%91.html",{loader:()=>a.e(44581).then(a.bind(a,76926)),meta:{author:"Navyum",date:1750171996e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["红黑树"],sticky:!1,excerpt:'<h2>红黑树</h2>\n<ul>\n<li>红黑树是一种自平衡的<code>二叉查找树</code>，属于AVL平衡树的一种特殊形式</li>\n</ul>\n<h3>特征：</h3>\n<ul>\n<li>每个节点要么是红色，要么是黑色。</li>\n<li>根节点是黑色。</li>\n<li>每个叶子节点（NIL）是黑色。</li>\n<li>如果一个节点是红色，则其两个子节点必须是黑色。</li>\n<li>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li>\n</ul>\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a6a9500ae0b135906603b4e8008e51b5.png" width="60%">',readingTime:{minutes:1.23,words:368},title:"4.红黑树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/5.%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91.html",{loader:()=>a.e(43925).then(a.bind(a,64742)),meta:{author:"Navyum",date:175017201e4,localizedDate:"2025年6月17日",category:["数据结构"],tag:["多路查找树"],sticky:!1,excerpt:'<h2>多路查找树</h2>\n<ul>\n<li>2-3树</li>\n<li>2-3-4树</li>\n<li>B树</li>\n<li>B+树</li>\n</ul>\n<h3>多叉树：</h3>\n<ul>\n<li>树的每个节点可以有超过2个子节点</li>\n<li>举例：2-3树、2-3-4树、B树、B+树</li>\n</ul>\n<h3>概念：</h3>\n<ul>\n<li><code>阶数(Order)</code>，对于一颗<code>M阶</code>B树，一个节点最多包含M个子节点</li>\n</ul>\n<h3>B树(<code>Balanced Tree</code>)：</h3>\n<ul>\n<li>B树是多路平衡查找树的一种特殊类型</li>\n<li>B 是Balance的意思</li>\n<li><code>M阶</code>B树 特点：\n<ul>\n<li>每个节点最多包含<code>M</code>个子节点。</li>\n<li>根节点至少包含 <code>2</code> 个子节点（或者0个子节点）</li>\n<li>每个非叶节点至少包含 <code>ceil(M/2)</code> 个子节点；</li>\n<li>拥有 k 个子节点的非叶节点将包含 k - 1 条记录</li>\n<li><span style="color: rgb(255, 41, 65);"><code>所有叶节点都在同一层中</code></span></li>\n</ul>\n</li>\n<li>B树的优点：\n<ul>\n<li>相对平衡二叉树，节点的空间的利用率更高</li>\n<li>对<code>访问局部性原理</code>的利用(预读机制)</li>\n</ul>\n</li>\n<li>B树缺点：\n<ul>\n<li>查询范围数据时，必须按照树的中顺遍历来访问各个节点\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/96037820ce236cf9f0b130a823eda857.png" width="60%"></li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:2.44,words:733},title:"5.多路查找树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/6.%E5%A0%86.html",{loader:()=>a.e(10429).then(a.bind(a,11765)),meta:{author:"Navyum",date:1750172031e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["堆","Heap"],sticky:!1,excerpt:'<h2>堆</h2>\n<ul>\n<li>定义：完全二叉树的一种特定应用</li>\n</ul>\n<h3>特征：</h3>\n<ul>\n<li>最底层节点靠左填充，其他层的节点都被填满（完全二叉树特性）。</li>\n<li>根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。</li>\n<li>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的。</li>\n</ul>\n<h3>堆分类：</h3>\n<ul>\n<li>小顶堆：任意节点的值<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span>其子节点的值</li>\n<li>大顶堆：任意节点的值<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span>其子节点的值\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6fbb6824c45bf70b780807aff9825567.png" width="60%"></li>\n</ul>',readingTime:{minutes:2.11,words:632},title:"6.堆",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/0.%E5%9B%BE.html",{loader:()=>a.e(80543).then(a.bind(a,57850)),meta:{author:"Navyum",date:1750172051e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["图","Graph"],sticky:!1,excerpt:"<h2>图</h2>\n<ul>\n<li>定义：\n<ul>\n<li>图（graph）是一种非线性数据结构，由顶点（vertex）和边（edge）组成。</li>\n<li>我们可以将图<code>G</code>抽象地表示为一组顶点<code>V</code>和一组边<code>E</code>的集合\n<ul>\n<li><code>G = { V , E}</code></li>\n<li><code>V = {1,2,3,4,5}</code></li>\n<li><code>E = {(1,2),(2,3),(2,4),(3,5)}</code></li>\n</ul>\n</li>\n<li>图代表的是网络关系，自由度更高</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:1.1,words:330},title:"0.图",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/1.%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html",{loader:()=>a.e(49134).then(a.bind(a,85428)),meta:{author:"Navyum",date:1750172065e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["图的存储"],sticky:!1,excerpt:'<h2>图的表示方式：</h2>\n<ul>\n<li>邻接矩阵</li>\n<li>邻接表</li>\n</ul>\n<h3>邻接矩阵</h3>\n<ul>\n<li>\n<p>定义：</p>\n<ul>\n<li>设图的顶点数量为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，<u>邻接矩阵（adjacency matrix）</u>使用一个 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 或 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示两个顶点之间是否存在边。</li>\n</ul>\n</li>\n<li>\n<p>图解：</p>\n<ul>\n<li>设邻接矩阵为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>、顶点列表为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> ，那么矩阵元素 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M[i, j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 表示顶点 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 到顶点 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 之间存在边，反之 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M[i, j] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示两顶点之间无边。\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/087a045aeee8ef7173198dc328b89462.png" width="60%"></li>\n</ul>\n</li>\n<li>\n<p>特性：</p>\n<ul>\n<li>顶点不能与自身相连 （因此邻接矩阵主对角线元素没有意义）</li>\n<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li>\n<li>将邻接矩阵的元素从 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 替换为权重，则可表示有权图。</li>\n</ul>\n</li>\n<li>\n<p>优缺点：</p>\n<ul>\n<li>可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</li>\n<li>矩阵的空间复杂度为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，内存占用较多。</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:2.35,words:705},title:"1.图的存储",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/2.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.html",{loader:()=>a.e(23612).then(a.bind(a,47357)),meta:{author:"Navyum",date:1750172078e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["拓扑排序"],sticky:!1,excerpt:"<h2>拓扑排序</h2>\n",readingTime:{minutes:.13,words:39},title:"2.拓扑排序",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/3.%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html",{loader:()=>a.e(6408).then(a.bind(a,17380)),meta:{author:"Navyum",date:1750172095e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["关键路径"],sticky:!1,excerpt:"\n",readingTime:{minutes:.13,words:39},title:"3.关键路径",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/4.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html",{loader:()=>a.e(90945).then(a.bind(a,38429)),meta:{author:"Navyum",date:1750172106e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["最短路径"],sticky:!1,excerpt:"<h2>最短路径</h2>\n",readingTime:{minutes:.13,words:39},title:"4.最短路径",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/5.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html",{loader:()=>a.e(25395).then(a.bind(a,93319)),meta:{author:"Navyum",date:1750172119e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["最小生成树"],sticky:!1,excerpt:"<h2>最小生成树</h2>\n",readingTime:{minutes:.14,words:42},title:"5.最小生成树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(9801).then(a.bind(a,44355)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.02,words:5},title:"分治算法.md",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html",{loader:()=>a.e(94851).then(a.bind(a,51682)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.02,words:5},title:"动态规划.md",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(66005).then(a.bind(a,27407)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.02,words:5},title:"回溯算法.md",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(11050).then(a.bind(a,45274)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.02,words:5},title:"枚举算法.md",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(43941).then(a.bind(a,4780)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.02,words:5},title:"贪心算法.md",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/1.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html",{loader:()=>a.e(50601).then(a.bind(a,33789)),meta:{author:"Navyum",date:1750172175e3,localizedDate:"2025年6月17日",category:["数据结构"],tag:["复杂度分析"],sticky:!1,excerpt:'<h2>复杂度分析：</h2>\n<ul>\n<li>\n<p>渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>\n</li>\n<li>\n<p>定义：</p>\n<ul>\n<li>复杂度分析能够体现算法运行所需的<code>时间和空间资源</code>与<code>输入数量级之间</code>的关系；</li>\n<li>它描述了随着输入数据量级的增加，算法执行所需时间和空间的<span style="color: rgb(255, 41, 65);">增长趋势</span>。</li>\n</ul>\n</li>\n<li>\n<p>复杂度分析的三个重点：</p>\n<ul>\n<li>时间和空间资源：分别对应时间复杂度、空间复杂度</li>\n<li>随着输入数据大小的增加：意味着复杂度反映算法运行效率与输入数据体量之间的关系</li>\n<li>时间和空间的增长趋势：表示复杂度分析关注的不是运行时间或占用空间的具体值，而是<code>时间或空间增长的“快慢”</code>。</li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:6.54,words:1961},title:"复杂度分析",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(55924).then(a.bind(a,56401)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","排序算法"],tag:["排序算法"],sticky:!0,excerpt:'<h2>排序算法</h2>\n<ul>\n<li>定义：\n<ul>\n<li>排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。</li>\n<li>通过排序算法得到有序数据，通常能够被更高效地查找、分析和处理。</li>\n</ul>\n</li>\n</ul>\n<h3>排序算法评价维度：</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">维度</th>\n<th style="text-align:left">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">运行效率</td>\n<td style="text-align:left">时间复杂度尽量低、操作尽量少</td>\n</tr>\n<tr>\n<td style="text-align:left">就地性</td>\n<td style="text-align:left">在原数组上直接操作实现排序，无须借助额外的辅助数组</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>稳定性</code></td>\n<td style="text-align:left">排序后`相等元素在数组中的相对顺序不发生改变</td>\n</tr>\n<tr>\n<td style="text-align:left">自适应性</td>\n<td style="text-align:left">自适应排序的时间复杂度会受输入数据的影响（最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等）</td>\n</tr>\n<tr>\n<td style="text-align:left">是否基于比较</td>\n<td style="text-align:left">基于比较的排序依赖比较运算符（<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mo>=</mo><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;=&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;=&gt;</span></span></span></span>）来判断元素的相对顺序从而进行排序，理论最优时间复杂度为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br> 非比较排序不使用比较运算符，时间复杂度可达 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，但其通用性相对较差。</td>\n</tr>\n</tbody>\n</table>',readingTime:{minutes:1.72,words:515},title:"排序算法",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/0.%E6%90%9C%E7%B4%A2.html",{loader:()=>a.e(33731).then(a.bind(a,30524)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","搜索算法"],tag:["算法","搜索算法"],sticky:!0,excerpt:'<h2>搜索</h2>\n<ul>\n<li>定义：\n<ul>\n<li>搜索算法（searching algorithm）用于在数据结构（例如数组、链表、树或图）中搜索一个或一组满足特定条件的元素</li>\n</ul>\n</li>\n</ul>\n<h3>分类：</h3>\n<ul>\n<li>暴力搜索</li>\n<li>自适应搜索</li>\n</ul>\n<h3>暴力搜索：</h3>\n<ul>\n<li>思路：<code>遍历</code>数据结构的每个元素</li>\n<li>遍历策略：\n<ul>\n<li>线性搜索：适用于数组和链表</li>\n<li><code>广度、深度优先搜索</code>：适用于树和图</li>\n</ul>\n</li>\n<li>优缺点：\n<ul>\n<li>优点：简单且通用性好，无须对数据做预处理和借助额外的数据结构</li>\n<li>缺点：时间复杂度为<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>\n</ul>\n</li>\n</ul>',readingTime:{minutes:1.28,words:383},title:"0.搜索",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",{loader:()=>a.e(62629).then(a.bind(a,64108)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","搜索算法"],tag:["算法","二分查找"],sticky:!0,excerpt:'<h2>二分查找</h2>\n<h3>定义：</h3>\n<ul>\n<li>二分查找（binary search）是一种基于分治策略的高效搜索算法。</li>\n<li>它利用数据的<code>有序性</code>，<code>每轮缩小一半搜索范围</code>，直至找到目标元素或搜索区间为空为止。</li>\n</ul>\n<h3>具体操作：</h3>\n<ol>\n<li>先初始化指针 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 和 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，分别指向数组首元素和尾元素，代表搜索区间 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>\n<li>计算中点索引 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">⌊</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">m = \\lfloor {(i + j) / 2} \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">/2</span></span><span class="mclose">⌋</span></span></span></span> （其中 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mtext> </mtext><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\\lfloor \\: \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mclose">⌋</span></span></span></span> 表示向下取整操作）</li>\n<li>判断 <code>nums[m]</code> 和 <code>target</code> 的大小关系，分为以下三种情况：\n<ol>\n<li>当 <code>nums[m] &lt; target</code> 时，说明 <code>target</code> 在区间 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中，因此执行 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li>\n<li>当 <code>nums[m] &gt; target</code> 时，说明 <code>target</code> 在区间 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, m - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中，因此执行 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j = m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li>\n<li>当 <code>nums[m] = target</code> 时，说明找到 <code>target</code> ，因此返回索引 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 。</li>\n</ol>\n</li>\n<li>重复2、3步骤，一直未找到元素，则搜索区间缩小为空。此时返回 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。</li>\n<li>注意项：由于 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 都是 <code>int</code> 类型，<strong>因此 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 可能会超出 <code>int</code> 类型的取值范围</strong>。为了避免大数越界，我们通常采用公式 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">⌊</mo><mrow><mi>i</mi><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">m = \\lfloor {i + (j - i) / 2} \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord">/2</span></span><span class="mclose">⌋</span></span></span></span> 来计算中点</li>\n</ol>',readingTime:{minutes:4.69,words:1408},title:"1.二分查找",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/2.%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE.html",{loader:()=>a.e(50359).then(a.bind(a,92042)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","搜索算法"],tag:["算法","遍历算法","深度优先","广度优先"],sticky:!0,excerpt:'<h2>作用：</h2>\n<ul>\n<li>用于树、图的遍历</li>\n</ul>\n<h2>广度优先：</h2>\n<ul>\n<li>广度优先遍历通常借助<code>队列</code>来实现。队列遵循<code>先进先出</code>的规则，而广度优先遍历则遵循<code>逐层推进</code>的规则</li>\n<li>代码实现（树）：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 层序遍历 */</span></span>\n<span class="line"><span>func levelOrder(root *TreeNode) []any {</span></span>\n<span class="line"><span>    // 初始化队列，加入根节点</span></span>\n<span class="line"><span>    queue := list.New()</span></span>\n<span class="line"><span>    queue.PushBack(root)</span></span>\n<span class="line"><span>    // 初始化一个切片，用于保存遍历序列</span></span>\n<span class="line"><span>    nums := make([]any, 0)</span></span>\n<span class="line"><span>    for queue.Len() &gt; 0 {</span></span>\n<span class="line"><span>        // 队列出队</span></span>\n<span class="line"><span>        node := queue.Remove(queue.Front()).(*TreeNode)</span></span>\n<span class="line"><span>        // 保存节点值</span></span>\n<span class="line"><span>        nums = append(nums, node.Val)</span></span>\n<span class="line"><span>        if node.Left != nil {</span></span>\n<span class="line"><span>            // 左子节点入队</span></span>\n<span class="line"><span>            queue.PushBack(node.Left)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if node.Right != nil {</span></span>\n<span class="line"><span>            // 右子节点入队</span></span>\n<span class="line"><span>            queue.PushBack(node.Right)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    return nums</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:1.53,words:458},title:"2.遍历查找",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/3.%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE.html",{loader:()=>a.e(56782).then(a.bind(a,45339)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","搜索算法"],tag:["算法","搜索树"],sticky:!0,excerpt:"<h2>搜索树查找</h2>\n<ul>\n<li>直接使用搜索树的节点有序、节点大小关系等特性</li>\n<li>本质思想根二分查找一致，通过有序的先验条件，快速排除1/2、1/M的节点，M为树的阶数</li>\n</ul>\n<h2>过程：</h2>\n<ul>\n<li>基于搜索树搜索：\n<ul>\n<li>二叉搜索树：比较target和节点值大小；小于节点，继续找左子树，大于节点，继续找右子树；相等则找到，或者访问到叶子节点也未找到。</li>\n<li>B树：比较target和节点值大小；根据值所在区间，到对应子树继续查找；如果节点中有根target相等，则可以在该节点找到target信息，或者访问到叶子节点也未找到。</li>\n<li>B+树：比较非叶子节点和target，根据值所在区间，到对应子树继续查找；因为只有叶子节点存数据，一直要找到叶子节点，才能找到target的具体信息</li>\n</ul>\n</li>\n</ul>",readingTime:{minutes:.92,words:277},title:"3.搜索树查找",order:-1,type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/AC%E8%87%AA%E5%8A%A8%E6%9C%BA.html",{loader:()=>a.e(17638).then(a.bind(a,14640)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.01,words:4},title:"AC自动机",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/KMP.html",{loader:()=>a.e(34966).then(a.bind(a,38545)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:0,words:1},title:"KMP",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/LSM-Tree.html",{loader:()=>a.e(98823).then(a.bind(a,64149)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.01,words:2},title:"LSM-Tree",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/Tier%E6%A0%91.html",{loader:()=>a.e(93585).then(a.bind(a,62453)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.01,words:2},title:"Tier树",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/%E6%9C%B4%E7%B4%A0.html",{loader:()=>a.e(90228).then(a.bind(a,86036)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.01,words:2},title:"朴素",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90.html",{loader:()=>a.e(50455).then(a.bind(a,85556)),meta:{date:1749983452e3,excerpt:"\n",readingTime:{minutes:.01,words:4},title:"概率分析",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.html",{loader:()=>a.e(96962).then(a.bind(a,21950)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法"],tag:["递归算法"],sticky:!0,excerpt:'<h3>一、什么是递归？</h3>\n<p>利用了函数栈实现</p>\n<ol>\n<li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li>\n<li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li>\n<li>基本上，所有的递归问题都可以用递推公式来表示，比如</li>\n</ol>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    f(n) = f(n-1) + 1; </span></span>\n<span class="line"><span>    f(n) = f(n-1) + f(n-2);</span></span>\n<span class="line"><span>    f(n) = n*f(n-1);</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',readingTime:{minutes:2.38,words:714},title:"递归",order:-1,type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9D%99%E6%80%81%E6%97%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%AD%E8%A8%80%EF%BC%89.html",{loader:()=>a.e(75699).then(a.bind(a,49872)),meta:{author:"Navyum",date:1750677538e3,localizedDate:"2025年6月23日",category:["golang"],tag:["golang"],sticky:!1,excerpt:'<ol>\n<li>\n<p>“业务逻辑”和“控制逻辑”分离解耦的编程模式\na. 反转控制：  开关和各种电器，不是将开关放在电器中，而是将开关抽象出来，由电器依赖开关，这样实现开关模块的独立和复用。\nb. map、redunce、filter\nc. reflect\nd. 目前go 的泛型编程基于interface</p>\n</li>\n<li>\n<p>修饰器编程模式</p>\n</li>\n<li>\n<p>编程范式：过程式编程procedural、函数式编程functional、面向对象编程object-oriented</p>\n</li>\n<li>\n<p>c语言特征：</p>\n<ul>\n<li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li>\n<li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li>\n<li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li>\n<li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li>\n<li>C 语言传递参数一般是以值传递，也可以传递指针；</li>\n<li>通过指针，C 语言可以容易地对内存进行低级控制，然而这加大了编程复杂度；</li>\n<li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li>\n</ul>\n</li>\n<li>\n<p>C 语言的伟大之处\n使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制</p>\n</li>\n<li>\n<p>c语言设计理念：</p>\n<ul>\n<li>相信程序员；</li>\n<li>不会阻止程序员做任何底层的事；</li>\n<li>保持语言的最小和最简的特性；</li>\n<li>保证 C 语言的最快的运行速度，那怕牺牲移值性。</li>\n</ul>\n</li>\n<li>\n<p>程序语言的类型系统提供的能力：</p>\n<ul>\n<li>程序语言的安全性</li>\n<li>利于编译器的优化（字节对齐、机器指令更高效）</li>\n<li>代码的可读性（函数、接口的定义更清晰）</li>\n<li>抽象化</li>\n<li>带来的问题：类型的多态（类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。）</li>\n<li>类型的定义：类型是对底层内存布局的一个抽象，不同的类型，会有不同的内存布局和内存分配的策略。不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li>\n</ul>\n</li>\n<li>\n<p>类型的检查：</p>\n<ul>\n<li>静态类型检查:  是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型(go)，反之称为弱类型(c)。</li>\n<li>动态类型检查: 系统更多的是在运行时期做动态类型标记和相关检查(检查工作交给程序员)。所以，动态类型的语言必然要给出一堆诸如：is_array(), is_int(), is_string() 或是 typeof() 这样的运行时类型检查函数。</li>\n</ul>\n</li>\n<li>\n<p>泛型的标准：</p>\n<ol>\n<li>标准化掉类型的内存分配、释放和访问。</li>\n<li>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……</li>\n<li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li>\n<li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li>\n</ol>\n</li>\n<li>\n<p>实现泛型的方式：</p>\n<ol>\n<li>通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。</li>\n<li>通过重载操作符，可以标准化类型的比较等操作。</li>\n<li>通过 iostream，标准化了类型的输入、输出控制。</li>\n<li>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。</li>\n<li>通过迭代器来标准化数据容器的遍历操作。</li>\n<li>通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。</li>\n<li>通过函数式（函数对象），来标准化对于不同类型的特定操作。</li>\n</ol>\n</li>\n<li>\n<p>泛型编程的理解：\n屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型</p>\n</li>\n<li>\n<p>函数式编程：\n核心： map、reduce、filter，pipline模式，decorator模式。\nDecorator 这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像 for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）</p>\n</li>\n<li>\n<p>编程的本质\n1. Programs = Algorithms + Data Structures\n2. Algorithm = Logic + Control\n有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</p>\n<p>绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。</p>\n</li>\n<li>\n<p>go 语言资料：<br>\n<a href="https://time.geekbang.org/column/article/8701" target="_blank" rel="noopener noreferrer">https://time.geekbang.org/column/article/8701</a>\n<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener noreferrer">https://github.com/avelino/awesome-go</a></p>\n</li>\n</ol>',readingTime:{minutes:4.73,words:1420},title:"go学习笔记（强类型的静态无虚拟机语言）",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/go%E6%80%BB%E7%BB%93.html",{loader:()=>a.e(40736).then(a.bind(a,31861)),meta:{date:1749983452e3,excerpt:"\n<p>基于混合线程的并发编程模型自然不必多说</p>\n<h1>在数据类型方面有：</h1>\n<ul>\n<li>基于底层数组的切片；</li>\n<li>用来传递数据的通道；</li>\n<li>作为一等类型的函数；</li>\n<li>可实现面向对象的结构体；</li>\n<li>能无侵入实现的接口等。</li>\n</ul>\n<h1>在语法方面有：</h1>\n<ul>\n<li>异步编程神器go语句；</li>\n<li>函数的最后关卡defer语句；</li>\n<li>可做类型判断的switch语句；</li>\n<li>多通道操作利器select语句；</li>\n<li>非常有特色的异常处理函数panic和recover。</li>\n</ul>",readingTime:{minutes:1.01,words:302},title:"Go 语言经典知识总结",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/context.html",{loader:()=>a.e(96086).then(a.bind(a,55818)),meta:{author:"navyum",date:1750544975e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<ol>\n<li>作用：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能</li>\n<li>context 使用注意事项：\n<ol>\n<li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li>\n<li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li>\n<li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li>\n<li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li>\n</ol>\n</li>\n<li>相关函数：\n这些函数都是幂等的，也就是说连续多次调用同一个方法，得到的结果都是相同的</li>\n</ol>",readingTime:{minutes:2.27,words:681},title:"context",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect.html",{loader:()=>a.e(36596).then(a.bind(a,38502)),meta:{date:1749983452e3,title:"",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/unsafe.html",{loader:()=>a.e(76007).then(a.bind(a,86182)),meta:{date:1749983452e3,title:"",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html",{loader:()=>a.e(37541).then(a.bind(a,89624)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","排序算法"],tag:["桶排序","计数排序","基数排序"],sticky:!0,excerpt:'<h2>计数、桶、基数</h2>\n<h3>桶排序（Bucket Sort）：</h3>\n<ul>\n<li>\n<p><u>思想：它通过设置一些具有有限数量、大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并</u></p>\n</li>\n<li>\n<p>稳定排序、非原地排序，需要借助k个桶和n个元素的数组</p>\n</li>\n<li>\n<p><span style="color: rgb(255, 41, 65);"> 非比较排序算法 </span></p>\n</li>\n<li>\n<p>算法流程：条件 一个长度为 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数组，其元素是范围 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 内的浮点数</p>\n<ol>\n<li>初始化 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个桶，将 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素分配到 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个桶中。</li>\n<li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li>\n<li>按照桶从小到大的顺序合并结果。</li>\n</ol>\n</li>\n<li>\n<p>桶排序的优化：</p>\n<ul>\n<li>将元素均匀分配到各个桶中，时间复杂度趋近于<span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。可以借助值的概率分布。\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/9b5e1ed580a44cb933621d58303cc112.png" alt="Img" loading="lazy"></li>\n</ul>\n</li>\n<li>\n<p>图解：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e071c5a7c5c6f087fb9dc231bda365b9.png" alt="Img" loading="lazy"></p>\n</li>\n<li>\n<p>代码：</p>\n<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 桶排序 */</span></span>\n<span class="line"><span>func bucketSort(nums []float64) {</span></span>\n<span class="line"><span>    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span>\n<span class="line"><span>    k := len(nums) / 2</span></span>\n<span class="line"><span>    buckets := make([][]float64, k)</span></span>\n<span class="line"><span>    for i := 0; i &lt; k; i++ {</span></span>\n<span class="line"><span>        buckets[i] = make([]float64, 0)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 1. 将数组元素分配到各个桶中</span></span>\n<span class="line"><span>    for _, num := range nums {</span></span>\n<span class="line"><span>        // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span>\n<span class="line"><span>        i := int(num * float64(k))</span></span>\n<span class="line"><span>        // 将 num 添加进桶 i</span></span>\n<span class="line"><span>        buckets[i] = append(buckets[i], num)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 2. 对各个桶执行排序</span></span>\n<span class="line"><span>    for i := 0; i &lt; k; i++ {</span></span>\n<span class="line"><span>        // 使用内置切片排序函数，也可以替换成其他排序算法</span></span>\n<span class="line"><span>        sort.Float64s(buckets[i])</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 3. 遍历桶合并结果</span></span>\n<span class="line"><span>    i := 0</span></span>\n<span class="line"><span>    for _, bucket := range buckets {</span></span>\n<span class="line"><span>        for _, num := range bucket {</span></span>\n<span class="line"><span>            nums[i] = num</span></span>\n<span class="line"><span>            i++</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:5.83,words:1748},title:"桶、计数、基数",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html",{loader:()=>a.e(65891).then(a.bind(a,35639)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法","排序算法"],tag:["冒泡","插入","选择"],sticky:!0,excerpt:'<h2>冒泡、选择、插入</h2>\n<h3>冒泡排序（Bubble Sort）：</h3>\n<ul>\n<li><u>思想：比较相邻的元素，如果前一个元素比后一个元素大，就交换它们的位置，重复进行直到整个数组排序完成。</u></li>\n<li>稳定排序，在“冒泡”中遇到相等元素不交换</li>\n<li>算法流程：\n<ol>\n<li>首先，对 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>。</li>\n<li>接下来，对剩余 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>\n<li>以此类推，经过 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮“冒泡”后，<strong>前 <span v-pre="" class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 大的元素都被交换至正确位置</strong>。</li>\n<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>\n</ol>\n</li>\n<li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 冒泡排序 */ </span></span>\n<span class="line"><span>func bubbleSort(nums []int) {</span></span>\n<span class="line"><span>    // 外循环：未排序区间为 [0, i]</span></span>\n<span class="line"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\n<span class="line"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\n<span class="line"><span>        for j := 0; j &lt; i; j++ {</span></span>\n<span class="line"><span>            if nums[j] &gt; nums[j+1] {</span></span>\n<span class="line"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\n<span class="line"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 冒泡排序（标志优化）当数组有序时，将不会发生交换，可以直接中断 */</span></span>\n<span class="line"><span>func bubbleSortWithFlag(nums []int) {</span></span>\n<span class="line"><span>    // 外循环：未排序区间为 [0, i]</span></span>\n<span class="line"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\n<span class="line"><span>        flag := false // 初始化标志位</span></span>\n<span class="line"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\n<span class="line"><span>        for j := 0; j &lt; i; j++ {</span></span>\n<span class="line"><span>            if nums[j] &gt; nums[j+1] {</span></span>\n<span class="line"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\n<span class="line"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\n<span class="line"><span>                flag = true // 记录交换元素</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if flag == false { // 此轮“冒泡”未交换任何元素，直接跳出</span></span>\n<span class="line"><span>            break</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:3.84,words:1153},title:"冒泡、插入、选择",type:"article"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(nlogn)/%E5%BF%AB%E9%80%9F%E3%80%81%E5%BD%92%E5%B9%B6%E3%80%81%E5%A0%86%E3%80%81%E5%B8%8C%E5%B0%94.html",{loader:()=>a.e(38061).then(a.bind(a,50987)),meta:{author:"navyum",date:17499456e5,localizedDate:"2025年6月15日",category:["算法"],tag:["快速","归并","堆","希尔"],sticky:!0,excerpt:'<h2>快速、归并、堆、希尔</h2>\n<h3>快速排序（Quick Sort）：</h3>\n<ul>\n<li>\n<p><u>思想：快速排序的核心操作是“哨兵划分”。选取一个基准元素作为哨兵，将数组分为比基准元素小和比基准元素大的两个部分，对这两个部分分别进行快速排序，重复进行直到整个数组排序完成。</u></p>\n</li>\n<li>\n<p><span style="color: rgb(255, 41, 65);">不稳定排序</span></p>\n</li>\n<li>\n<p>算法流程：</p>\n<ol>\n<li>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li>\n<li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li>\n<li>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</li>\n</ol>\n</li>\n<li>\n<p>图解：\n<img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/36c35425526d1e6b7ba4ab42a12a7603.png" alt="Img" loading="lazy"></p>\n</li>\n<li>\n<p>代码：</p>\n<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 哨兵划分 */</span></span>\n<span class="line"><span>func (q *quickSort) partition(nums []int, left, right int) int {</span></span>\n<span class="line"><span>    // 以 nums[left] 为基准数</span></span>\n<span class="line"><span>    i, j := left, right</span></span>\n<span class="line"><span>    for i &lt; j {</span></span>\n<span class="line"><span>        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {</span></span>\n<span class="line"><span>            j-- // 从右向左找首个小于基准数的元素</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {</span></span>\n<span class="line"><span>            i++ // 从左向右找首个大于基准数的元素</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 元素交换</span></span>\n<span class="line"><span>        nums[i], nums[j] = nums[j], nums[i]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 将基准数交换至两子数组的分界线</span></span>\n<span class="line"><span>    nums[i], nums[left] = nums[left], nums[i]</span></span>\n<span class="line"><span>    return i // 返回基准数的索引</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 快速排序 */</span></span>\n<span class="line"><span>func (q *quickSort) quickSort(nums []int, left, right int) {</span></span>\n<span class="line"><span>    // 子数组长度为 1 时终止递归</span></span>\n<span class="line"><span>    if left &gt;= right {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 哨兵划分</span></span>\n<span class="line"><span>    pivot := q.partition(nums, left, right)</span></span>\n<span class="line"><span>    // 递归左子数组、右子数组</span></span>\n<span class="line"><span>    q.quickSort(nums, left, pivot-1)</span></span>\n<span class="line"><span>    q.quickSort(nums, pivot+1, right)</span></span>\n<span class="line"><span>}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>\n</ul>',readingTime:{minutes:5.22,words:1566},title:"快速、归并、堆、希尔",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Cond.html",{loader:()=>a.e(93082).then(a.bind(a,19255)),meta:{author:"navyum",date:1750544933e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>条件变量定义：</p>\n<pre><code>当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，只要等待通知就好了。\n\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的\n\n方法：等待通知（wait）、单发通知（signal）和广播通知（broadcast）\n</code></pre>\n<p>规则：</p>\n<pre><code>利用条件变量可以实现单向的通知，而双向的通知则需要两个条件变量。这也是条件变量的基本使用规则。\n</code></pre>\n<p>Wait： wait方法总会把当前的 goroutine 添加到通知队列的队尾</p>\n<p>Signal： signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。这两个方法的行为决定了它们的适用场景。如果你确定只有一个 goroutine 在等待通知，或者只需唤醒任意一个 goroutine 就可以满足要求，那么使用条件变量的Signal方法就好了。</p>",readingTime:{minutes:1.99,words:598},title:"sync.Cond",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Mutext%E3%80%81sync.RWMutex.html",{loader:()=>a.e(15179).then(a.bind(a,6378)),meta:{author:"navyum",date:175054494e4,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>Mutex定义：</p>\n<pre><code>互斥锁看作是针对某一个临界区或某一组相关临界区的唯一访问令牌\n\n互斥锁一个结构体类型，属于值类型中的一种.\n</code></pre>\n<p>互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）</p>\n<p>Mutex使用注意事项:</p>\n<ul>\n<li>不要重复锁定互斥锁；</li>\n<li>不要忘记解锁互斥锁，必要时使用defer语句；</li>\n<li>不要对尚未锁定或者已解锁的互斥锁解锁；</li>\n<li>不要在多个函数之间直接传递互斥锁。\n对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到该互斥锁的Unlock方法被调用</li>\n</ul>",readingTime:{minutes:2.48,words:745},title:"sync.Mutext、sync.RWMutex",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.WaitGroup%E3%80%81sync.Once.html",{loader:()=>a.e(19703).then(a.bind(a,57848)),meta:{author:"navyum",date:1750544963e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>Once同时使用了原子操作和互斥锁，原子操作操作done的值，互斥锁用来锁定临界区代码（如果是对代码块进行保护，还需要用锁）</p>\n<p>Once过程：</p>\n<p>Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的Once值的Do方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为false，而继续执行Do方法中剩余的代码。在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。如果你熟悉 GoF 设计模式中的单例模式的话，那么肯定能看出来，这个Do方法的实现方式，与那个单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为“快路径”，或者叫做“快速失败路径”。如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）“双重检查”。由于进入临界区之前，肯定要锁定保护它的互斥锁m，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为“慢路径”或者“常规路径”</p>",readingTime:{minutes:2.4,words:721},title:"sync.WaitGroup、sync.Once",type:"article"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync/atomic.html",{loader:()=>a.e(96136).then(a.bind(a,37227)),meta:{author:"navyum",date:1750544918e3,localizedDate:"2025年6月21日",category:["笔记"],tag:["笔记"],sticky:!1,excerpt:"<p>互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）</p>\n<p>在众多的同步工具中，真正能够保证原子性执行的只有原子操作</p>\n<p>原子操作在进行的过程中是不允许中断的，这个特性由底层CPU提供芯片级别的支持</p>\n<p>原子操作支持的类型：</p>\n<p>数据类型有：</p>\n<p>int32、int64、uint32、uint64、uintptr</p>\n<p>unsafe包中的Pointer以及 Value的类型（它可以被用来存储任意类型的值）</p>\n<p>原子操作支持的方法：</p>\n<p>加法（add）</p>\n<p>比较并交换（compare and swap，简称 CAS）</p>",readingTime:{minutes:.85,words:256},title:"atomic",type:"article"}}],["/404.html",{loader:()=>a.e(27490).then(a.bind(a,53930)),meta:{title:""}}],["/posts/",{loader:()=>a.e(18666).then(a.bind(a,86615)),meta:{title:"Posts"}}],["/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/",{loader:()=>a.e(44383).then(a.bind(a,21506)),meta:{title:"个人思考"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/",{loader:()=>a.e(81438).then(a.bind(a,79289)),meta:{title:"工具武器库"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/",{loader:()=>a.e(67358).then(a.bind(a,60103)),meta:{title:"常用软件"}}],["/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/",{loader:()=>a.e(7060).then(a.bind(a,42879)),meta:{title:"我的世界"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/",{loader:()=>a.e(4e3).then(a.bind(a,45162)),meta:{title:"架构设计"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{loader:()=>a.e(18334).then(a.bind(a,93826)),meta:{title:"算法数据结构"}}],["/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/",{loader:()=>a.e(74181).then(a.bind(a,63923)),meta:{title:"面试经验"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/",{loader:()=>a.e(19191).then(a.bind(a,15924)),meta:{title:"00.概念"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/",{loader:()=>a.e(83955).then(a.bind(a,22032)),meta:{title:"大模型 LLM"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/01.%E6%A1%86%E6%9E%B6/",{loader:()=>a.e(8435).then(a.bind(a,72588)),meta:{title:"01.框架"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/02.RAG/",{loader:()=>a.e(31178).then(a.bind(a,1118)),meta:{title:"02. RAG"}}],["/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/04.%E5%BA%94%E7%94%A8/",{loader:()=>a.e(66254).then(a.bind(a,63773)),meta:{title:"04.应用"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/",{loader:()=>a.e(91032).then(a.bind(a,64785)),meta:{title:"网络抓包 Wireshark"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/",{loader:()=>a.e(83835).then(a.bind(a,27414)),meta:{title:"软件破解"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/",{loader:()=>a.e(39563).then(a.bind(a,14328)),meta:{title:"问题分析"}}],["/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%9D%99%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFGDB/",{loader:()=>a.e(47502).then(a.bind(a,33580)),meta:{title:"静态追踪技术 GDB"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/",{loader:()=>a.e(30816).then(a.bind(a,54890)),meta:{title:"容器化"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/",{loader:()=>a.e(54150).then(a.bind(a,45462)),meta:{title:"数据库"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",{loader:()=>a.e(74208).then(a.bind(a,67407)),meta:{title:"消息队列"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/",{loader:()=>a.e(34411).then(a.bind(a,49484)),meta:{title:"02.分布式与架构"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/",{loader:()=>a.e(31339).then(a.bind(a,69193)),meta:{title:"03.中间件"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/",{loader:()=>a.e(53213).then(a.bind(a,24278)),meta:{title:"04. WEB框架"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/05.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%91%E5%8E%9F%E7%94%9F/",{loader:()=>a.e(89881).then(a.bind(a,94725)),meta:{title:"05.微服务云原生"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{loader:()=>a.e(12274).then(a.bind(a,11989)),meta:{title:"数据结构"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/",{loader:()=>a.e(41744).then(a.bind(a,92290)),meta:{title:"Golang"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/",{loader:()=>a.e(63061).then(a.bind(a,11758)),meta:{title:"编程语言"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/",{loader:()=>a.e(14653).then(a.bind(a,4364)),meta:{title:"分布式基建"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/zookeeper/",{loader:()=>a.e(39588).then(a.bind(a,79901)),meta:{title:"Zookeeper"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse/",{loader:()=>a.e(45975).then(a.bind(a,42995)),meta:{title:"Clickhouse"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticSearch/",{loader:()=>a.e(51026).then(a.bind(a,21081)),meta:{title:"Elastic Search"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/",{loader:()=>a.e(84715).then(a.bind(a,93707)),meta:{title:"Mysql"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/",{loader:()=>a.e(80018).then(a.bind(a,56075)),meta:{title:"Redis"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/",{loader:()=>a.e(13713).then(a.bind(a,63001)),meta:{title:"Kafka"}}],["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/",{loader:()=>a.e(80119).then(a.bind(a,25752)),meta:{title:"Rocketmq"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{loader:()=>a.e(73292).then(a.bind(a,97166)),meta:{title:"常见设计模式"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{loader:()=>a.e(80449).then(a.bind(a,33034)),meta:{title:"01.设计模式"}}],["/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/",{loader:()=>a.e(73560).then(a.bind(a,44619)),meta:{title:"01.弹性设计 高可用"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/",{loader:()=>a.e(44428).then(a.bind(a,86152)),meta:{title:"01.线性表"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/",{loader:()=>a.e(6575).then(a.bind(a,41799)),meta:{title:"02.哈希表"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/",{loader:()=>a.e(95167).then(a.bind(a,56533)),meta:{title:"03.树"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/",{loader:()=>a.e(27531).then(a.bind(a,69265)),meta:{title:"04.图"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/",{loader:()=>a.e(95528).then(a.bind(a,23393)),meta:{title:"0.基本思想"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/",{loader:()=>a.e(943).then(a.bind(a,34892)),meta:{title:"算法"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/1.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/",{loader:()=>a.e(39176).then(a.bind(a,59386)),meta:{title:"1.复杂度分析"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/",{loader:()=>a.e(89643).then(a.bind(a,34866)),meta:{title:"2.排序"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/",{loader:()=>a.e(76271).then(a.bind(a,81474)),meta:{title:"3.搜索"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/",{loader:()=>a.e(54914).then(a.bind(a,27322)),meta:{title:"5.字符串匹配"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/",{loader:()=>a.e(40444).then(a.bind(a,87575)),meta:{title:"6.其他"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/",{loader:()=>a.e(22886).then(a.bind(a,97918)),meta:{title:"学习资料汇总"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/",{loader:()=>a.e(63545).then(a.bind(a,95055)),meta:{title:"标准库"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/",{loader:()=>a.e(54004).then(a.bind(a,6513)),meta:{title:"O(n K)"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/",{loader:()=>a.e(15593).then(a.bind(a,3989)),meta:{title:"O(n 2)"}}],["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(nlogn)/",{loader:()=>a.e(63802).then(a.bind(a,50047)),meta:{title:"O(nlogn)"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/",{loader:()=>a.e(3973).then(a.bind(a,80960)),meta:{title:"Sync"}}],["/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync/",{loader:()=>a.e(91657).then(a.bind(a,17932)),meta:{title:"Sync"}}],["/category/",{loader:()=>a.e(23583).then(a.bind(a,27422)),meta:{title:"分类",index:!1}}],["/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>a.e(24021).then(a.bind(a,65264)),meta:{title:"使用指南 分类",index:!1}}],["/category/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/",{loader:()=>a.e(70656).then(a.bind(a,4883)),meta:{title:"个人思考 分类",index:!1}}],["/category/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/",{loader:()=>a.e(16516).then(a.bind(a,46968)),meta:{title:"职业规划 分类",index:!1}}],["/category/%E5%88%86%E5%B8%83%E5%BC%8F/",{loader:()=>a.e(57056).then(a.bind(a,86657)),meta:{title:"分布式 分类",index:!1}}],["/category/heif/",{loader:()=>a.e(26260).then(a.bind(a,6816)),meta:{title:"HEIF 分类",index:!1}}],["/category/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(93750).then(a.bind(a,46197)),meta:{title:"图片格式 分类",index:!1}}],["/category/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/",{loader:()=>a.e(52003).then(a.bind(a,71445)),meta:{title:"工具配置 分类",index:!1}}],["/category/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(38148).then(a.bind(a,41989)),meta:{title:"多媒体格式 分类",index:!1}}],["/category/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/",{loader:()=>a.e(10500).then(a.bind(a,7678)),meta:{title:"协议规范 分类",index:!1}}],["/category/electron/",{loader:()=>a.e(76782).then(a.bind(a,72409)),meta:{title:"Electron 分类",index:!1}}],["/category/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/",{loader:()=>a.e(95639).then(a.bind(a,39488)),meta:{title:"应用开发 分类",index:!1}}],["/category/%E5%8F%91%E5%B8%83%E9%83%A8%E7%BD%B2/",{loader:()=>a.e(44102).then(a.bind(a,39030)),meta:{title:"发布部署 分类",index:!1}}],["/category/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/",{loader:()=>a.e(12025).then(a.bind(a,61699)),meta:{title:"踩坑记录 分类",index:!1}}],["/category/%E7%BC%96%E7%A8%8B/",{loader:()=>a.e(88299).then(a.bind(a,65629)),meta:{title:"编程 分类",index:!1}}],["/category/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/",{loader:()=>a.e(88996).then(a.bind(a,13447)),meta:{title:"技术方案 分类",index:!1}}],["/category/ai%E6%90%9C%E7%B4%A2/",{loader:()=>a.e(30668).then(a.bind(a,84579)),meta:{title:"AI搜索 分类",index:!1}}],["/category/%E5%86%85%E5%AE%B9%E8%90%A5%E9%94%80/",{loader:()=>a.e(54143).then(a.bind(a,34321)),meta:{title:"内容营销 分类",index:!1}}],["/category/%E6%8F%92%E4%BB%B6/",{loader:()=>a.e(92940).then(a.bind(a,56707)),meta:{title:"插件 分类",index:!1}}],["/category/%E5%8D%9A%E5%AE%A2/",{loader:()=>a.e(21080).then(a.bind(a,6386)),meta:{title:"博客 分类",index:!1}}],["/category/%E5%81%A5%E8%BA%AB/",{loader:()=>a.e(39252).then(a.bind(a,4155)),meta:{title:"健身 分类",index:!1}}],["/category/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/",{loader:()=>a.e(38948).then(a.bind(a,32999)),meta:{title:"参考资料 分类",index:!1}}],["/category/%E7%AE%97%E6%B3%95/",{loader:()=>a.e(59544).then(a.bind(a,69399)),meta:{title:"算法 分类",index:!1}}],["/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{loader:()=>a.e(79641).then(a.bind(a,27617)),meta:{title:"数据结构 分类",index:!1}}],["/category/%E7%BD%91%E7%BB%9C/",{loader:()=>a.e(50953).then(a.bind(a,1961)),meta:{title:"网络 分类",index:!1}}],["/category/%E9%9D%A2%E8%AF%95/",{loader:()=>a.e(91673).then(a.bind(a,3850)),meta:{title:"面试 分类",index:!1}}],["/category/llm/",{loader:()=>a.e(47155).then(a.bind(a,24151)),meta:{title:"LLM 分类",index:!1}}],["/category/ai/",{loader:()=>a.e(5894).then(a.bind(a,68095)),meta:{title:"AI 分类",index:!1}}],["/category/%E5%B7%A5%E5%85%B7/",{loader:()=>a.e(7968).then(a.bind(a,28017)),meta:{title:"工具 分类",index:!1}}],["/category/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/",{loader:()=>a.e(38854).then(a.bind(a,31038)),meta:{title:"性能分析 分类",index:!1}}],["/category/flamegraph/",{loader:()=>a.e(52873).then(a.bind(a,19880)),meta:{title:"FlameGraph 分类",index:!1}}],["/category/%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91/",{loader:()=>a.e(94416).then(a.bind(a,49711)),meta:{title:"英文翻译 分类",index:!1}}],["/category/systemtap/",{loader:()=>a.e(28226).then(a.bind(a,62518)),meta:{title:"Systemtap 分类",index:!1}}],["/category/wireshark/",{loader:()=>a.e(15306).then(a.bind(a,2986)),meta:{title:"wireshark 分类",index:!1}}],["/category/%E5%8E%8B%E6%B5%8B/",{loader:()=>a.e(8038).then(a.bind(a,94545)),meta:{title:"压测 分类",index:!1}}],["/category/gdb/",{loader:()=>a.e(83935).then(a.bind(a,11390)),meta:{title:"GDB 分类",index:!1}}],["/category/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/",{loader:()=>a.e(28612).then(a.bind(a,87410)),meta:{title:"容器技术 分类",index:!1}}],["/category/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/",{loader:()=>a.e(91946).then(a.bind(a,47186)),meta:{title:"踩坑笔记 分类",index:!1}}],["/category/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/",{loader:()=>a.e(37549).then(a.bind(a,94491)),meta:{title:"常用软件 分类",index:!1}}],["/category/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",{loader:()=>a.e(47647).then(a.bind(a,44008)),meta:{title:"消息队列 分类",index:!1}}],["/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1/",{loader:()=>a.e(66968).then(a.bind(a,8594)),meta:{title:"微服务 分类",index:!1}}],["/category/golang/",{loader:()=>a.e(59746).then(a.bind(a,99333)),meta:{title:"golang 分类",index:!1}}],["/category/%E7%AC%94%E8%AE%B0/",{loader:()=>a.e(17632).then(a.bind(a,58384)),meta:{title:"笔记 分类",index:!1}}],["/category/java/",{loader:()=>a.e(68236).then(a.bind(a,96512)),meta:{title:"java 分类",index:!1}}],["/category/%E6%95%B0%E6%8D%AE%E5%BA%93/",{loader:()=>a.e(3863).then(a.bind(a,19852)),meta:{title:"数据库 分类",index:!1}}],["/category/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/",{loader:()=>a.e(55659).then(a.bind(a,20229)),meta:{title:"全文搜索 分类",index:!1}}],["/category/mysql/",{loader:()=>a.e(41006).then(a.bind(a,22041)),meta:{title:"Mysql 分类",index:!1}}],["/category/redis/",{loader:()=>a.e(30007).then(a.bind(a,79755)),meta:{title:"Redis 分类",index:!1}}],["/category/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/",{loader:()=>a.e(14175).then(a.bind(a,60280)),meta:{title:"架构设计 分类",index:!1}}],["/category/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",{loader:()=>a.e(39207).then(a.bind(a,30098)),meta:{title:"排序算法 分类",index:!1}}],["/category/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/",{loader:()=>a.e(52734).then(a.bind(a,94180)),meta:{title:"搜索算法 分类",index:!1}}],["/tag/",{loader:()=>a.e(1797).then(a.bind(a,56539)),meta:{title:"标签",index:!1}}],["/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",{loader:()=>a.e(50602).then(a.bind(a,11448)),meta:{title:"标签: 页面配置",index:!1}}],["/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>a.e(21431).then(a.bind(a,28412)),meta:{title:"标签: 使用指南",index:!1}}],["/tag/%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/",{loader:()=>a.e(91843).then(a.bind(a,387)),meta:{title:"标签: 事故复盘",index:!1}}],["/tag/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/",{loader:()=>a.e(71546).then(a.bind(a,39614)),meta:{title:"标签: 团队管理",index:!1}}],["/tag/%E7%A7%AF%E7%B4%AF/",{loader:()=>a.e(68684).then(a.bind(a,5806)),meta:{title:"标签: 积累",index:!1}}],["/tag/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/",{loader:()=>a.e(30026).then(a.bind(a,10765)),meta:{title:"标签: 职业规划",index:!1}}],["/tag/%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B/",{loader:()=>a.e(15058).then(a.bind(a,94263)),meta:{title:"标签: 个人能力",index:!1}}],["/tag/%E6%94%B9%E5%8F%98/",{loader:()=>a.e(79371).then(a.bind(a,80558)),meta:{title:"标签: 改变",index:!1}}],["/tag/%E4%B9%A0%E6%83%AF/",{loader:()=>a.e(60167).then(a.bind(a,88863)),meta:{title:"标签: 习惯",index:!1}}],["/tag/%E8%81%8C%E5%9C%BAppt/",{loader:()=>a.e(63624).then(a.bind(a,53895)),meta:{title:"标签: 职场PPT",index:!1}}],["/tag/ppt%E7%BE%8E%E5%8C%96/",{loader:()=>a.e(9170).then(a.bind(a,53130)),meta:{title:"标签: PPT美化",index:!1}}],["/tag/%E8%81%8C%E5%9C%BA/",{loader:()=>a.e(19336).then(a.bind(a,48152)),meta:{title:"标签: 职场",index:!1}}],["/tag/%E6%96%B9%E6%B3%95%E8%AE%BA/",{loader:()=>a.e(82002).then(a.bind(a,73704)),meta:{title:"标签: 方法论",index:!1}}],["/tag/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/",{loader:()=>a.e(49483).then(a.bind(a,41808)),meta:{title:"标签: 思维模型",index:!1}}],["/tag/%E6%B1%87%E6%8A%A5/",{loader:()=>a.e(49058).then(a.bind(a,40311)),meta:{title:"标签: 汇报",index:!1}}],["/tag/%E6%80%BB%E7%BB%93/",{loader:()=>a.e(95436).then(a.bind(a,99223)),meta:{title:"标签: 总结",index:!1}}],["/tag/%E5%88%86%E5%B8%83%E5%BC%8F/",{loader:()=>a.e(66798).then(a.bind(a,63388)),meta:{title:"标签: 分布式",index:!1}}],["/tag/heif/",{loader:()=>a.e(71606).then(a.bind(a,16334)),meta:{title:"标签: HEIF",index:!1}}],["/tag/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/",{loader:()=>a.e(4150).then(a.bind(a,80515)),meta:{title:"标签: 环境安装",index:!1}}],["/tag/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(13968).then(a.bind(a,51696)),meta:{title:"标签: 图片格式",index:!1}}],["/tag/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/",{loader:()=>a.e(79208).then(a.bind(a,3986)),meta:{title:"标签: 编解码器",index:!1}}],["/tag/isobmff/",{loader:()=>a.e(98206).then(a.bind(a,82187)),meta:{title:"标签: ISOBMFF",index:!1}}],["/tag/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(41446).then(a.bind(a,99838)),meta:{title:"标签: 多媒体格式",index:!1}}],["/tag/%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(93698).then(a.bind(a,56515)),meta:{title:"标签: 容器格式",index:!1}}],["/tag/electron/",{loader:()=>a.e(56052).then(a.bind(a,83062)),meta:{title:"标签: Electron",index:!1}}],["/tag/macos/",{loader:()=>a.e(9887).then(a.bind(a,23105)),meta:{title:"标签: macOS",index:!1}}],["/tag/%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85/",{loader:()=>a.e(21658).then(a.bind(a,94680)),meta:{title:"标签: 应用打包",index:!1}}],["/tag/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/",{loader:()=>a.e(45039).then(a.bind(a,45979)),meta:{title:"标签: 代码签名",index:!1}}],["/tag/%E5%8F%91%E5%B8%83/",{loader:()=>a.e(12114).then(a.bind(a,72716)),meta:{title:"标签: 发布",index:!1}}],["/tag/github%E5%B7%A5%E4%BD%9C%E6%B5%81/",{loader:()=>a.e(2967).then(a.bind(a,40074)),meta:{title:"标签: github工作流",index:!1}}],["/tag/github-action/",{loader:()=>a.e(8878).then(a.bind(a,25508)),meta:{title:"标签: github Action",index:!1}}],["/tag/jsdelivr/",{loader:()=>a.e(55389).then(a.bind(a,11915)),meta:{title:"标签: jsdelivr",index:!1}}],["/tag/cdn/",{loader:()=>a.e(13865).then(a.bind(a,48079)),meta:{title:"标签: CDN",index:!1}}],["/tag/icns%E5%9B%BE%E6%A0%87/",{loader:()=>a.e(18186).then(a.bind(a,80113)),meta:{title:"标签: icns图标",index:!1}}],["/tag/iconutil/",{loader:()=>a.e(54647).then(a.bind(a,76185)),meta:{title:"标签: iconutil",index:!1}}],["/tag/paypal%E6%94%AF%E4%BB%98/",{loader:()=>a.e(27474).then(a.bind(a,60537)),meta:{title:"标签: paypal支付",index:!1}}],["/tag/piclist/",{loader:()=>a.e(92378).then(a.bind(a,63679)),meta:{title:"标签: piclist",index:!1}}],["/tag/geo%E4%BC%98%E5%8C%96/",{loader:()=>a.e(66009).then(a.bind(a,66766)),meta:{title:"标签: GEO优化",index:!1}}],["/tag/ai%E6%90%9C%E7%B4%A2/",{loader:()=>a.e(63046).then(a.bind(a,18385)),meta:{title:"标签: AI搜索",index:!1}}],["/tag/%E5%86%85%E5%AE%B9%E8%90%A5%E9%94%80/",{loader:()=>a.e(3013).then(a.bind(a,34040)),meta:{title:"标签: 内容营销",index:!1}}],["/tag/%E7%94%9F%E6%88%90%E5%BC%8F%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/",{loader:()=>a.e(72063).then(a.bind(a,56320)),meta:{title:"标签: 生成式引擎优化",index:!1}}],["/tag/%E6%8F%92%E4%BB%B6/",{loader:()=>a.e(70506).then(a.bind(a,57059)),meta:{title:"标签: 插件",index:!1}}],["/tag/%E5%8D%9A%E5%AE%A2/",{loader:()=>a.e(29606).then(a.bind(a,16147)),meta:{title:"标签: 博客",index:!1}}],["/tag/llm/",{loader:()=>a.e(56725).then(a.bind(a,1990)),meta:{title:"标签: LLM",index:!1}}],["/tag/hugging-face/",{loader:()=>a.e(83889).then(a.bind(a,27392)),meta:{title:"标签: hugging face",index:!1}}],["/tag/hf/",{loader:()=>a.e(25960).then(a.bind(a,71471)),meta:{title:"标签: hf",index:!1}}],["/tag/%E5%81%A5%E8%BA%AB/",{loader:()=>a.e(62438).then(a.bind(a,94068)),meta:{title:"标签: 健身",index:!1}}],["/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/",{loader:()=>a.e(4333).then(a.bind(a,13782)),meta:{title:"标签: 架构设计",index:!1}}],["/tag/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/",{loader:()=>a.e(63655).then(a.bind(a,3156)),meta:{title:"标签: 学习路径",index:!1}}],["/tag/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/",{loader:()=>a.e(19769).then(a.bind(a,70369)),meta:{title:"标签: 思维导图",index:!1}}],["/tag/%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D/",{loader:()=>a.e(30616).then(a.bind(a,37404)),meta:{title:"标签: 参考书籍",index:!1}}],["/tag/tcpip-%E4%BA%94%E5%B1%82/",{loader:()=>a.e(22701).then(a.bind(a,59093)),meta:{title:"标签: TCP/IP 五层",index:!1}}],["/tag/tcp/",{loader:()=>a.e(13997).then(a.bind(a,14876)),meta:{title:"标签: TCP",index:!1}}],["/tag/mac/",{loader:()=>a.e(39145).then(a.bind(a,79612)),meta:{title:"标签: MAC",index:!1}}],["/tag/ip/",{loader:()=>a.e(61923).then(a.bind(a,18919)),meta:{title:"标签: IP",index:!1}}],["/tag/http/",{loader:()=>a.e(4226).then(a.bind(a,43760)),meta:{title:"标签: HTTP",index:!1}}],["/tag/http2/",{loader:()=>a.e(74436).then(a.bind(a,7961)),meta:{title:"标签: HTTP2",index:!1}}],["/tag/tls/",{loader:()=>a.e(93603).then(a.bind(a,65769)),meta:{title:"标签: TLS",index:!1}}],["/tag/quic/",{loader:()=>a.e(64996).then(a.bind(a,68530)),meta:{title:"标签: QUIC",index:!1}}],["/tag/http3/",{loader:()=>a.e(15363).then(a.bind(a,11103)),meta:{title:"标签: HTTP3",index:!1}}],["/tag/io/",{loader:()=>a.e(14086).then(a.bind(a,60676)),meta:{title:"标签: IO",index:!1}}],["/tag/nio/",{loader:()=>a.e(57936).then(a.bind(a,37460)),meta:{title:"标签: NIO",index:!1}}],["/tag/aio/",{loader:()=>a.e(99993).then(a.bind(a,63138)),meta:{title:"标签: AIO",index:!1}}],["/tag/aes/",{loader:()=>a.e(48521).then(a.bind(a,50449)),meta:{title:"标签: AES",index:!1}}],["/tag/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/",{loader:()=>a.e(16511).then(a.bind(a,95031)),meta:{title:"标签: 非对称加密",index:!1}}],["/tag/socket%E7%BC%96%E7%A8%8B/",{loader:()=>a.e(49016).then(a.bind(a,73478)),meta:{title:"标签: socket编程",index:!1}}],["/tag/%E9%9D%A2%E8%AF%95/",{loader:()=>a.e(50243).then(a.bind(a,76177)),meta:{title:"标签: 面试",index:!1}}],["/tag/%E7%AE%80%E5%8E%86/",{loader:()=>a.e(95072).then(a.bind(a,81561)),meta:{title:"标签: 简历",index:!1}}],["/tag/%E6%A6%82%E5%BF%B5/",{loader:()=>a.e(69187).then(a.bind(a,83397)),meta:{title:"标签: 概念",index:!1}}],["/tag/gpt/",{loader:()=>a.e(85643).then(a.bind(a,55396)),meta:{title:"标签: GPT",index:!1}}],["/tag/prompt/",{loader:()=>a.e(46724).then(a.bind(a,72217)),meta:{title:"标签: Prompt",index:!1}}],["/tag/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/",{loader:()=>a.e(74364).then(a.bind(a,72152)),meta:{title:"标签: 性能分析",index:!1}}],["/tag/%E5%8F%AF%E8%A7%86%E5%8C%96/",{loader:()=>a.e(16583).then(a.bind(a,91120)),meta:{title:"标签: 可视化",index:!1}}],["/tag/flamegraph/",{loader:()=>a.e(22443).then(a.bind(a,7839)),meta:{title:"标签: FlameGraph",index:!1}}],["/tag/trace/",{loader:()=>a.e(21299).then(a.bind(a,27415)),meta:{title:"标签: trace",index:!1}}],["/tag/systemtap%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97/",{loader:()=>a.e(363).then(a.bind(a,12882)),meta:{title:"标签: Systemtap新手指南",index:!1}}],["/tag/systemtap/",{loader:()=>a.e(9788).then(a.bind(a,88548)),meta:{title:"标签: Systemtap",index:!1}}],["/tag/systemtap%E6%89%8B%E5%86%8C/",{loader:()=>a.e(51915).then(a.bind(a,36320)),meta:{title:"标签: Systemtap手册",index:!1}}],["/tag/systemtap%E8%AF%AD%E6%B3%95/",{loader:()=>a.e(8942).then(a.bind(a,44015)),meta:{title:"标签: SystemTap语法",index:!1}}],["/tag/systemtap/",{loader:()=>a.e(9788).then(a.bind(a,88548)),meta:{title:"标签: SystemTap",index:!1}}],["/tag/ebpf/",{loader:()=>a.e(29563).then(a.bind(a,65793)),meta:{title:"标签: eBPF",index:!1}}],["/tag/nginx%E6%BA%90%E7%A0%81/",{loader:()=>a.e(26437).then(a.bind(a,40655)),meta:{title:"标签: nginx源码",index:!1}}],["/tag/tcp-fin/",{loader:()=>a.e(39381).then(a.bind(a,88017)),meta:{title:"标签: TCP FIN",index:!1}}],["/tag/tcp-rst/",{loader:()=>a.e(63577).then(a.bind(a,23613)),meta:{title:"标签: TCP RST",index:!1}}],["/tag/wireshark/",{loader:()=>a.e(72736).then(a.bind(a,57134)),meta:{title:"标签: wireshark",index:!1}}],["/tag/%E6%8A%93%E5%8C%85/",{loader:()=>a.e(49550).then(a.bind(a,90918)),meta:{title:"标签: 抓包",index:!1}}],["/tag/chunk%E6%A0%BC%E5%BC%8F/",{loader:()=>a.e(15102).then(a.bind(a,58548)),meta:{title:"标签: chunk格式",index:!1}}],["/tag/tomcat/",{loader:()=>a.e(21986).then(a.bind(a,14730)),meta:{title:"标签: tomcat",index:!1}}],["/tag/host%E9%94%99%E8%AF%AF/",{loader:()=>a.e(48536).then(a.bind(a,53826)),meta:{title:"标签: host错误",index:!1}}],["/tag/%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/",{loader:()=>a.e(93369).then(a.bind(a,8184)),meta:{title:"标签: 网络分析",index:!1}}],["/tag/tsl%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5/",{loader:()=>a.e(44935).then(a.bind(a,54438)),meta:{title:"标签: TSL握手失败",index:!1}}],["/tag/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/",{loader:()=>a.e(88871).then(a.bind(a,59922)),meta:{title:"标签: 网络问题分析",index:!1}}],["/tag/wireshark%E6%8A%93%E5%8C%85/",{loader:()=>a.e(18008).then(a.bind(a,99402)),meta:{title:"标签: wireshark抓包",index:!1}}],["/tag/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/",{loader:()=>a.e(57574).then(a.bind(a,96198)),meta:{title:"标签: 故障排查",index:!1}}],["/tag/icmp/",{loader:()=>a.e(98583).then(a.bind(a,23041)),meta:{title:"标签: icmp",index:!1}}],["/tag/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/",{loader:()=>a.e(38012).then(a.bind(a,42938)),meta:{title:"标签: 压力测试",index:!1}}],["/tag/%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/",{loader:()=>a.e(75098).then(a.bind(a,20159)),meta:{title:"标签: 瓶颈分析",index:!1}}],["/tag/p99x/",{loader:()=>a.e(33600).then(a.bind(a,56993)),meta:{title:"标签: P99X",index:!1}}],["/tag/locust/",{loader:()=>a.e(1508).then(a.bind(a,36765)),meta:{title:"标签: Locust",index:!1}}],["/tag/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/",{loader:()=>a.e(61358).then(a.bind(a,22736)),meta:{title:"标签: 性能测试",index:!1}}],["/tag/api%E6%B5%8B%E8%AF%95/",{loader:()=>a.e(41598).then(a.bind(a,80687)),meta:{title:"标签: API测试",index:!1}}],["/tag/gdb/",{loader:()=>a.e(10561).then(a.bind(a,60680)),meta:{title:"标签: GDB",index:!1}}],["/tag/luajit/",{loader:()=>a.e(12595).then(a.bind(a,98940)),meta:{title:"标签: luajit",index:!1}}],["/tag/btrace/",{loader:()=>a.e(52081).then(a.bind(a,56694)),meta:{title:"标签: btrace",index:!1}}],["/tag/docker/",{loader:()=>a.e(84446).then(a.bind(a,45651)),meta:{title:"标签: Docker",index:!1}}],["/tag/minikube/",{loader:()=>a.e(3744).then(a.bind(a,59836)),meta:{title:"标签: minikube",index:!1}}],["/tag/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",{loader:()=>a.e(70217).then(a.bind(a,36676)),meta:{title:"标签: 消息队列",index:!1}}],["/tag/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/",{loader:()=>a.e(88456).then(a.bind(a,28691)),meta:{title:"标签: 基础理论",index:!1}}],["/tag/cap%E5%AE%9A%E7%90%86/",{loader:()=>a.e(32530).then(a.bind(a,71552)),meta:{title:"标签: CAP定理",index:!1}}],["/tag/acid/",{loader:()=>a.e(13223).then(a.bind(a,83569)),meta:{title:"标签: ACID",index:!1}}],["/tag/base/",{loader:()=>a.e(38463).then(a.bind(a,45989)),meta:{title:"标签: BASE",index:!1}}],["/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/",{loader:()=>a.e(79198).then(a.bind(a,59524)),meta:{title:"标签: 分布式事务",index:!1}}],["/tag/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/",{loader:()=>a.e(76927).then(a.bind(a,85565)),meta:{title:"标签: 一致性算法",index:!1}}],["/tag/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/",{loader:()=>a.e(32005).then(a.bind(a,21435)),meta:{title:"标签: 共识算法",index:!1}}],["/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/",{loader:()=>a.e(37963).then(a.bind(a,12078)),meta:{title:"标签: 分布式通信",index:!1}}],["/tag/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/",{loader:()=>a.e(56483).then(a.bind(a,15802)),meta:{title:"标签: 高性能设计",index:!1}}],["/tag/%E5%BA%8F%E5%88%97%E5%8C%96/",{loader:()=>a.e(66426).then(a.bind(a,37392)),meta:{title:"标签: 序列化",index:!1}}],["/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B/",{loader:()=>a.e(38775).then(a.bind(a,49390)),meta:{title:"标签: 分布式故障模型",index:!1}}],["/tag/%E5%94%AF%E4%B8%80id/",{loader:()=>a.e(55472).then(a.bind(a,14987)),meta:{title:"标签: 唯一ID",index:!1}}],["/tag/%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89/",{loader:()=>a.e(11025).then(a.bind(a,77058)),meta:{title:"标签: 基础定义",index:!1}}],["/tag/golang/",{loader:()=>a.e(77984).then(a.bind(a,3428)),meta:{title:"标签: golang",index:!1}}],["/tag/%E7%AC%94%E8%AE%B0/",{loader:()=>a.e(26238).then(a.bind(a,24522)),meta:{title:"标签: 笔记",index:!1}}],["/tag/java/",{loader:()=>a.e(80250).then(a.bind(a,54360)),meta:{title:"标签: java",index:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",{loader:()=>a.e(34817).then(a.bind(a,59157)),meta:{title:"标签: 数据库",index:!1}}],["/tag/es/",{loader:()=>a.e(94590).then(a.bind(a,58133)),meta:{title:"标签: ES",index:!1}}],["/tag/mysql/",{loader:()=>a.e(72996).then(a.bind(a,72679)),meta:{title:"标签: Mysql",index:!1}}],["/tag/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/",{loader:()=>a.e(41768).then(a.bind(a,2413)),meta:{title:"标签: 逻辑架构",index:!1}}],["/tag/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/",{loader:()=>a.e(94784).then(a.bind(a,69656)),meta:{title:"标签: 日志系统",index:!1}}],["/tag/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/",{loader:()=>a.e(85261).then(a.bind(a,45343)),meta:{title:"标签: 事务隔离级别",index:!1}}],["/tag/%E9%94%81/",{loader:()=>a.e(73089).then(a.bind(a,59697)),meta:{title:"标签: 锁",index:!1}}],["/tag/%E8%A1%8C%E8%AE%B0%E5%BD%95/",{loader:()=>a.e(16217).then(a.bind(a,17908)),meta:{title:"标签: 行记录",index:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E9%A1%B5/",{loader:()=>a.e(97895).then(a.bind(a,23914)),meta:{title:"标签: 数据页",index:!1}}],["/tag/%E7%B4%A2%E5%BC%95/",{loader:()=>a.e(59043).then(a.bind(a,61336)),meta:{title:"标签: 索引",index:!1}}],["/tag/%E8%A1%A8%E7%A9%BA%E9%97%B4/",{loader:()=>a.e(94876).then(a.bind(a,38109)),meta:{title:"标签: 表空间",index:!1}}],["/tag/%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/",{loader:()=>a.e(66341).then(a.bind(a,38324)),meta:{title:"标签: 索引合并",index:!1}}],["/tag/%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/",{loader:()=>a.e(20083).then(a.bind(a,48085)),meta:{title:"标签: 连表查询",index:!1}}],["/tag/explain/",{loader:()=>a.e(70829).then(a.bind(a,74919)),meta:{title:"标签: explain",index:!1}}],["/tag/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",{loader:()=>a.e(84928).then(a.bind(a,86145)),meta:{title:"标签: 性能优化",index:!1}}],["/tag/optimize/",{loader:()=>a.e(73973).then(a.bind(a,13248)),meta:{title:"标签: optimize",index:!1}}],["/tag/%E7%BC%93%E5%86%B2%E6%B1%A0/",{loader:()=>a.e(44001).then(a.bind(a,62748)),meta:{title:"标签: 缓冲池",index:!1}}],["/tag/bufferpool/",{loader:()=>a.e(95458).then(a.bind(a,39325)),meta:{title:"标签: BufferPool",index:!1}}],["/tag/sql/",{loader:()=>a.e(85374).then(a.bind(a,32546)),meta:{title:"标签: SQL",index:!1}}],["/tag/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/",{loader:()=>a.e(5728).then(a.bind(a,93341)),meta:{title:"标签: 主从同步",index:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B/",{loader:()=>a.e(14109).then(a.bind(a,34567)),meta:{title:"标签: 数据库选型",index:!1}}],["/tag/redis/",{loader:()=>a.e(18857).then(a.bind(a,10158)),meta:{title:"标签: Redis",index:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",{loader:()=>a.e(67266).then(a.bind(a,23585)),meta:{title:"标签: 数据类型",index:!1}}],["/tag/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{loader:()=>a.e(49812).then(a.bind(a,38463)),meta:{title:"标签: 底层数据结构",index:!1}}],["/tag/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8/",{loader:()=>a.e(94710).then(a.bind(a,35484)),meta:{title:"标签: 全局哈希表",index:!1}}],["/tag/%E9%94%AE%E5%80%BC%E5%AF%B9%E7%BB%93%E6%9E%84/",{loader:()=>a.e(72972).then(a.bind(a,98031)),meta:{title:"标签: 键值对结构",index:!1}}],["/tag/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/",{loader:()=>a.e(5796).then(a.bind(a,56730)),meta:{title:"标签: 线程模型",index:!1}}],["/tag/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/",{loader:()=>a.e(78591).then(a.bind(a,54037)),meta:{title:"标签: 淘汰策略",index:!1}}],["/tag/%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/",{loader:()=>a.e(35067).then(a.bind(a,78099)),meta:{title:"标签: 删除策略",index:!1}}],["/tag/%E6%8C%81%E4%B9%85%E5%8C%96/",{loader:()=>a.e(5414).then(a.bind(a,5544)),meta:{title:"标签: 持久化",index:!1}}],["/tag/aof/",{loader:()=>a.e(22068).then(a.bind(a,33221)),meta:{title:"标签: AOF",index:!1}}],["/tag/rdb/",{loader:()=>a.e(89678).then(a.bind(a,96750)),meta:{title:"标签: RDB",index:!1}}],["/tag/repl-backlog-buffer/",{loader:()=>a.e(61750).then(a.bind(a,27501)),meta:{title:"标签: repl_backlog_buffer",index:!1}}],["/tag/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/",{loader:()=>a.e(75353).then(a.bind(a,48863)),meta:{title:"标签: 哨兵机制",index:!1}}],["/tag/sentinel/",{loader:()=>a.e(1666).then(a.bind(a,6073)),meta:{title:"标签: Sentinel",index:!1}}],["/tag/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/",{loader:()=>a.e(48479).then(a.bind(a,69861)),meta:{title:"标签: 分片集群",index:!1}}],["/tag/sharding/",{loader:()=>a.e(82938).then(a.bind(a,67872)),meta:{title:"标签: Sharding",index:!1}}],["/tag/kafka/",{loader:()=>a.e(88900).then(a.bind(a,75952)),meta:{title:"标签: kafka",index:!1}}],["/tag/nsq/",{loader:()=>a.e(46852).then(a.bind(a,23987)),meta:{title:"标签: nsq",index:!1}}],["/tag/rocketmq/",{loader:()=>a.e(19624).then(a.bind(a,92033)),meta:{title:"标签: RocketMQ",index:!1}}],["/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{loader:()=>a.e(47055).then(a.bind(a,15176)),meta:{title:"标签: 设计模式",index:!1}}],["/tag/%E7%BA%BF%E6%80%A7%E8%A1%A8/",{loader:()=>a.e(11408).then(a.bind(a,31441)),meta:{title:"标签: 线性表",index:!1}}],["/tag/%E6%95%B0%E7%BB%84/",{loader:()=>a.e(15494).then(a.bind(a,97706)),meta:{title:"标签: 数组",index:!1}}],["/tag/%E5%88%97%E8%A1%A8/",{loader:()=>a.e(71013).then(a.bind(a,92908)),meta:{title:"标签: 列表",index:!1}}],["/tag/%E9%93%BE%E8%A1%A8/",{loader:()=>a.e(56068).then(a.bind(a,40353)),meta:{title:"标签: 链表",index:!1}}],["/tag/%E6%A0%88/",{loader:()=>a.e(22066).then(a.bind(a,1619)),meta:{title:"标签: 栈",index:!1}}],["/tag/%E9%98%9F%E5%88%97/",{loader:()=>a.e(25524).then(a.bind(a,63038)),meta:{title:"标签: 队列",index:!1}}],["/tag/%E6%95%A3%E5%88%97%E8%A1%A8/",{loader:()=>a.e(97676).then(a.bind(a,92467)),meta:{title:"标签: 散列表",index:!1}}],["/tag/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/",{loader:()=>a.e(28283).then(a.bind(a,17432)),meta:{title:"标签: 哈希函数",index:!1}}],["/tag/%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/",{loader:()=>a.e(54213).then(a.bind(a,50540)),meta:{title:"标签: 冲突处理",index:!1}}],["/tag/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9/",{loader:()=>a.e(75631).then(a.bind(a,42320)),meta:{title:"标签: 动态扩容",index:!1}}],["/tag/%E4%BD%8D%E5%9B%BE/",{loader:()=>a.e(66577).then(a.bind(a,34722)),meta:{title:"标签: 位图",index:!1}}],["/tag/%E6%A0%91/",{loader:()=>a.e(61713).then(a.bind(a,56828)),meta:{title:"标签: 树",index:!1}}],["/tag/%E4%BA%8C%E5%8F%89%E6%A0%91/",{loader:()=>a.e(2264).then(a.bind(a,43970)),meta:{title:"标签: 二叉树",index:!1}}],["/tag/avl%E5%B9%B3%E8%A1%A1%E6%A0%91/",{loader:()=>a.e(2486).then(a.bind(a,55701)),meta:{title:"标签: AVL平衡树",index:!1}}],["/tag/%E7%BA%A2%E9%BB%91%E6%A0%91/",{loader:()=>a.e(91062).then(a.bind(a,73251)),meta:{title:"标签: 红黑树",index:!1}}],["/tag/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/",{loader:()=>a.e(33845).then(a.bind(a,42866)),meta:{title:"标签: 多路查找树",index:!1}}],["/tag/%E5%A0%86/",{loader:()=>a.e(5672).then(a.bind(a,32827)),meta:{title:"标签: 堆",index:!1}}],["/tag/heap/",{loader:()=>a.e(66820).then(a.bind(a,18420)),meta:{title:"标签: Heap",index:!1}}],["/tag/%E5%9B%BE/",{loader:()=>a.e(65104).then(a.bind(a,96407)),meta:{title:"标签: 图",index:!1}}],["/tag/graph/",{loader:()=>a.e(94582).then(a.bind(a,86399)),meta:{title:"标签: Graph",index:!1}}],["/tag/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/",{loader:()=>a.e(2320).then(a.bind(a,88982)),meta:{title:"标签: 图的存储",index:!1}}],["/tag/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/",{loader:()=>a.e(69393).then(a.bind(a,10751)),meta:{title:"标签: 拓扑排序",index:!1}}],["/tag/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/",{loader:()=>a.e(13116).then(a.bind(a,62942)),meta:{title:"标签: 关键路径",index:!1}}],["/tag/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/",{loader:()=>a.e(12046).then(a.bind(a,15224)),meta:{title:"标签: 最短路径",index:!1}}],["/tag/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/",{loader:()=>a.e(21907).then(a.bind(a,33320)),meta:{title:"标签: 最小生成树",index:!1}}],["/tag/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/",{loader:()=>a.e(90423).then(a.bind(a,68017)),meta:{title:"标签: 复杂度分析",index:!1}}],["/tag/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",{loader:()=>a.e(56145).then(a.bind(a,12780)),meta:{title:"标签: 排序算法",index:!1}}],["/tag/%E7%AE%97%E6%B3%95/",{loader:()=>a.e(95874).then(a.bind(a,32329)),meta:{title:"标签: 算法",index:!1}}],["/tag/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/",{loader:()=>a.e(59468).then(a.bind(a,34045)),meta:{title:"标签: 搜索算法",index:!1}}],["/tag/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/",{loader:()=>a.e(66871).then(a.bind(a,14464)),meta:{title:"标签: 二分查找",index:!1}}],["/tag/%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/",{loader:()=>a.e(16305).then(a.bind(a,44405)),meta:{title:"标签: 遍历算法",index:!1}}],["/tag/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/",{loader:()=>a.e(13573).then(a.bind(a,63131)),meta:{title:"标签: 深度优先",index:!1}}],["/tag/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/",{loader:()=>a.e(8731).then(a.bind(a,5122)),meta:{title:"标签: 广度优先",index:!1}}],["/tag/%E6%90%9C%E7%B4%A2%E6%A0%91/",{loader:()=>a.e(94683).then(a.bind(a,55348)),meta:{title:"标签: 搜索树",index:!1}}],["/tag/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/",{loader:()=>a.e(49102).then(a.bind(a,35784)),meta:{title:"标签: 递归算法",index:!1}}],["/tag/%E6%A1%B6%E6%8E%92%E5%BA%8F/",{loader:()=>a.e(63687).then(a.bind(a,97340)),meta:{title:"标签: 桶排序",index:!1}}],["/tag/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/",{loader:()=>a.e(92664).then(a.bind(a,72258)),meta:{title:"标签: 计数排序",index:!1}}],["/tag/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/",{loader:()=>a.e(22495).then(a.bind(a,16914)),meta:{title:"标签: 基数排序",index:!1}}],["/tag/%E5%86%92%E6%B3%A1/",{loader:()=>a.e(69927).then(a.bind(a,70735)),meta:{title:"标签: 冒泡",index:!1}}],["/tag/%E6%8F%92%E5%85%A5/",{loader:()=>a.e(3139).then(a.bind(a,11918)),meta:{title:"标签: 插入",index:!1}}],["/tag/%E9%80%89%E6%8B%A9/",{loader:()=>a.e(28300).then(a.bind(a,58257)),meta:{title:"标签: 选择",index:!1}}],["/tag/%E5%BF%AB%E9%80%9F/",{loader:()=>a.e(76008).then(a.bind(a,39474)),meta:{title:"标签: 快速",index:!1}}],["/tag/%E5%BD%92%E5%B9%B6/",{loader:()=>a.e(87242).then(a.bind(a,33923)),meta:{title:"标签: 归并",index:!1}}],["/tag/%E5%B8%8C%E5%B0%94/",{loader:()=>a.e(9490).then(a.bind(a,75827)),meta:{title:"标签: 希尔",index:!1}}],["/article/",{loader:()=>a.e(97511).then(a.bind(a,71586)),meta:{title:"文章",index:!1}}],["/star/",{loader:()=>a.e(47199).then(a.bind(a,24850)),meta:{title:"星标",index:!1}}],["/timeline/",{loader:()=>a.e(85464).then(a.bind(a,41688)),meta:{title:"时间轴",index:!1}}]])},50594:(e,n,a)=>{a.d(n,{U:()=>i});const i=JSON.parse('{"article":{"/":{"path":"/article/","indexes":[103,104,105,8,9,10,11,33,31,106,0,46,47,48,49,50,51,52,53,54,55,56,57,107,108,109,110,111,1,83,177,12,42,40,41,178,128,147,13,14,15,16,17,18,146,96,97,130,131,132,133,134,135,136,137,138,139,140,141,142,143,124,144,145,2,166,167,168,169,170,171,172,173,174,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,122,123,148,125,126,127,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,45,129,19,20,21,22,23,24,25,26,27,28,29,30,98,99,3,4,5,6,34,35,36,37,32,112,113,114,115,94,95,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,84,116,43,44,117,118,119,120,121,7,175,176,38,100,39,101,102,85,86,87,88,89,90,91,92,93]}},"star":{"/":{"path":"/star/","indexes":[12,42,103,40,41,104,147,13,14,15,16,17,18,146,96,97,2,105,166,167,168,169,170,171,172,173,174,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,122,123,148,125,126,127,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,45,129,19,20,21,22,23,24,25,8,26,27,9,10,11,28,29,30,98,99,3,5,35,36,37,33,31,106,95,0,46,47,48,49,50,51,52,53,54,55,56,57,84,107,108,109,110,111,7,175,176,1,86,83,89]}},"timeline":{"/":{"path":"/timeline/","indexes":[177,12,42,103,40,41,104,178,128,147,13,14,15,16,17,18,146,96,97,130,131,132,133,134,135,136,137,138,139,140,141,142,143,124,144,145,2,105,166,167,168,169,170,171,172,173,174,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,122,123,148,125,126,127,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,45,129,19,20,21,22,23,24,25,8,26,27,9,10,11,28,29,30,98,99,3,4,5,6,34,35,36,37,33,32,31,106,112,113,114,115,94,95,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,0,46,47,48,49,50,51,52,53,54,55,56,57,84,116,43,44,117,118,119,107,120,121,108,109,110,111,7,175,176,38,100,1,39,101,102,85,86,83,87,88,89,90,91,92,93]}}}')},71878:(e,n,a)=>{a.d(n,{v:()=>i});const i={"/计算机网络/":["01.网络模型","02.物理层（一层）","03.数据链路层、MAC（二层）","04.网络层、IP（三层）","05.传输层、TCP（四层）","06.应用层、HTTP（五层）","07.网络IO技术-阻塞、非阻塞、同步、异步","08.网络文件IO优化","09.SSH公私钥验证","10.socket编程","50.常见的题目"],"/算法数据结构/数据结构/":["00.定义",{text:"01.线性表",prefix:"01.线性表/",collapsible:!0,children:["0.线性表","1.数组","2.1列表","2.链表","3.栈","4.队列"]},{text:"02.哈希表",prefix:"02.哈希表/",collapsible:!0,children:["1.散列表","2.哈希函数","3.冲突处理","4.动态扩容","5.位图"]},{text:"03.树",prefix:"03.树/",collapsible:!0,children:["1.树","2.二叉树","3.AVL平衡树","4.红黑树","5.多路查找树","6.堆"]},{text:"04.图",prefix:"04.图/",collapsible:!0,children:["0.图","1.图的存储","2.拓扑排序","3.关键路径","4.最短路径","5.最小生成树"]}],"/算法数据结构/算法/":[{text:"0.基本思想",prefix:"0.基本思想/",collapsible:!0,children:["分治算法","动态规划","回溯算法","枚举算法","贪心算法"]},{text:"1.复杂度分析",prefix:"1.复杂度分析/",collapsible:!0,children:["复杂度分析"]},{text:"2.排序",prefix:"2.排序/",collapsible:!0,children:[{text:"O(n^2)",prefix:"O(n_2)/",collapsible:!0,children:["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html"]},{text:"O(n+k)",prefix:"O(n_k)/",collapsible:!0,children:["/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html"]},{text:"O(nlogn)",prefix:"O(nlogn)/",collapsible:!0,children:["快速、归并、堆、希尔"]},"排序算法"]},{text:"3.搜索",prefix:"3.搜索/",collapsible:!0,children:["0.搜索","1.二分查找","2.遍历查找","3.搜索树查找"]},{text:"5.字符串匹配",prefix:"5.字符串匹配/",collapsible:!0,children:["AC自动机","KMP","LSM-Tree","Tier树","朴素"]},{text:"6.其他",prefix:"6.其他/",collapsible:!0,children:["概率分析","递归算法"]}],"/编程语言/":[{text:"Golang",prefix:"golang/",collapsible:!0,children:["array、slice","CSP、channel","gc","golang学习笔记","goroutine","interface","interface和struct的使用场景","map","options函数选项模式","panic、recover、defer","select",{text:"学习资料汇总",prefix:"学习资料汇总/",collapsible:!0,children:["go总结","go学习笔记（强类型的静态无虚拟机语言）"]},"数据类型",{text:"标准库",prefix:"标准库/",collapsible:!0,children:["reflect","unsafe","context",{text:"Sync",prefix:"sync/",collapsible:!0,children:[{text:"Sync",prefix:"sync/",collapsible:!0,children:["atomic"]},"sync.Cond","sync.Mutext、sync.RWMutex","sync.WaitGroup、sync.Once"]}]},"类型转换和断言"]},{text:"JAVA",prefix:"java/",collapsible:!0,children:[""]},{text:"Lua",prefix:"lua/",collapsible:!0,children:[""]},{text:"Python",prefix:"python/",collapsible:!0,children:[""]}],"/常用软件/":[{text:"分布式基建",prefix:"分布式基建/",collapsible:!0,children:[{text:"chubby",prefix:"chubby/",collapsible:!0,children:[""]},{text:"consul",prefix:"consul/",collapsible:!0,children:[""]},{text:"etcd",prefix:"etcd/",collapsible:!0,children:[""]},{text:"nacos",prefix:"nacos/",collapsible:!0,children:[""]},{text:"Zookeeper",prefix:"zookeeper/",collapsible:!0,children:["原理"]}]},{text:"容器化",prefix:"容器化/",collapsible:!0,children:["docker","k8s","minikube"]},{text:"数据库",prefix:"数据库/",collapsible:!0,children:[{text:"Clickhouse",prefix:"clickhouse/",collapsible:!0,children:["原理"]},{text:"Elastic Search",prefix:"elasticSearch/",collapsible:!0,children:["原理"]},{text:"Mysql",prefix:"mysql/",collapsible:!0,children:["01.Mysql逻辑架构","02.日志系统","03.事务隔离级别","06.全局锁、表锁、行锁","07.行记录结构","08.数据页结构","09.索引结构","10.表空间结构","11.索引概念","12.索引合并-indexMerge","13.连表查询-join","14.性能优化-explain优化器决策结果","15.性能优化-optimizeTrace优化器决策过程","16.缓冲池-BufferPool","17.Sql是如何执行的","18.主从同步","19.常见云数据库选型"]},{text:"openSearch",prefix:"opensearch/",collapsible:!0,children:[""]},"QA",{text:"Redis",prefix:"redis/",collapsible:!0,children:["01.数据类型、底层数据结构","02.全局哈希表","03.线程模型","04.淘汰策略","06.持久化-AOF","07.持久化-RDB","08.主从同步-Slave","09.哨兵机制-Sentinel","10.分片集群-Sharding"]}]},{text:"消息队列",prefix:"消息队列/",collapsible:!0,children:[{text:"Kafka",prefix:"kafka/",collapsible:!0,children:["kafka原理"]},{text:"README",prefix:"nsq/",collapsible:!0,children:[""]},{text:"Rocketmq",prefix:"rocketmq/",collapsible:!0,children:["RocketMQ原理"]},"消息队列的作用"]},"0.学习路径"],"/架构设计/":[{text:"01.设计模式",prefix:"01.设计模式/",collapsible:!0,children:[{text:"常见设计模式",prefix:"常见设计模式/",collapsible:!0,children:["设计模式大纲","设计模式汇总"]}]},{text:"02.分布式与架构",prefix:"02.分布式与架构/",collapsible:!0,children:["01.分布式设计总纲",{text:"01.弹性设计 高可用",prefix:"01.弹性设计-高可用/",collapsible:!0,children:["隔离设计-Bulkheads","大纲图解","幂等性设计-Idempotency","异步通讯设计-Asynchronous","服务的状态-State","熔断设计-Circuit-Breaker","补偿事务-CompensatingTransaction","重试设计-Retry","降级设计-degradation","限流设计-Throttle"]},"02.分布式系统概念","03.分布式基础理论","04.分布式事务","05.分布式一致性算法","06.分布式共识算法-可信","07.分布式共识算法-非可信","08.分布式通信协议","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/10._%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html","11.序列化技术","12.分布式故障模型","13.分布式唯一ID生成算法","架构设计-三个原则","架构设计-可扩展架构"]},{text:"03.中间件",prefix:"03.中间件/",collapsible:!0,children:["分布式协调服务"]},{text:"04. WEB框架",prefix:"04.WEB框架/",collapsible:!0,children:["dubbo","flask","gin","netty","openresty","springboot"]},{text:"05.微服务云原生",prefix:"05.微服务云原生/",collapsible:!0,children:["微服务、云原生"]},"06.参考资料"],"/大模型LLM/":[{text:"00.概念",prefix:"00.概念/",collapsible:!0,children:["01.Transformer","02.GPT","03.Prompt","04.Models"]},{text:"01.框架",prefix:"01.框架/",collapsible:!0,children:["eino","langchain"]},{text:"02. RAG",prefix:"02.RAG/",collapsible:!0,children:["RAG"]},{text:"04.应用",prefix:"04.应用/",collapsible:!0,children:["关于GEO优化Generative-Engine-Optimization","白嫖huggingface的API"]},{text:"README",prefix:"03.微调/",collapsible:!0,children:[""]}],"/工具武器库/":["markdown高级技巧","2025提效插件推荐","electron","关于GEO优化","github_action","HEIF编解码器安装","ISOBMFF多媒体文件协议","jsdeliver","mac系统生成icns图标","Mermaid时序图控制语法完全指南","paypal支付","piclist","插件推荐","白嫖huggingface的API",{text:"网络抓包 Wireshark",prefix:"网络抓包Wireshark/",collapsible:!0,children:["wireshark抓包之Host校验的异常","wireshark抓包之SSL握手问题","wireshark抓包之SSL握手问题二","wireshark抓包之Host设置不正确","wireshark抓包之HTTP状态码200的异常","wireshark抓包之如何抓包","wireshark抓包之目标主机不可达"]},{text:"软件破解",prefix:"软件破解/",collapsible:!0,children:["strongbox"]},{text:"问题分析",prefix:"问题分析/",collapsible:!0,children:["API压测框架之locust","todo"]},{text:"静态动态追踪原理",prefix:"动态追踪技术Tracing/",collapsible:!0,children:["","eBPF技术","FlameGraph-火焰图","Systemtap-tapset","Systemtap-Beginners-Guide中文版","Systemtap-Language-Reference中文版","systemTap分析","systemTap原理","systemTap安装","systemtap笔记"]},{text:"静态追踪技术 GDB",prefix:"静态追踪技术GDB/",collapsible:!0,children:["python运行gdb"]}],"/面试经验/":["简历模版","Ready4Interview"],"/个人思考/":["如何事故复盘","如何做好工作","如何做职业规划","如何养成微习惯","如何写好PPT","职场方法论"],"/我的世界/":["代谢系统","供能系统"],"/_posts/":[]}},76650:(e,n,a)=>{},79354:(e,n,a)=>{a.d(n,{U:()=>i});const i=JSON.parse('{"base":"/","lang":"zh-CN","title":"Navyum\'s Blog","description":"自我提升笔记，记录学习成长的经历；互联网摸爬滚打总结，系统性整理知识","head":[["link",{"rel":"alternate","type":"application/atom+xml","href":"https://myblog.camscanner.top/atom.xml","title":"Navyum\'s Blog Atom Feed"}],["link",{"rel":"alternate","type":"application/json","href":"https://myblog.camscanner.top/feed.json","title":"Navyum\'s Blog JSON Feed"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://myblog.camscanner.top/rss.xml","title":"Navyum\'s Blog RSS Feed"}],["link",{"rel":"icon","href":"/favicon.ico"}]],"locales":{}}')},82798:(e,n,a)=>{a.d(n,{l:()=>i});const i=JSON.parse('{"category":{"/":{"path":"/category/","map":{"使用指南":{"path":"/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","indexes":[0,1]},"个人思考":{"path":"/category/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/","indexes":[2,3,4,5,6,7]},"职业规划":{"path":"/category/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/","indexes":[3]},"分布式":{"path":"/category/%E5%88%86%E5%B8%83%E5%BC%8F/","indexes":[8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]},"HEIF":{"path":"/category/heif/","indexes":[31]},"图片格式":{"path":"/category/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/","indexes":[31]},"工具配置":{"path":"/category/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/","indexes":[31]},"多媒体格式":{"path":"/category/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/","indexes":[32]},"协议规范":{"path":"/category/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/","indexes":[32]},"Electron":{"path":"/category/electron/","indexes":[33]},"应用开发":{"path":"/category/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","indexes":[33]},"发布部署":{"path":"/category/%E5%8F%91%E5%B8%83%E9%83%A8%E7%BD%B2/","indexes":[33]},"踩坑记录":{"path":"/category/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","indexes":[34,35,36,37,38]},"编程":{"path":"/category/%E7%BC%96%E7%A8%8B/","indexes":[39]},"技术方案":{"path":"/category/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/","indexes":[39]},"AI搜索":{"path":"/category/ai%E6%90%9C%E7%B4%A2/","indexes":[40,41]},"内容营销":{"path":"/category/%E5%86%85%E5%AE%B9%E8%90%A5%E9%94%80/","indexes":[40,41]},"插件":{"path":"/category/%E6%8F%92%E4%BB%B6/","indexes":[42]},"博客":{"path":"/category/%E5%8D%9A%E5%AE%A2/","indexes":[42]},"健身":{"path":"/category/%E5%81%A5%E8%BA%AB/","indexes":[43,44]},"参考资料":{"path":"/category/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/","indexes":[45]},"算法":{"path":"/category/%E7%AE%97%E6%B3%95/","indexes":[46,47,48,49,50,51,52,53,54,55,56,57]},"数据结构":{"path":"/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","indexes":[46,47,48,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82]},"网络":{"path":"/category/%E7%BD%91%E7%BB%9C/","indexes":[83,84,85,86,87,88,89,90,91,92,93]},"面试":{"path":"/category/%E9%9D%A2%E8%AF%95/","indexes":[94,95]},"LLM":{"path":"/category/llm/","indexes":[96,97,98,99,100,101,102]},"AI":{"path":"/category/ai/","indexes":[98,99,100,101,102]},"工具":{"path":"/category/%E5%B7%A5%E5%85%B7/","indexes":[103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121]},"性能分析":{"path":"/category/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","indexes":[106,112,113,114,115,116,117,118,119,120,121]},"FlameGraph":{"path":"/category/flamegraph/","indexes":[115]},"英文翻译":{"path":"/category/%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91/","indexes":[113,117,118]},"Systemtap":{"path":"/category/systemtap/","indexes":[113,116,117,118,119,120,121]},"wireshark":{"path":"/category/wireshark/","indexes":[103,104,105,107,108,109,110]},"压测":{"path":"/category/%E5%8E%8B%E6%B5%8B/","indexes":[111]},"GDB":{"path":"/category/gdb/","indexes":[106]},"容器技术":{"path":"/category/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/","indexes":[122,123]},"踩坑笔记":{"path":"/category/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/","indexes":[124,122]},"常用软件":{"path":"/category/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/","indexes":[125,126,127]},"消息队列":{"path":"/category/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","indexes":[128,125,126,127]},"微服务":{"path":"/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","indexes":[129]},"golang":{"path":"/category/golang/","indexes":[130,131]},"笔记":{"path":"/category/%E7%AC%94%E8%AE%B0/","indexes":[132,133,134,135,136,137,138,139,140,141,142,143,124,144,145]},"java":{"path":"/category/java/","indexes":[146]},"数据库":{"path":"/category/%E6%95%B0%E6%8D%AE%E5%BA%93/","indexes":[147,148]},"全文搜索":{"path":"/category/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/","indexes":[148]},"Mysql":{"path":"/category/mysql/","indexes":[149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165]},"Redis":{"path":"/category/redis/","indexes":[166,167,168,169,170,171,172,173,174]},"架构设计":{"path":"/category/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","indexes":[175,176]},"排序算法":{"path":"/category/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","indexes":[49,55,56]},"搜索算法":{"path":"/category/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","indexes":[50,51,52,53]}}}},"tag":{"/":{"path":"/tag/","map":{"页面配置":{"path":"/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/","indexes":[0,1]},"使用指南":{"path":"/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","indexes":[0,1]},"事故复盘":{"path":"/tag/%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/","indexes":[2]},"团队管理":{"path":"/tag/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/","indexes":[2]},"积累":{"path":"/tag/%E7%A7%AF%E7%B4%AF/","indexes":[6]},"职业规划":{"path":"/tag/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/","indexes":[3]},"个人能力":{"path":"/tag/%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B/","indexes":[3]},"改变":{"path":"/tag/%E6%94%B9%E5%8F%98/","indexes":[4]},"习惯":{"path":"/tag/%E4%B9%A0%E6%83%AF/","indexes":[4]},"职场PPT":{"path":"/tag/%E8%81%8C%E5%9C%BAppt/","indexes":[5]},"PPT美化":{"path":"/tag/ppt%E7%BE%8E%E5%8C%96/","indexes":[5]},"职场":{"path":"/tag/%E8%81%8C%E5%9C%BA/","indexes":[7]},"方法论":{"path":"/tag/%E6%96%B9%E6%B3%95%E8%AE%BA/","indexes":[7]},"思维模型":{"path":"/tag/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/","indexes":[7]},"汇报":{"path":"/tag/%E6%B1%87%E6%8A%A5/","indexes":[7]},"总结":{"path":"/tag/%E6%80%BB%E7%BB%93/","indexes":[7]},"分布式":{"path":"/tag/%E5%88%86%E5%B8%83%E5%BC%8F/","indexes":[12,13,14,15,16,17,18]},"HEIF":{"path":"/tag/heif/","indexes":[31,32]},"环境安装":{"path":"/tag/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","indexes":[31]},"图片格式":{"path":"/tag/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/","indexes":[31]},"编解码器":{"path":"/tag/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/","indexes":[31]},"ISOBMFF":{"path":"/tag/isobmff/","indexes":[32]},"多媒体格式":{"path":"/tag/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/","indexes":[32]},"容器格式":{"path":"/tag/%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F/","indexes":[32]},"Electron":{"path":"/tag/electron/","indexes":[33]},"macOS":{"path":"/tag/macos/","indexes":[33]},"应用打包":{"path":"/tag/%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85/","indexes":[33]},"代码签名":{"path":"/tag/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/","indexes":[33]},"发布":{"path":"/tag/%E5%8F%91%E5%B8%83/","indexes":[33]},"github工作流":{"path":"/tag/github%E5%B7%A5%E4%BD%9C%E6%B5%81/","indexes":[37]},"github Action":{"path":"/tag/github-action/","indexes":[37]},"jsdelivr":{"path":"/tag/jsdelivr/","indexes":[36]},"CDN":{"path":"/tag/cdn/","indexes":[36]},"icns图标":{"path":"/tag/icns%E5%9B%BE%E6%A0%87/","indexes":[35]},"iconutil":{"path":"/tag/iconutil/","indexes":[35]},"paypal支付":{"path":"/tag/paypal%E6%94%AF%E4%BB%98/","indexes":[39]},"piclist":{"path":"/tag/piclist/","indexes":[34]},"GEO优化":{"path":"/tag/geo%E4%BC%98%E5%8C%96/","indexes":[40,41]},"AI搜索":{"path":"/tag/ai%E6%90%9C%E7%B4%A2/","indexes":[40,41]},"内容营销":{"path":"/tag/%E5%86%85%E5%AE%B9%E8%90%A5%E9%94%80/","indexes":[40,41]},"生成式引擎优化":{"path":"/tag/%E7%94%9F%E6%88%90%E5%BC%8F%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/","indexes":[40,41]},"插件":{"path":"/tag/%E6%8F%92%E4%BB%B6/","indexes":[42]},"博客":{"path":"/tag/%E5%8D%9A%E5%AE%A2/","indexes":[42]},"LLM":{"path":"/tag/llm/","indexes":[96,97,98,99,38,100,101,102]},"hugging face":{"path":"/tag/hugging-face/","indexes":[38]},"hf":{"path":"/tag/hf/","indexes":[38]},"健身":{"path":"/tag/%E5%81%A5%E8%BA%AB/","indexes":[43,44]},"架构设计":{"path":"/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","indexes":[8,9,10,11,45,129,19,20,21,22,23,24,25,26,27,28,29,30]},"学习路径":{"path":"/tag/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","indexes":[46]},"思维导图":{"path":"/tag/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","indexes":[47]},"参考书籍":{"path":"/tag/%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D/","indexes":[48]},"TCP/IP 五层":{"path":"/tag/tcpip-%E4%BA%94%E5%B1%82/","indexes":[92]},"TCP":{"path":"/tag/tcp/","indexes":[86,88,91,93]},"MAC":{"path":"/tag/mac/","indexes":[90]},"IP":{"path":"/tag/ip/","indexes":[89]},"HTTP":{"path":"/tag/http/","indexes":[83]},"HTTP2":{"path":"/tag/http2/","indexes":[83]},"TLS":{"path":"/tag/tls/","indexes":[83,84]},"QUIC":{"path":"/tag/quic/","indexes":[83]},"HTTP3":{"path":"/tag/http3/","indexes":[83]},"IO":{"path":"/tag/io/","indexes":[87]},"NIO":{"path":"/tag/nio/","indexes":[87]},"AIO":{"path":"/tag/aio/","indexes":[87]},"AES":{"path":"/tag/aes/","indexes":[84]},"非对称加密":{"path":"/tag/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","indexes":[84]},"socket编程":{"path":"/tag/socket%E7%BC%96%E7%A8%8B/","indexes":[85]},"面试":{"path":"/tag/%E9%9D%A2%E8%AF%95/","indexes":[95]},"简历":{"path":"/tag/%E7%AE%80%E5%8E%86/","indexes":[94]},"概念":{"path":"/tag/%E6%A6%82%E5%BF%B5/","indexes":[102]},"GPT":{"path":"/tag/gpt/","indexes":[101]},"Prompt":{"path":"/tag/prompt/","indexes":[98,99,100]},"性能分析":{"path":"/tag/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","indexes":[106,112,114,115,116,119,120,121]},"可视化":{"path":"/tag/%E5%8F%AF%E8%A7%86%E5%8C%96/","indexes":[106,112,114,115]},"FlameGraph":{"path":"/tag/flamegraph/","indexes":[115]},"trace":{"path":"/tag/trace/","indexes":[114]},"Systemtap新手指南":{"path":"/tag/systemtap%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97/","indexes":[117]},"Systemtap":{"path":"/tag/systemtap/","indexes":[117,118]},"Systemtap手册":{"path":"/tag/systemtap%E6%89%8B%E5%86%8C/","indexes":[118]},"SystemTap语法":{"path":"/tag/systemtap%E8%AF%AD%E6%B3%95/","indexes":[118]},"SystemTap":{"path":"/tag/systemtap/","indexes":[113,116,119,120,121]},"eBPF":{"path":"/tag/ebpf/","indexes":[112]},"nginx源码":{"path":"/tag/nginx%E6%BA%90%E7%A0%81/","indexes":[119]},"TCP FIN":{"path":"/tag/tcp-fin/","indexes":[119]},"TCP RST":{"path":"/tag/tcp-rst/","indexes":[119]},"wireshark":{"path":"/tag/wireshark/","indexes":[103,105,107,108,110]},"抓包":{"path":"/tag/%E6%8A%93%E5%8C%85/","indexes":[103,104,105,107,108,109,110]},"chunk格式":{"path":"/tag/chunk%E6%A0%BC%E5%BC%8F/","indexes":[107]},"tomcat":{"path":"/tag/tomcat/","indexes":[110]},"host错误":{"path":"/tag/host%E9%94%99%E8%AF%AF/","indexes":[105]},"网络分析":{"path":"/tag/%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/","indexes":[104,108]},"TSL握手失败":{"path":"/tag/tsl%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5/","indexes":[108,109]},"网络问题分析":{"path":"/tag/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/","indexes":[109]},"wireshark抓包":{"path":"/tag/wireshark%E6%8A%93%E5%8C%85/","indexes":[104,109]},"故障排查":{"path":"/tag/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/","indexes":[104]},"icmp":{"path":"/tag/icmp/","indexes":[103]},"压力测试":{"path":"/tag/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/","indexes":[111]},"瓶颈分析":{"path":"/tag/%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/","indexes":[111]},"P99X":{"path":"/tag/p99x/","indexes":[111]},"Locust":{"path":"/tag/locust/","indexes":[111]},"性能测试":{"path":"/tag/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","indexes":[111]},"API测试":{"path":"/tag/api%E6%B5%8B%E8%AF%95/","indexes":[111]},"GDB":{"path":"/tag/gdb/","indexes":[106]},"luajit":{"path":"/tag/luajit/","indexes":[106]},"btrace":{"path":"/tag/btrace/","indexes":[106]},"Docker":{"path":"/tag/docker/","indexes":[123]},"minikube":{"path":"/tag/minikube/","indexes":[122]},"消息队列":{"path":"/tag/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","indexes":[128,126,127]},"基础理论":{"path":"/tag/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","indexes":[28]},"CAP定理":{"path":"/tag/cap%E5%AE%9A%E7%90%86/","indexes":[28]},"ACID":{"path":"/tag/acid/","indexes":[28]},"BASE":{"path":"/tag/base/","indexes":[28]},"分布式事务":{"path":"/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","indexes":[11]},"一致性算法":{"path":"/tag/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/","indexes":[10]},"共识算法":{"path":"/tag/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/","indexes":[9,27]},"分布式通信":{"path":"/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/","indexes":[26]},"高性能设计":{"path":"/tag/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/","indexes":[8]},"序列化":{"path":"/tag/%E5%BA%8F%E5%88%97%E5%8C%96/","indexes":[24]},"分布式故障模型":{"path":"/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B/","indexes":[23]},"唯一ID":{"path":"/tag/%E5%94%AF%E4%B8%80id/","indexes":[22]},"基础定义":{"path":"/tag/%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89/","indexes":[59]},"golang":{"path":"/tag/golang/","indexes":[130,131]},"笔记":{"path":"/tag/%E7%AC%94%E8%AE%B0/","indexes":[132,133,134,135,136,137,138,139,140,141,142,143,124,144,145]},"java":{"path":"/tag/java/","indexes":[146]},"数据库":{"path":"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/","indexes":[147]},"ES":{"path":"/tag/es/","indexes":[148]},"Mysql":{"path":"/tag/mysql/","indexes":[149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165]},"逻辑架构":{"path":"/tag/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","indexes":[165]},"日志系统":{"path":"/tag/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","indexes":[164]},"事务隔离级别":{"path":"/tag/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","indexes":[163]},"锁":{"path":"/tag/%E9%94%81/","indexes":[162]},"行记录":{"path":"/tag/%E8%A1%8C%E8%AE%B0%E5%BD%95/","indexes":[161]},"数据页":{"path":"/tag/%E6%95%B0%E6%8D%AE%E9%A1%B5/","indexes":[160]},"索引":{"path":"/tag/%E7%B4%A2%E5%BC%95/","indexes":[157,159]},"表空间":{"path":"/tag/%E8%A1%A8%E7%A9%BA%E9%97%B4/","indexes":[158]},"索引合并":{"path":"/tag/%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/","indexes":[156]},"连表查询":{"path":"/tag/%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/","indexes":[155]},"explain":{"path":"/tag/explain/","indexes":[154]},"性能优化":{"path":"/tag/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","indexes":[153,154]},"optimize":{"path":"/tag/optimize/","indexes":[153]},"缓冲池":{"path":"/tag/%E7%BC%93%E5%86%B2%E6%B1%A0/","indexes":[152]},"BufferPool":{"path":"/tag/bufferpool/","indexes":[152]},"SQL":{"path":"/tag/sql/","indexes":[151]},"主从同步":{"path":"/tag/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/","indexes":[168,150]},"数据库选型":{"path":"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B/","indexes":[149]},"Redis":{"path":"/tag/redis/","indexes":[166,167,168,169,170,171,172,173,174]},"数据类型":{"path":"/tag/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","indexes":[174]},"底层数据结构":{"path":"/tag/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","indexes":[174]},"全局哈希表":{"path":"/tag/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8/","indexes":[173]},"键值对结构":{"path":"/tag/%E9%94%AE%E5%80%BC%E5%AF%B9%E7%BB%93%E6%9E%84/","indexes":[173]},"线程模型":{"path":"/tag/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","indexes":[172]},"淘汰策略":{"path":"/tag/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/","indexes":[171]},"删除策略":{"path":"/tag/%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/","indexes":[171]},"持久化":{"path":"/tag/%E6%8C%81%E4%B9%85%E5%8C%96/","indexes":[169,170]},"AOF":{"path":"/tag/aof/","indexes":[170]},"RDB":{"path":"/tag/rdb/","indexes":[169]},"repl_backlog_buffer":{"path":"/tag/repl-backlog-buffer/","indexes":[168]},"哨兵机制":{"path":"/tag/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/","indexes":[167]},"Sentinel":{"path":"/tag/sentinel/","indexes":[167]},"分片集群":{"path":"/tag/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/","indexes":[166]},"Sharding":{"path":"/tag/sharding/","indexes":[166]},"kafka":{"path":"/tag/kafka/","indexes":[125]},"nsq":{"path":"/tag/nsq/","indexes":[128]},"RocketMQ":{"path":"/tag/rocketmq/","indexes":[126]},"设计模式":{"path":"/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","indexes":[175,176]},"线性表":{"path":"/tag/%E7%BA%BF%E6%80%A7%E8%A1%A8/","indexes":[82]},"数组":{"path":"/tag/%E6%95%B0%E7%BB%84/","indexes":[81]},"列表":{"path":"/tag/%E5%88%97%E8%A1%A8/","indexes":[80]},"链表":{"path":"/tag/%E9%93%BE%E8%A1%A8/","indexes":[79]},"栈":{"path":"/tag/%E6%A0%88/","indexes":[78]},"队列":{"path":"/tag/%E9%98%9F%E5%88%97/","indexes":[77]},"散列表":{"path":"/tag/%E6%95%A3%E5%88%97%E8%A1%A8/","indexes":[76]},"哈希函数":{"path":"/tag/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/","indexes":[75]},"冲突处理":{"path":"/tag/%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","indexes":[74]},"动态扩容":{"path":"/tag/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9/","indexes":[73]},"位图":{"path":"/tag/%E4%BD%8D%E5%9B%BE/","indexes":[72]},"树":{"path":"/tag/%E6%A0%91/","indexes":[71]},"二叉树":{"path":"/tag/%E4%BA%8C%E5%8F%89%E6%A0%91/","indexes":[70]},"AVL平衡树":{"path":"/tag/avl%E5%B9%B3%E8%A1%A1%E6%A0%91/","indexes":[69]},"红黑树":{"path":"/tag/%E7%BA%A2%E9%BB%91%E6%A0%91/","indexes":[68]},"多路查找树":{"path":"/tag/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/","indexes":[67]},"堆":{"path":"/tag/%E5%A0%86/","indexes":[57,66]},"Heap":{"path":"/tag/heap/","indexes":[66]},"图":{"path":"/tag/%E5%9B%BE/","indexes":[65]},"Graph":{"path":"/tag/graph/","indexes":[65]},"图的存储":{"path":"/tag/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/","indexes":[64]},"拓扑排序":{"path":"/tag/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","indexes":[63]},"关键路径":{"path":"/tag/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/","indexes":[62]},"最短路径":{"path":"/tag/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","indexes":[61]},"最小生成树":{"path":"/tag/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","indexes":[60]},"复杂度分析":{"path":"/tag/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","indexes":[58]},"排序算法":{"path":"/tag/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","indexes":[49]},"算法":{"path":"/tag/%E7%AE%97%E6%B3%95/","indexes":[50,51,52,53]},"搜索算法":{"path":"/tag/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","indexes":[50]},"二分查找":{"path":"/tag/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","indexes":[51]},"遍历算法":{"path":"/tag/%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","indexes":[52]},"深度优先":{"path":"/tag/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/","indexes":[52]},"广度优先":{"path":"/tag/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/","indexes":[52]},"搜索树":{"path":"/tag/%E6%90%9C%E7%B4%A2%E6%A0%91/","indexes":[53]},"递归算法":{"path":"/tag/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","indexes":[54]},"桶排序":{"path":"/tag/%E6%A1%B6%E6%8E%92%E5%BA%8F/","indexes":[55]},"计数排序":{"path":"/tag/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","indexes":[55]},"基数排序":{"path":"/tag/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","indexes":[55]},"冒泡":{"path":"/tag/%E5%86%92%E6%B3%A1/","indexes":[56]},"插入":{"path":"/tag/%E6%8F%92%E5%85%A5/","indexes":[56]},"选择":{"path":"/tag/%E9%80%89%E6%8B%A9/","indexes":[56]},"快速":{"path":"/tag/%E5%BF%AB%E9%80%9F/","indexes":[57]},"归并":{"path":"/tag/%E5%BD%92%E5%B9%B6/","indexes":[57]},"希尔":{"path":"/tag/%E5%B8%8C%E5%B0%94/","indexes":[57]}}}}}')},98047:(e,n,a)=>{a.d(n,{P:()=>i});const i={GitHub:'<svg xmlns="http://www.w3.org/2000/svg" class="vp-social-media-icon github-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#171515"/><path fill="#fff" d="M509.423 146.442c-200.317 0-362.756 162.42-362.756 362.8 0 160.266 103.936 296.24 248.109 344.217 18.139 3.327 24.76-7.872 24.76-17.486 0-8.613-.313-31.427-.49-61.702-100.912 21.923-122.205-48.63-122.205-48.63-16.495-41.91-40.28-53.067-40.28-53.067-32.937-22.51 2.492-22.053 2.492-22.053 36.407 2.566 55.568 37.386 55.568 37.386 32.362 55.438 84.907 39.43 105.58 30.143 3.296-23.444 12.667-39.43 23.032-48.498-80.557-9.156-165.246-40.28-165.246-179.297 0-39.604 14.135-71.988 37.342-97.348-3.731-9.178-16.18-46.063 3.556-96.009 0 0 30.46-9.754 99.76 37.19 28.937-8.048 59.97-12.071 90.823-12.211 30.807.14 61.843 4.165 90.822 12.21 69.26-46.944 99.663-37.189 99.663-37.189 19.792 49.946 7.34 86.831 3.61 96.01 23.25 25.359 37.29 57.742 37.29 97.347 0 139.366-84.82 170.033-165.637 179.013 13.026 11.2 24.628 33.342 24.628 67.182 0 48.498-.445 87.627-.445 99.521 0 9.702 6.535 20.988 24.945 17.444 144.03-48.067 247.881-183.95 247.881-344.175 0-200.378-162.442-362.798-362.802-362.798z"/></svg>',Email:'<svg xmlns="http://www.w3.org/2000/svg" class="vp-social-media-icon email-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#1384FF"/><path fill="#fff" d="M270.077 286.233H751.99c32.933 0 59.86 24.855 60.274 55.51l-301.023 157L210.217 341.88c.207-30.723 26.927-55.717 59.86-55.717zm-59.929 115.714-.276 277.756c0 30.931 27.134 56.2 60.205 56.2H751.99c33.14 0 60.274-25.269 60.274-56.2V401.81L518.283 551.492a15.88 15.88 0 0 1-14.43 0L210.148 401.947z"/></svg>',Gmail:'<svg xmlns="http://www.w3.org/2000/svg" class="vp-social-media-icon gmail-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#DB4437"/><path fill="#E67C73" d="M277.48 285.567h465.767v441.362H277.48V285.567z"/><path fill="#FFF" d="M282.543 285.567h-10.645c-25.962 0-47.122 21.808-47.122 48.705v343.952c0 26.897 21.08 48.705 47.122 48.705h24.976V407.954l213.49 169.95 213.489-169.95V726.93h24.975c26.04 0 47.123-21.809 47.123-48.705V334.272c0-26.897-21.134-48.705-47.123-48.705h-10.644L510.364 480.44 282.542 285.567z"/></svg>'}},98589:(e,n,a)=>{a.d(n,{M:()=>i});const i=JSON.parse('["/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html","/encrypt/","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98.html","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%81%9A%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92.html","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%85%BB%E6%88%90%E5%BE%AE%E4%B9%A0%E6%83%AF.html","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDPPT.html","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%B7%A5%E4%BD%9C.html","/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/%E8%81%8C%E5%9C%BA%E6%96%B9%E6%B3%95%E8%AE%BA.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/09._%E9%AB%98%E6%80%A7%E8%83%BD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/06.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E5%8F%AF%E4%BF%A1.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/05.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/04.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/2025%E6%8F%90%E6%95%88%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/k8s.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/zookeeper/%E5%8E%9F%E7%90%86.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/nacos/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/etcd/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/consul/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E5%BB%BA/chubby/","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/13.%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/12.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/11.%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/10._%E5%A6%82%E4%BD%95%E5%81%9A%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/08.%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/07.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-%E9%9D%9E%E5%8F%AF%E4%BF%A1.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BA%B2.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/HEIF%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%AE%89%E8%A3%85.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/ISOBMFF%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/electron.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/piclist.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/mac%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90icns%E5%9B%BE%E6%A0%87.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/jsdeliver.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/github_action.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%99%BD%E5%AB%96huggingface%E7%9A%84API.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/paypal%E6%94%AF%E4%BB%98.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%85%B3%E4%BA%8EGEO%E4%BC%98%E5%8C%96.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/04.%E5%BA%94%E7%94%A8/%E5%85%B3%E4%BA%8EGEO%E4%BC%98%E5%8C%96Generative-Engine-Optimization.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html","/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/%E4%BE%9B%E8%83%BD%E7%B3%BB%E7%BB%9F.html","/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/%E4%BB%A3%E8%B0%A2%E7%B3%BB%E7%BB%9F.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/06.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/0.%E6%90%9C%E7%B4%A2.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/2.%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/3.%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_k)/%E6%A1%B6%E3%80%81%E8%AE%A1%E6%95%B0%E3%80%81%E5%9F%BA%E6%95%B0.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(nlogn)/%E5%BF%AB%E9%80%9F%E3%80%81%E5%BD%92%E5%B9%B6%E3%80%81%E5%A0%86%E3%80%81%E5%B8%8C%E5%B0%94.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/1.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/00.%E5%AE%9A%E4%B9%89.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/5.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/4.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/3.%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/2.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/1.%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%9B%BE/0.%E5%9B%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/6.%E5%A0%86.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/5.%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/4.%E7%BA%A2%E9%BB%91%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/3.AVL%E5%B9%B3%E8%A1%A1%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/2.%E4%BA%8C%E5%8F%89%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%91/1.%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/5.%E4%BD%8D%E5%9B%BE.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/4.%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/3.%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/2.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8/1.%E6%95%A3%E5%88%97%E8%A1%A8.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/4.%E9%98%9F%E5%88%97.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/3.%E6%A0%88.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/2.%E9%93%BE%E8%A1%A8.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/2.1%E5%88%97%E8%A1%A8.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.%E6%95%B0%E7%BB%84.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/0.%E7%BA%BF%E6%80%A7%E8%A1%A8.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81HTTP%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/09.SSH%E5%85%AC%E7%A7%81%E9%92%A5%E9%AA%8C%E8%AF%81.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.socket%E7%BC%96%E7%A8%8B.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/08.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6IO%E4%BC%98%E5%8C%96.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.%E7%BD%91%E7%BB%9CIO%E6%8A%80%E6%9C%AF-%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/05.%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%81TCP%EF%BC%88%E5%9B%9B%E5%B1%82%EF%BC%89.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.%E7%BD%91%E7%BB%9C%E5%B1%82%E3%80%81IP%EF%BC%88%E4%B8%89%E5%B1%82%EF%BC%89.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81MAC%EF%BC%88%E4%BA%8C%E5%B1%82%EF%BC%89.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%E5%B1%82%EF%BC%89.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html","/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/50.%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%98%E7%9B%AE.html","/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/%E7%AE%80%E5%8E%86%E6%A8%A1%E7%89%88.html","/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/Ready4Interview.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/01.%E6%A1%86%E6%9E%B6/langchain.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/01.%E6%A1%86%E6%9E%B6/eino.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/04.Models.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/03.Prompt.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/04.%E5%BA%94%E7%94%A8/%E7%99%BD%E5%AB%96huggingface%E7%9A%84API.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/02.GPT.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/00.%E6%A6%82%E5%BF%B5/01.Transformer.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHost%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%9D%99%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFGDB/python%E8%BF%90%E8%A1%8Cgdb.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHTTP%E7%8A%B6%E6%80%81%E7%A0%81200%E7%9A%84%E5%BC%82%E5%B8%B8.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BSSL%E6%8F%A1%E6%89%8B%E9%97%AE%E9%A2%98.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BSSL%E6%8F%A1%E6%89%8B%E9%97%AE%E9%A2%98%E4%BA%8C.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHost%E6%A0%A1%E9%AA%8C%E7%9A%84%E5%BC%82%E5%B8%B8.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/API%E5%8E%8B%E6%B5%8B%E6%A1%86%E6%9E%B6%E4%B9%8Blocust.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/eBPF%E6%8A%80%E6%9C%AF.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-tapset.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/FlameGraph-%E7%81%AB%E7%84%B0%E5%9B%BE.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemtap%E7%AC%94%E8%AE%B0.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-Beginners-Guide%E4%B8%AD%E6%96%87%E7%89%88.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/Systemtap-Language-Reference%E4%B8%AD%E6%96%87%E7%89%88.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%88%86%E6%9E%90.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%8E%9F%E7%90%86.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%AE%89%E8%A3%85.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/minikube.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E5%AE%B9%E5%99%A8%E5%8C%96/docker.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/kafka%E5%8E%9F%E7%90%86.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/RocketMQ%E5%8E%9F%E7%90%86.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/nsq/","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/05.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%91%E5%8E%9F%E7%94%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/CSP%E3%80%81channel.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9D%99%E6%80%81%E6%97%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%AD%E8%A8%80%EF%BC%89.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/context.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.WaitGroup%E3%80%81sync.Once.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Mutext%E3%80%81sync.RWMutex.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync.Cond.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/sync/atomic.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/select.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/panic%E3%80%81recover%E3%80%81defer.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/options%E5%87%BD%E6%95%B0%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/map.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface%E5%92%8Cstruct%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/goroutine.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/gc.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/array%E3%80%81slice.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse/%E5%8E%9F%E7%90%86.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticSearch/%E5%8E%9F%E7%90%86.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/19.%E5%B8%B8%E8%A7%81%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/18.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/17.Sql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/16.%E7%BC%93%E5%86%B2%E6%B1%A0-BufferPool.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/15.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-optimizeTrace%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/14.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-explain%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%B3%E7%AD%96%E7%BB%93%E6%9E%9C.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/13.%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2-join.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/12.%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6-indexMerge.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/11.%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10.%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/09.%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/08.%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/07.%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06.%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/02.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/01.Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/10.%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-Sharding.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/09.%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-Sentinel.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/08.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5-Slave.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/07.%E6%8C%81%E4%B9%85%E5%8C%96-RDB.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/06.%E6%8C%81%E4%B9%85%E5%8C%96-AOF.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/04.%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/03.%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02.%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.html","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E7%BA%B2.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/Mermaid%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%8E%A7%E5%88%B6%E8%AF%AD%E6%B3%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/strongbox.html","/map.html","/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/markdown%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/02.RAG/RAG.html","/%E5%A4%A7%E6%A8%A1%E5%9E%8BLLM/03.%E5%BE%AE%E8%B0%83/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/QA.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/dubbo.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/flask.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/gin.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/netty.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/openresty.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/04.WEB%E6%A1%86%E6%9E%B6/springboot.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lua/","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/","/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/opensearch/","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%A4%A7%E7%BA%B2%E5%9B%BE%E8%A7%A3.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1-Idempotency.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1-Asynchronous.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81-State.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%86%94%E6%96%AD%E8%AE%BE%E8%AE%A1-Circuit-Breaker.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1-CompensatingTransaction.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1-Retry.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%99%8D%E7%BA%A7%E8%AE%BE%E8%AE%A1-degradation.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1-Throttle.html","/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1-Bulkheads.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/AC%E8%87%AA%E5%8A%A8%E6%9C%BA.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/KMP.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/LSM-Tree.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/Tier%E6%A0%91.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/%E6%9C%B4%E7%B4%A0.html","/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/6.%E5%85%B6%E4%BB%96/%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/go%E6%80%BB%E7%BB%93.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect.html","/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%A0%87%E5%87%86%E5%BA%93/unsafe.html"]')}},e=>{e.O(0,[51451,1181],(()=>e(e.s=13160))),e.O()}]);
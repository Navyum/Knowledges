"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[82149],{4502:(l,e,i)=>{i.r(e),i.d(e,{comp:()=>t,data:()=>s});var n=i(6254);const a={},t=(0,i(36995).A)(a,[["render",function(l,e){const i=(0,n.g2)("font");return(0,n.uX)(),(0,n.CE)("div",null,[e[11]||(e[11]=(0,n.Fv)('<h2 id="过期删除策略" tabindex="-1"><a class="header-anchor" href="#过期删除策略"><span>过期删除策略：</span></a></h2><ul><li><p>场景：针对业务使用，key如果设置了有效期，过期后会进行删除</p></li><li><p>过期时间的存储结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct redisDb {</span></span>\n<span class="line"><span>    dict *dict;    /* 数据库键空间，存放着所有的键值对 */</span></span>\n<span class="line"><span>    dict *expires; /* 键的过期时间 */</span></span>\n<span class="line"><span>    ....</span></span>\n<span class="line"><span>} redisDb;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>删除过程：</p><ol><li>查询key时，先从<code>expires</code>过期哈希表中查找</li><li>如果过期哈希表中存在该key，则比较存储的时间和系统时间确定是否过期。</li><li>如果不存在、或者key未过期，则返回key对应value</li><li>如果key存在，且已过期，则返回null</li></ol></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3bd65bf45ac843e5e929c68a78f2a1e7.png" alt="Img" loading="lazy"></p></li><li><p>一般的过期删除策略：</p><ul><li>定时删除： <ul><li>定义：给key创建定时删除事件，时间达到则删除</li><li>优点：删除更实时，内存释放更快</li><li>缺点：内存不紧张时，也会耗费CPU资源</li></ul></li><li>惰性删除： <ul><li>定义：不主动删除过期键，仅当key被访问时，判断是否过期，从而决定是否（同步/异步）删除。</li><li>优点：占用CPU相对更少</li><li>缺点：读少、写多时，内存可能得不到释放</li></ul></li><li>定期删除： <ul><li>定义：每隔一段时间<code>随机</code>从expires哈希表取出一定数量的 key进行检查，删除其中的过期key</li><li>优点：折中方案，通过检查频率，限制CPU的使用，并且能相对及时清理内存</li><li>缺点：删除操作的时长和频率无法把控，频率太低或者太高都不好</li></ul></li></ul></li><li><p>Redis过期删除策略：</p><ul><li><code>惰性删除</code> + <code>定期删除</code>组合使用</li><li>同步 or 异步删除，Redis&gt;=4.0 通过<code>lazyfree-lazy-expire</code>配置</li><li>频率：默认每秒进行10次过期检查</li><li>随机数量：20个</li><li>额外逻辑： <ul><li>一次检查中，如果超过25%的key过期，则再次获取20个key</li><li>一次检查的最大时间限制：默认25ms。防止因为有大量key过期，一直陷在检查中，导致程序卡死。</li></ul></li><li>疑问？：频率*最大时间限制超过了1s</li></ul></li></ul><h2 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略：</span></a></h2>',3)),(0,n.Lk)("ul",null,[e[10]||(e[10]=(0,n.Lk)("li",null,"场景：针对系统保护，如果内存使用超过设置的内存上限，就会触发淘汰",-1)),(0,n.Lk)("li",null,[e[9]||(e[9]=(0,n.eW)("内存淘汰策略分类： ")),(0,n.Lk)("ul",null,[e[8]||(e[8]=(0,n.Lk)("li",null,[(0,n.eW)("不淘汰： "),(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"noeviction"),(0,n.eW)("：如果内存不够，触发OOM")])])],-1)),(0,n.Lk)("li",null,[e[7]||(e[7]=(0,n.eW)("淘汰： ")),(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[e[5]||(e[5]=(0,n.eW)("针对有过期时间的数据淘汰： ")),(0,n.Lk)("ul",null,[e[2]||(e[2]=(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"volatile-random"),(0,n.eW)("：随机淘汰有过期时间的key")],-1)),e[3]||(e[3]=(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"volatile-ttl"),(0,n.eW)("：优先淘汰更早过期的key")],-1)),e[4]||(e[4]=(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"volatile-lru"),(0,n.eW)("：优先淘汰最久未使用的key；")],-1)),(0,n.Lk)("li",null,[(0,n.bF)(i,{color:"ff0000"},{default:(0,n.k6)((()=>e[0]||(e[0]=[(0,n.eW)("`volatile-lfu`")]))),_:1}),e[1]||(e[1]=(0,n.eW)("：优先淘汰最少使用的key；（4.0开始默认策略）"))])])]),e[6]||(e[6]=(0,n.Lk)("li",null,[(0,n.eW)("针对全部数据淘汰： "),(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"allkeys-random"),(0,n.eW)("：随机淘汰任意key;")]),(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"allkeys-lru"),(0,n.eW)("：优先淘汰最久未使用的key；")]),(0,n.Lk)("li",null,[(0,n.Lk)("code",null,"allkeys-lfu"),(0,n.eW)("：优先淘汰最少使用的key；")])])],-1))])])])])]),e[12]||(e[12]=(0,n.Fv)("<ul><li>Redis中的<code>LRU</code>(Least Recently Used)： <ul><li>是一种<code>近似LRU</code></li><li>在每个key对象中记录最近一次访问时间，每次触发淘汰时，随机选5个key，淘汰其中时间最早的那个。（如果是volatile，则从过期哈希表中找）</li><li>优点： <ul><li>不需要大链表，节省内存</li><li>不需要频繁将被访问数据插入表头</li></ul></li><li>缺点： <ul><li><code>缓存污染</code>：一次取出大量数据，将热数据置换出去，导致缓存命中率下降</li></ul></li></ul></li><li>Redis中的<code>LFU</code>(Least Frequently Used)： <ul><li>在每个key对象中记录单位时间内的访问频率，每次触发淘汰时，随机选5个key，淘汰其中频率最低的key</li><li>优点：同LRU，并且解决了<code>缓存污染</code>问题</li></ul></li></ul>",1))])}]]),s=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/04.%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html","title":"04.淘汰策略","lang":"zh-CN","frontmatter":{"title":"04.淘汰策略","date":"2025-06-17T15:38:05.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","淘汰策略","删除策略"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"过期删除策略： 场景：针对业务使用，key如果设置了有效期，过期后会进行删除 过期时间的存储结构： 删除过程： 查询key时，先从expires过期哈希表中查找 如果过期哈希表中存在该key，则比较存储的时间和系统时间确定是否过期。 如果不存在、或者key未过期，则返回key对应value 如果key存在，且已过期，则返回null 图解： Img 一般...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/04.%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"04.淘汰策略"}],["meta",{"property":"og:description","content":"过期删除策略： 场景：针对业务使用，key如果设置了有效期，过期后会进行删除 过期时间的存储结构： 删除过程： 查询key时，先从expires过期哈希表中查找 如果过期哈希表中存在该key，则比较存储的时间和系统时间确定是否过期。 如果不存在、或者key未过期，则返回key对应value 如果key存在，且已过期，则返回null 图解： Img 一般..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3bd65bf45ac843e5e929c68a78f2a1e7.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"淘汰策略"}],["meta",{"property":"article:tag","content":"删除策略"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:38:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"04.淘汰策略\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3bd65bf45ac843e5e929c68a78f2a1e7.png\\"],\\"datePublished\\":\\"2025-06-17T15:38:05.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":3.06,"words":919},"filePathRelative":"常用软件/数据库/redis/04.淘汰策略.md","localizedDate":"2025年6月17日","excerpt":"<h2>过期删除策略：</h2>\\n<ul>\\n<li>\\n<p>场景：针对业务使用，key如果设置了有效期，过期后会进行删除</p>\\n</li>\\n<li>\\n<p>过期时间的存储结构：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>typedef struct redisDb {</span></span>\\n<span class=\\"line\\"><span>    dict *dict;    /* 数据库键空间，存放着所有的键值对 */</span></span>\\n<span class=\\"line\\"><span>    dict *expires; /* 键的过期时间 */</span></span>\\n<span class=\\"line\\"><span>    ....</span></span>\\n<span class=\\"line\\"><span>} redisDb;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>删除过程：</p>\\n<ol>\\n<li>查询key时，先从<code>expires</code>过期哈希表中查找</li>\\n<li>如果过期哈希表中存在该key，则比较存储的时间和系统时间确定是否过期。</li>\\n<li>如果不存在、或者key未过期，则返回key对应value</li>\\n<li>如果key存在，且已过期，则返回null</li>\\n</ol>\\n</li>\\n<li>\\n<p>图解：\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3bd65bf45ac843e5e929c68a78f2a1e7.png\\" alt=\\"Img\\" loading=\\"lazy\\"></p>\\n</li>\\n<li>\\n<p>一般的过期删除策略：</p>\\n<ul>\\n<li>定时删除：\\n<ul>\\n<li>定义：给key创建定时删除事件，时间达到则删除</li>\\n<li>优点：删除更实时，内存释放更快</li>\\n<li>缺点：内存不紧张时，也会耗费CPU资源</li>\\n</ul>\\n</li>\\n<li>惰性删除：\\n<ul>\\n<li>定义：不主动删除过期键，仅当key被访问时，判断是否过期，从而决定是否（同步/异步）删除。</li>\\n<li>优点：占用CPU相对更少</li>\\n<li>缺点：读少、写多时，内存可能得不到释放</li>\\n</ul>\\n</li>\\n<li>定期删除：\\n<ul>\\n<li>定义：每隔一段时间<code>随机</code>从expires哈希表取出一定数量的 key进行检查，删除其中的过期key</li>\\n<li>优点：折中方案，通过检查频率，限制CPU的使用，并且能相对及时清理内存</li>\\n<li>缺点：删除操作的时长和频率无法把控，频率太低或者太高都不好</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Redis过期删除策略：</p>\\n<ul>\\n<li><code>惰性删除</code> + <code>定期删除</code>组合使用</li>\\n<li>同步 or 异步删除，Redis&gt;=4.0 通过<code>lazyfree-lazy-expire</code>配置</li>\\n<li>频率：默认每秒进行10次过期检查</li>\\n<li>随机数量：20个</li>\\n<li>额外逻辑：\\n<ul>\\n<li>一次检查中，如果超过25%的key过期，则再次获取20个key</li>\\n<li>一次检查的最大时间限制：默认25ms。防止因为有大量key过期，一直陷在检查中，导致程序卡死。</li>\\n</ul>\\n</li>\\n<li>疑问？：频率*最大时间限制超过了1s</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},36995:(l,e)=>{e.A=(l,e)=>{const i=l.__vccOpts||l;for(const[l,n]of e)i[l]=n;return i}}}]);
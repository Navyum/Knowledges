"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[50359],{36995:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},92042:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var e=a(6254);const i={},l=(0,a(36995).A)(i,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用：</span></a></h2><ul><li>用于树、图的遍历</li></ul><h2 id="广度优先" tabindex="-1"><a class="header-anchor" href="#广度优先"><span>广度优先：</span></a></h2><ul><li>广度优先遍历通常借助<code>队列</code>来实现。队列遵循<code>先进先出</code>的规则，而广度优先遍历则遵循<code>逐层推进</code>的规则</li><li>代码实现（树）：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 层序遍历 */</span></span>\n<span class="line"><span>func levelOrder(root *TreeNode) []any {</span></span>\n<span class="line"><span>    // 初始化队列，加入根节点</span></span>\n<span class="line"><span>    queue := list.New()</span></span>\n<span class="line"><span>    queue.PushBack(root)</span></span>\n<span class="line"><span>    // 初始化一个切片，用于保存遍历序列</span></span>\n<span class="line"><span>    nums := make([]any, 0)</span></span>\n<span class="line"><span>    for queue.Len() &gt; 0 {</span></span>\n<span class="line"><span>        // 队列出队</span></span>\n<span class="line"><span>        node := queue.Remove(queue.Front()).(*TreeNode)</span></span>\n<span class="line"><span>        // 保存节点值</span></span>\n<span class="line"><span>        nums = append(nums, node.Val)</span></span>\n<span class="line"><span>        if node.Left != nil {</span></span>\n<span class="line"><span>            // 左子节点入队</span></span>\n<span class="line"><span>            queue.PushBack(node.Left)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if node.Right != nil {</span></span>\n<span class="line"><span>            // 右子节点入队</span></span>\n<span class="line"><span>            queue.PushBack(node.Right)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    return nums</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="深度优先" tabindex="-1"><a class="header-anchor" href="#深度优先"><span>深度优先：</span></a></h2><ul><li>深度优先遍历通常借助<code>栈/递归</code>来实现。递归`先&quot;递&quot;后&quot;归&quot;的过程，根深度优先遍历“先走到尽头，再回溯继续”思想一致。</li><li>树的深度优先遍历，根据<code>根在左节点、右节点的先中后顺序</code>，分别对应前序遍历、中序遍历和后序遍历。</li><li>二叉搜索树因为<code>左子树中所有节点的值</code> &lt; <code>根节点的值</code> &lt; <code>右子树中所有节点的值</code>的特性，使用中序遍历即可得到<code>升序结果</code></li><li>代码实现：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 前序遍历 */</span></span>\n<span class="line"><span>func preOrder(node *TreeNode) {</span></span>\n<span class="line"><span>    if node == nil {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span>\n<span class="line"><span>    nums = append(nums, node.Val)</span></span>\n<span class="line"><span>    preOrder(node.Left)</span></span>\n<span class="line"><span>    preOrder(node.Right)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 中序遍历 */</span></span>\n<span class="line"><span>func inOrder(node *TreeNode) {</span></span>\n<span class="line"><span>    if node == nil {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span>\n<span class="line"><span>    inOrder(node.Left)</span></span>\n<span class="line"><span>    nums = append(nums, node.Val)</span></span>\n<span class="line"><span>    inOrder(node.Right)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 后序遍历 */</span></span>\n<span class="line"><span>func postOrder(node *TreeNode) {</span></span>\n<span class="line"><span>    if node == nil {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span>\n<span class="line"><span>    postOrder(node.Left)</span></span>\n<span class="line"><span>    postOrder(node.Right)</span></span>\n<span class="line"><span>    nums = append(nums, node.Val)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',6)]))}]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/2.%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE.html","title":"2.遍历查找","lang":"zh-CN","frontmatter":{"title":"2.遍历查找","author":"navyum","date":"2025-06-15T00:00:00.000Z","order":-1,"article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法","搜索算法"],"tag":["算法","遍历算法","深度优先","广度优先"],"description":"作用： 用于树、图的遍历 广度优先： 广度优先遍历通常借助队列来实现。队列遵循先进先出的规则，而广度优先遍历则遵循逐层推进的规则 代码实现（树）： 深度优先： 深度优先遍历通常借助栈/递归来实现。递归`先\\"递\\"后\\"归\\"的过程，根深度优先遍历“先走到尽头，再回溯继续”思想一致。 树的深度优先遍历，根据根在左节点、右节点的先中后顺序，分别对应前序遍历、中序...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/2.%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"2.遍历查找"}],["meta",{"property":"og:description","content":"作用： 用于树、图的遍历 广度优先： 广度优先遍历通常借助队列来实现。队列遵循先进先出的规则，而广度优先遍历则遵循逐层推进的规则 代码实现（树）： 深度优先： 深度优先遍历通常借助栈/递归来实现。递归`先\\"递\\"后\\"归\\"的过程，根深度优先遍历“先走到尽头，再回溯继续”思想一致。 树的深度优先遍历，根据根在左节点、右节点的先中后顺序，分别对应前序遍历、中序..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"遍历算法"}],["meta",{"property":"article:tag","content":"深度优先"}],["meta",{"property":"article:tag","content":"广度优先"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.遍历查找\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":1.53,"words":458},"filePathRelative":"算法数据结构/算法/3.搜索/2.遍历查找.md","localizedDate":"2025年6月15日","excerpt":"<h2>作用：</h2>\\n<ul>\\n<li>用于树、图的遍历</li>\\n</ul>\\n<h2>广度优先：</h2>\\n<ul>\\n<li>广度优先遍历通常借助<code>队列</code>来实现。队列遵循<code>先进先出</code>的规则，而广度优先遍历则遵循<code>逐层推进</code>的规则</li>\\n<li>代码实现（树）：<div class=\\"language-golang line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"golang\\" data-title=\\"golang\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/* 层序遍历 */</span></span>\\n<span class=\\"line\\"><span>func levelOrder(root *TreeNode) []any {</span></span>\\n<span class=\\"line\\"><span>    // 初始化队列，加入根节点</span></span>\\n<span class=\\"line\\"><span>    queue := list.New()</span></span>\\n<span class=\\"line\\"><span>    queue.PushBack(root)</span></span>\\n<span class=\\"line\\"><span>    // 初始化一个切片，用于保存遍历序列</span></span>\\n<span class=\\"line\\"><span>    nums := make([]any, 0)</span></span>\\n<span class=\\"line\\"><span>    for queue.Len() &gt; 0 {</span></span>\\n<span class=\\"line\\"><span>        // 队列出队</span></span>\\n<span class=\\"line\\"><span>        node := queue.Remove(queue.Front()).(*TreeNode)</span></span>\\n<span class=\\"line\\"><span>        // 保存节点值</span></span>\\n<span class=\\"line\\"><span>        nums = append(nums, node.Val)</span></span>\\n<span class=\\"line\\"><span>        if node.Left != nil {</span></span>\\n<span class=\\"line\\"><span>            // 左子节点入队</span></span>\\n<span class=\\"line\\"><span>            queue.PushBack(node.Left)</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        if node.Right != nil {</span></span>\\n<span class=\\"line\\"><span>            // 右子节点入队</span></span>\\n<span class=\\"line\\"><span>            queue.PushBack(node.Right)</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    return nums</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>","autoDesc":true}')}}]);
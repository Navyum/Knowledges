"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[38061],{36995:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},50987:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>p});var i=a(6254);const l={},e=(0,a(36995).A)(l,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<h2 id="快速、归并、堆、希尔" tabindex="-1"><a class="header-anchor" href="#快速、归并、堆、希尔"><span>快速、归并、堆、希尔</span></a></h2><h3 id="快速排序-quick-sort" tabindex="-1"><a class="header-anchor" href="#快速排序-quick-sort"><span>快速排序（Quick Sort）：</span></a></h3><ul><li><p><u>思想：快速排序的核心操作是“哨兵划分”。选取一个基准元素作为哨兵，将数组分为比基准元素小和比基准元素大的两个部分，对这两个部分分别进行快速排序，重复进行直到整个数组排序完成。</u></p></li><li><p><span style="color:rgb(255, 41, 65);">不稳定排序</span></p></li><li><p>算法流程：</p><ol><li>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li><li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li><li>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</li></ol></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/36c35425526d1e6b7ba4ab42a12a7603.png" alt="Img" loading="lazy"></p></li><li><p>代码：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 哨兵划分 */</span></span>\n<span class="line"><span>func (q *quickSort) partition(nums []int, left, right int) int {</span></span>\n<span class="line"><span>    // 以 nums[left] 为基准数</span></span>\n<span class="line"><span>    i, j := left, right</span></span>\n<span class="line"><span>    for i &lt; j {</span></span>\n<span class="line"><span>        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {</span></span>\n<span class="line"><span>            j-- // 从右向左找首个小于基准数的元素</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {</span></span>\n<span class="line"><span>            i++ // 从左向右找首个大于基准数的元素</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 元素交换</span></span>\n<span class="line"><span>        nums[i], nums[j] = nums[j], nums[i]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 将基准数交换至两子数组的分界线</span></span>\n<span class="line"><span>    nums[i], nums[left] = nums[left], nums[i]</span></span>\n<span class="line"><span>    return i // 返回基准数的索引</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 快速排序 */</span></span>\n<span class="line"><span>func (q *quickSort) quickSort(nums []int, left, right int) {</span></span>\n<span class="line"><span>    // 子数组长度为 1 时终止递归</span></span>\n<span class="line"><span>    if left &gt;= right {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 哨兵划分</span></span>\n<span class="line"><span>    pivot := q.partition(nums, left, right)</span></span>\n<span class="line"><span>    // 递归左子数组、右子数组</span></span>\n<span class="line"><span>    q.quickSort(nums, left, pivot-1)</span></span>\n<span class="line"><span>    q.quickSort(nums, pivot+1, right)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="堆排序-heap-sort" tabindex="-1"><a class="header-anchor" href="#堆排序-heap-sort"><span>堆排序（Heap Sort）：</span></a></h3><ul><li><p><u>思想：将数组构建成一个最大堆或最小堆，每次取出堆顶元素，然后重新调整堆，重复进行直到整个数组排序完成。</u></p></li><li><p><span style="color:rgb(255, 41, 65);">不稳定排序</span></p></li><li><p>算法流程：</p><ol><li>输入数组并建立大顶堆。最大元素位于堆顶。</li><li><code>将堆顶元素与堆底元素交换</code>。完成交换后，堆的长度减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，已排序元素数量加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li><li>重新执行堆化操作（sift down）。完成堆化后，堆的性质得到修复（堆顶为当前最大元素）。</li><li>循环执行第<code>2</code>步和第<code>3</code>步。循环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮后，即可完成数组排序。</li></ol></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e2a67dcf2ceba54e15121b113b8702cb.png" alt="Img" loading="lazy"></p></li><li><p>代码：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span>\n<span class="line"><span>func siftDown(nums *[]int, n, i int) {</span></span>\n<span class="line"><span>    for true {</span></span>\n<span class="line"><span>        // 判断节点 i, l, r 中值最大的节点，记为 ma</span></span>\n<span class="line"><span>        l := 2*i + 1</span></span>\n<span class="line"><span>        r := 2*i + 2</span></span>\n<span class="line"><span>        ma := i</span></span>\n<span class="line"><span>        if l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] {</span></span>\n<span class="line"><span>            ma = l</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] {</span></span>\n<span class="line"><span>            ma = r</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span>\n<span class="line"><span>        if ma == i {</span></span>\n<span class="line"><span>            break</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 交换两节点</span></span>\n<span class="line"><span>        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]</span></span>\n<span class="line"><span>        // 循环向下堆化</span></span>\n<span class="line"><span>        i = ma</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 堆排序 */</span></span>\n<span class="line"><span>func heapSort(nums *[]int) {</span></span>\n<span class="line"><span>    // 建堆操作：堆化除叶节点以外的其他所有节点</span></span>\n<span class="line"><span>    for i := len(*nums)/2 - 1; i &gt;= 0; i-- {</span></span>\n<span class="line"><span>        siftDown(nums, len(*nums), i)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 从堆中提取最大元素，循环 n-1 轮</span></span>\n<span class="line"><span>    for i := len(*nums) - 1; i &gt; 0; i-- {</span></span>\n<span class="line"><span>        // 交换根节点与最右叶节点（交换首元素与尾元素）</span></span>\n<span class="line"><span>        (*nums)[0], (*nums)[i] = (*nums)[i], (*nums)[0]</span></span>\n<span class="line"><span>        // 以根节点为起点，从顶至底进行堆化</span></span>\n<span class="line"><span>        siftDown(nums, i, 0)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="归并排序-merge-sort" tabindex="-1"><a class="header-anchor" href="#归并排序-merge-sort"><span>归并排序（Merge Sort）：</span></a></h3><ul><li><p><u>思想：将数组分成两个部分，对每个部分分别进行排序，然后将两个已排序的部分合并成一个有序的数组。</u></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中唯一<span style="color:rgb(255, 41, 65);">的稳定排序</span></p></li><li><p><span style="color:rgb(255, 41, 65);">归并排序与二叉树后序遍历的递归顺序是一致的</span></p></li><li><p>空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>、非原地排序,合并时需要借助辅助数组实现</p></li><li><p>算法流程：</p><ul><li><code>划分阶段</code>： <ul><li>通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。 <ul><li>从顶至底递归地将数组从中点切分为两个子数组。</li><li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li><li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li></ul></li></ul></li><li>合并阶段： <ul><li>当子数组长度为 1 时终止划分，从底至顶地开始合并。持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ul></li></ul></li><li><p>图解： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/19c6f0f392d3419577c1fd13048e4818.png" alt="Img" loading="lazy"></p></li><li><p>代码：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 合并左子数组和右子数组 */</span></span>\n<span class="line"><span>func merge(nums []int, left, mid, right int) {</span></span>\n<span class="line"><span>    // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span></span>\n<span class="line"><span>    // 创建一个临时数组 tmp ，用于存放合并后的结果</span></span>\n<span class="line"><span>    tmp := make([]int, right-left+1)</span></span>\n<span class="line"><span>    // 初始化左子数组和右子数组的起始索引</span></span>\n<span class="line"><span>    i, j, k := left, mid+1, 0</span></span>\n<span class="line"><span>    // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span>\n<span class="line"><span>    for i &lt;= mid &amp;&amp; j &lt;= right {</span></span>\n<span class="line"><span>        if nums[i] &lt;= nums[j] {</span></span>\n<span class="line"><span>            tmp[k] = nums[i]</span></span>\n<span class="line"><span>            i++</span></span>\n<span class="line"><span>        } else {</span></span>\n<span class="line"><span>            tmp[k] = nums[j]</span></span>\n<span class="line"><span>            j++</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        k++</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 将左子数组和右子数组的剩余元素复制到临时数组中</span></span>\n<span class="line"><span>    for i &lt;= mid {</span></span>\n<span class="line"><span>        tmp[k] = nums[i]</span></span>\n<span class="line"><span>        i++</span></span>\n<span class="line"><span>        k++</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    for j &lt;= right {</span></span>\n<span class="line"><span>        tmp[k] = nums[j]</span></span>\n<span class="line"><span>        j++</span></span>\n<span class="line"><span>        k++</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span>\n<span class="line"><span>    for k := 0; k &lt; len(tmp); k++ {</span></span>\n<span class="line"><span>        nums[left+k] = tmp[k]</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 归并排序 */</span></span>\n<span class="line"><span>func mergeSort(nums []int, left, right int) {</span></span>\n<span class="line"><span>    // 终止条件</span></span>\n<span class="line"><span>    if left &gt;= right {</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 划分阶段</span></span>\n<span class="line"><span>    mid := left + (right - left) / 2</span></span>\n<span class="line"><span>    mergeSort(nums, left, mid)</span></span>\n<span class="line"><span>    mergeSort(nums, mid+1, right)</span></span>\n<span class="line"><span>    // 合并阶段</span></span>\n<span class="line"><span>    merge(nums, left, mid, right)</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="希尔排序-shell-sort" tabindex="-1"><a class="header-anchor" href="#希尔排序-shell-sort"><span>希尔排序（Shell Sort）：</span></a></h3><ul><li><u>思想：插入排序的改进版，先将数组按照一定间隔分为若干个子序列，对每个子序列进行插入排序，然后缩小间隔再进行排序，直到间隔为 1 时进行最后一次排序。</u></li><li><span style="color:rgb(255, 41, 65);">不稳定排序</span></li><li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func shellSort(arr []int) {</span></span>\n<span class="line"><span>    n := len(arr)</span></span>\n<span class="line"><span>    for gap := n / 2; gap &gt; 0; gap /= 2 {</span></span>\n<span class="line"><span>        for i := gap; i &lt; n; i++ {</span></span>\n<span class="line"><span>            temp := arr[i]</span></span>\n<span class="line"><span>            j := i</span></span>\n<span class="line"><span>            for j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp {</span></span>\n<span class="line"><span>                arr[j] = arr[j-gap]</span></span>\n<span class="line"><span>                j -= gap</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            arr[j] = temp</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',9)]))}]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(nlogn)/%E5%BF%AB%E9%80%9F%E3%80%81%E5%BD%92%E5%B9%B6%E3%80%81%E5%A0%86%E3%80%81%E5%B8%8C%E5%B0%94.html","title":"快速、归并、堆、希尔","lang":"zh-CN","frontmatter":{"title":"快速、归并、堆、希尔","author":"navyum","date":"2025-06-15T00:00:00.000Z","article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法"],"tag":["快速","归并","堆","希尔"],"description":"快速、归并、堆、希尔 快速排序（Quick Sort）： 思想：快速排序的核心操作是“哨兵划分”。选取一个基准元素作为哨兵，将数组分为比基准元素小和比基准元素大的两个部分，对这两个部分分别进行快速排序，重复进行直到整个数组排序完成。 不稳定排序 算法流程： 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。 然后，对左子数组和右子数组...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(nlogn)/%E5%BF%AB%E9%80%9F%E3%80%81%E5%BD%92%E5%B9%B6%E3%80%81%E5%A0%86%E3%80%81%E5%B8%8C%E5%B0%94.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"快速、归并、堆、希尔"}],["meta",{"property":"og:description","content":"快速、归并、堆、希尔 快速排序（Quick Sort）： 思想：快速排序的核心操作是“哨兵划分”。选取一个基准元素作为哨兵，将数组分为比基准元素小和比基准元素大的两个部分，对这两个部分分别进行快速排序，重复进行直到整个数组排序完成。 不稳定排序 算法流程： 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。 然后，对左子数组和右子数组..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/36c35425526d1e6b7ba4ab42a12a7603.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"快速"}],["meta",{"property":"article:tag","content":"归并"}],["meta",{"property":"article:tag","content":"堆"}],["meta",{"property":"article:tag","content":"希尔"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"快速、归并、堆、希尔\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/36c35425526d1e6b7ba4ab42a12a7603.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e2a67dcf2ceba54e15121b113b8702cb.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/19c6f0f392d3419577c1fd13048e4818.png\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":5.22,"words":1566},"filePathRelative":"算法数据结构/算法/2.排序/O(nlogn)/快速、归并、堆、希尔.md","localizedDate":"2025年6月15日","excerpt":"<h2>快速、归并、堆、希尔</h2>\\n<h3>快速排序（Quick Sort）：</h3>\\n<ul>\\n<li>\\n<p><u>思想：快速排序的核心操作是“哨兵划分”。选取一个基准元素作为哨兵，将数组分为比基准元素小和比基准元素大的两个部分，对这两个部分分别进行快速排序，重复进行直到整个数组排序完成。</u></p>\\n</li>\\n<li>\\n<p><span style=\\"color: rgb(255, 41, 65);\\">不稳定排序</span></p>\\n</li>\\n<li>\\n<p>算法流程：</p>\\n<ol>\\n<li>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li>\\n<li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li>\\n<li>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</li>\\n</ol>\\n</li>\\n<li>\\n<p>图解：\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/36c35425526d1e6b7ba4ab42a12a7603.png\\" alt=\\"Img\\" loading=\\"lazy\\"></p>\\n</li>\\n<li>\\n<p>代码：</p>\\n<div class=\\"language-golang line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"golang\\" data-title=\\"golang\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/* 哨兵划分 */</span></span>\\n<span class=\\"line\\"><span>func (q *quickSort) partition(nums []int, left, right int) int {</span></span>\\n<span class=\\"line\\"><span>    // 以 nums[left] 为基准数</span></span>\\n<span class=\\"line\\"><span>    i, j := left, right</span></span>\\n<span class=\\"line\\"><span>    for i &lt; j {</span></span>\\n<span class=\\"line\\"><span>        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {</span></span>\\n<span class=\\"line\\"><span>            j-- // 从右向左找首个小于基准数的元素</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {</span></span>\\n<span class=\\"line\\"><span>            i++ // 从左向右找首个大于基准数的元素</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        // 元素交换</span></span>\\n<span class=\\"line\\"><span>        nums[i], nums[j] = nums[j], nums[i]</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    // 将基准数交换至两子数组的分界线</span></span>\\n<span class=\\"line\\"><span>    nums[i], nums[left] = nums[left], nums[i]</span></span>\\n<span class=\\"line\\"><span>    return i // 返回基准数的索引</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>/* 快速排序 */</span></span>\\n<span class=\\"line\\"><span>func (q *quickSort) quickSort(nums []int, left, right int) {</span></span>\\n<span class=\\"line\\"><span>    // 子数组长度为 1 时终止递归</span></span>\\n<span class=\\"line\\"><span>    if left &gt;= right {</span></span>\\n<span class=\\"line\\"><span>        return</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    // 哨兵划分</span></span>\\n<span class=\\"line\\"><span>    pivot := q.partition(nums, left, right)</span></span>\\n<span class=\\"line\\"><span>    // 递归左子数组、右子数组</span></span>\\n<span class=\\"line\\"><span>    q.quickSort(nums, left, pivot-1)</span></span>\\n<span class=\\"line\\"><span>    q.quickSort(nums, pivot+1, right)</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>","autoDesc":true}')}}]);
"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[18022],{36995:(p,n)=>{n.A=(p,n)=>{const e=p.__vccOpts||p;for(const[p,t]of n)e[p]=t;return e}},97536:(p,n,e)=>{e.r(n),e.d(n,{comp:()=>o,data:()=>l});var t=e(6254);const i={},o=(0,e(36995).A)(i,[["render",function(p,n){return(0,t.uX)(),(0,t.CE)("div",null,n[0]||(n[0]=[(0,t.Fv)('<h1 id="异步通讯设计-asynchronous" tabindex="-1"><a class="header-anchor" href="#异步通讯设计-asynchronous"><span>异步通讯设计-Asynchronous</span></a></h1><p>同步的优点：</p><ul><li><p>系统间只耦合于接口</p></li><li><p>实时性也会比异步调用要高 同步的缺点：</p></li><li><p>同步调用需要被调用方的吞吐不低于调用方的吞吐。同步调用链的性能会由最慢的那个服务所决定。</p></li><li><p>同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。</p></li><li><p>同步调用只能是一对一的，很难做到一对多。</p></li><li><p>同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。 异步调用的优点：</p></li><li><p>增加吞吐量之外</p></li><li><p>让服务间的解耦更为彻底，系统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力 异步通讯的三种方式：</p></li></ul><p>请求相应式</p><p>a. 发送方轮询</p><p>b. 发送方设置回调</p><p>直接订阅</p><p>中间件broker订阅</p><p>延伸：</p><p>事件驱动设计，如订阅、broker</p><p>自包含”也就是没有和别人产生依赖</p><p>事件驱动的好处：</p><p>服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。</p><p>服务的开发、测试、运维，以及故障处理都是高度隔离的。</p><p>服务间通过事件关联，所以服务间是不会相互 block 的。</p><p>在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。</p><p>服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。</p><p>坏处：</p><p>业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。</p><p>事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。</p><p>事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。</p><p>为什么要做异步设计：</p><ul><li><p>异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过 Broker 的机制。</p></li><li><p>解耦的目的是让各个服务的隔离性更好，这样不会出现“一倒倒一片”的故障。</p></li><li><p>异步通讯的架构可以获得更大的吞吐量，而且各个服务间的性能不受干扰相对独立。利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的“削峰”，这对后端系统是个不错的保护。</p></li><li><p>服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。 异步架构注意点：</p></li><li><p>中间件 Broker 是关键，需要设计成高可用不丢消息的。</p></li><li><p>无序。因为是分布式的，所以可能很难保证消息的顺序，因此你的设计最好不依赖于消息的顺序。</p></li><li><p>业务处理流程不直观。因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。</p></li><li><p>因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理。这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。例如银行的对账程序。</p></li><li><p>需要处理方有幂等的处理。消息传递中，可能有的业务逻辑会有像 TCP 协议那样的 send 和 ACK 机制。</p></li></ul>',23)]))}]]),l=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1-Asynchronous.html","title":"异步通讯设计-Asynchronous","lang":"zh-CN","frontmatter":{"description":"异步通讯设计-Asynchronous 同步的优点： 系统间只耦合于接口 实时性也会比异步调用要高 同步的缺点： 同步调用需要被调用方的吞吐不低于调用方的吞吐。同步调用链的性能会由最慢的那个服务所决定。 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84/01.%E5%BC%B9%E6%80%A7%E8%AE%BE%E8%AE%A1-%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1-Asynchronous.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"异步通讯设计-Asynchronous"}],["meta",{"property":"og:description","content":"异步通讯设计-Asynchronous 同步的优点： 系统间只耦合于接口 实时性也会比异步调用要高 同步的缺点： 同步调用需要被调用方的吞吐不低于调用方的吞吐。同步调用链的性能会由最慢的那个服务所决定。 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-15T10:30:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-15T10:30:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"异步通讯设计-Asynchronous\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-15T10:30:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\",\\"url\\":\\"https://myblog.camscanner.top\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1749983452000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":3.61,"words":1083},"filePathRelative":"架构设计/02.分布式与架构/01.弹性设计-高可用/异步通讯设计-Asynchronous.md","localizedDate":"2025年6月15日","excerpt":"\\n<p>同步的优点：</p>\\n<ul>\\n<li>\\n<p>系统间只耦合于接口</p>\\n</li>\\n<li>\\n<p>实时性也会比异步调用要高\\n同步的缺点：</p>\\n</li>\\n<li>\\n<p>同步调用需要被调用方的吞吐不低于调用方的吞吐。同步调用链的性能会由最慢的那个服务所决定。</p>\\n</li>\\n<li>\\n<p>同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。</p>\\n</li>\\n<li>\\n<p>同步调用只能是一对一的，很难做到一对多。</p>\\n</li>\\n<li>\\n<p>同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。\\n异步调用的优点：</p>\\n</li>\\n<li>\\n<p>增加吞吐量之外</p>\\n</li>\\n<li>\\n<p>让服务间的解耦更为彻底，系统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力\\n异步通讯的三种方式：</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);
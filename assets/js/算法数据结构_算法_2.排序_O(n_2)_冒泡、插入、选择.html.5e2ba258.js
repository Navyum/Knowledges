"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[65891],{35639:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>p});var i=a(6254);const e={},l=(0,a(36995).A)(e,[["render",function(s,n){return(0,i.uX)(),(0,i.CE)("div",null,n[0]||(n[0]=[(0,i.Fv)('<h2 id="冒泡、选择、插入" tabindex="-1"><a class="header-anchor" href="#冒泡、选择、插入"><span>冒泡、选择、插入</span></a></h2><h3 id="冒泡排序-bubble-sort" tabindex="-1"><a class="header-anchor" href="#冒泡排序-bubble-sort"><span>冒泡排序（Bubble Sort）：</span></a></h3><ul><li><u>思想：比较相邻的元素，如果前一个元素比后一个元素大，就交换它们的位置，重复进行直到整个数组排序完成。</u></li><li>稳定排序，在“冒泡”中遇到相等元素不交换</li><li>算法流程： <ol><li>首先，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>。</li><li>接下来，对剩余 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li><li>以此类推，经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮“冒泡”后，<strong>前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 大的元素都被交换至正确位置</strong>。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ol></li><li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 冒泡排序 */ </span></span>\n<span class="line"><span>func bubbleSort(nums []int) {</span></span>\n<span class="line"><span>    // 外循环：未排序区间为 [0, i]</span></span>\n<span class="line"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\n<span class="line"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\n<span class="line"><span>        for j := 0; j &lt; i; j++ {</span></span>\n<span class="line"><span>            if nums[j] &gt; nums[j+1] {</span></span>\n<span class="line"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\n<span class="line"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* 冒泡排序（标志优化）当数组有序时，将不会发生交换，可以直接中断 */</span></span>\n<span class="line"><span>func bubbleSortWithFlag(nums []int) {</span></span>\n<span class="line"><span>    // 外循环：未排序区间为 [0, i]</span></span>\n<span class="line"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\n<span class="line"><span>        flag := false // 初始化标志位</span></span>\n<span class="line"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\n<span class="line"><span>        for j := 0; j &lt; i; j++ {</span></span>\n<span class="line"><span>            if nums[j] &gt; nums[j+1] {</span></span>\n<span class="line"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\n<span class="line"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\n<span class="line"><span>                flag = true // 记录交换元素</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if flag == false { // 此轮“冒泡”未交换任何元素，直接跳出</span></span>\n<span class="line"><span>            break</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="选择排序-selection-sort" tabindex="-1"><a class="header-anchor" href="#选择排序-selection-sort"><span>选择排序（Selection Sort）：</span></a></h3><ul><li><u>思想：每次从<code>未排序的部分中选择最小</code>的元素，放到已排序部分的末尾，重复进行直到整个数组排序完成。</u></li><li><span style="color:rgb(255, 41, 65);">不稳定排序</span></li><li>算法流程： <ol><li>初始状态下，所有元素未排序，即未排序（索引）区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。</li><li>选取区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中的最小元素，将其与索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 处的元素交换。完成后，数组前 1 个元素已排序。</li><li>选取区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中的最小元素，将其与索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 处的元素交换。完成后，数组前 2 个元素已排序。</li><li>以此类推。经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮选择与交换后，数组前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素已排序。</li><li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li></ol></li><li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 选择排序 */</span></span>\n<span class="line"><span>func selectionSort(nums []int) {</span></span>\n<span class="line"><span>    n := len(nums)</span></span>\n<span class="line"><span>    // 外循环：未排序区间为 [i, n-1]</span></span>\n<span class="line"><span>    for i := 0; i &lt; n-1; i++ {</span></span>\n<span class="line"><span>        // 内循环：找到未排序区间内的最小元素</span></span>\n<span class="line"><span>        min := i</span></span>\n<span class="line"><span>        for j := i + 1; j &lt; n; j++ {</span></span>\n<span class="line"><span>            if nums[j] &lt; nums[min] {</span></span>\n<span class="line"><span>                // 记录最小元素的索引</span></span>\n<span class="line"><span>                min = j</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 将该最小元素与未排序区间的首个元素交换</span></span>\n<span class="line"><span>        nums[i], nums[min] = nums[min], nums[i]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="插入排序-insertion-sort" tabindex="-1"><a class="header-anchor" href="#插入排序-insertion-sort"><span>插入排序（Insertion Sort）：</span></a></h3><ul><li><u> 思想：将数组分为已排序和未排序两个部分，每次从未排序部分中选择一个元素插入到已排序部分的正确位置，重复进行直到整个数组排序完成。</u>（参考扑克牌的排序）</li><li>稳定排序</li><li>算法流程： <ol><li>初始状态下，数组的第 1 个元素已完成排序。</li><li>选取数组的第 2 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 2 个元素已排序</strong>。</li><li>选取第 3 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 3 个元素已排序</strong>。</li><li>以此类推，在最后一轮中，选取最后一个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>所有元素均已排序</strong>。</li></ol></li><li>代码：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 插入排序 */</span></span>\n<span class="line"><span>func insertionSort(nums []int) {</span></span>\n<span class="line"><span>    // 外循环：已排序区间为 [0, i-1]</span></span>\n<span class="line"><span>    for i := 1; i &lt; len(nums); i++ {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 内循环：将索引i，值为base 插入到已排序区间 [0, i-1] 中的正确位置</span></span>\n<span class="line"><span>        for j := i - 1; j &gt;= 0 ; j-- {</span></span>\n<span class="line"><span>            if nums[j+1] &lt; nums[j] {                        // 冒泡的逆过程</span></span>\n<span class="line"><span>                nums[j+1], nums[j] = nums[j], nums[j+1]     // 两两比较交换</span></span>\n<span class="line"><span>            } else {                                        // 一旦发现小值或者等值，则说明位置已经找到，结束内循环。因为等值时不改变位置，所以是稳定排序。</span></span>\n<span class="line"><span>                break</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',7)]))}]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html","title":"冒泡、插入、选择","lang":"zh-CN","frontmatter":{"title":"冒泡、插入、选择","author":"navyum","date":"2025-06-15T00:00:00.000Z","article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法","排序算法"],"tag":["冒泡","插入","选择"],"description":"冒泡、选择、插入 冒泡排序（Bubble Sort）： 思想：比较相邻的元素，如果前一个元素比后一个元素大，就交换它们的位置，重复进行直到整个数组排序完成。 稳定排序，在“冒泡”中遇到相等元素不交换 算法流程： 首先，对 n 个元素执行“冒泡”，将数组的最大元素交换至正确位置。 接下来，对剩余 n−1 个元素执行“冒泡”，将第二大元素交换至正确位置。 ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2.%E6%8E%92%E5%BA%8F/O(n_2)/%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"冒泡、插入、选择"}],["meta",{"property":"og:description","content":"冒泡、选择、插入 冒泡排序（Bubble Sort）： 思想：比较相邻的元素，如果前一个元素比后一个元素大，就交换它们的位置，重复进行直到整个数组排序完成。 稳定排序，在“冒泡”中遇到相等元素不交换 算法流程： 首先，对 n 个元素执行“冒泡”，将数组的最大元素交换至正确位置。 接下来，对剩余 n−1 个元素执行“冒泡”，将第二大元素交换至正确位置。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"冒泡"}],["meta",{"property":"article:tag","content":"插入"}],["meta",{"property":"article:tag","content":"选择"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"冒泡、插入、选择\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":3.84,"words":1153},"filePathRelative":"算法数据结构/算法/2.排序/O(n^2)/冒泡、插入、选择.md","localizedDate":"2025年6月15日","excerpt":"<h2>冒泡、选择、插入</h2>\\n<h3>冒泡排序（Bubble Sort）：</h3>\\n<ul>\\n<li><u>思想：比较相邻的元素，如果前一个元素比后一个元素大，就交换它们的位置，重复进行直到整个数组排序完成。</u></li>\\n<li>稳定排序，在“冒泡”中遇到相等元素不交换</li>\\n<li>算法流程：\\n<ol>\\n<li>首先，对 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\"application/x-tex\\">n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">n</span></span></span></span> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>。</li>\\n<li>接下来，对剩余 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">n - 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>\\n<li>以此类推，经过 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">n - 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> 轮“冒泡”后，<strong>前 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">n - 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> 大的元素都被交换至正确位置</strong>。</li>\\n<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>\\n</ol>\\n</li>\\n<li>代码：<div class=\\"language-golang line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"golang\\" data-title=\\"golang\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/* 冒泡排序 */ </span></span>\\n<span class=\\"line\\"><span>func bubbleSort(nums []int) {</span></span>\\n<span class=\\"line\\"><span>    // 外循环：未排序区间为 [0, i]</span></span>\\n<span class=\\"line\\"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\\n<span class=\\"line\\"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\\n<span class=\\"line\\"><span>        for j := 0; j &lt; i; j++ {</span></span>\\n<span class=\\"line\\"><span>            if nums[j] &gt; nums[j+1] {</span></span>\\n<span class=\\"line\\"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\\n<span class=\\"line\\"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\\n<span class=\\"line\\"><span>            }</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>/* 冒泡排序（标志优化）当数组有序时，将不会发生交换，可以直接中断 */</span></span>\\n<span class=\\"line\\"><span>func bubbleSortWithFlag(nums []int) {</span></span>\\n<span class=\\"line\\"><span>    // 外循环：未排序区间为 [0, i]</span></span>\\n<span class=\\"line\\"><span>    for i := len(nums) - 1; i &gt; 0; i-- {</span></span>\\n<span class=\\"line\\"><span>        flag := false // 初始化标志位</span></span>\\n<span class=\\"line\\"><span>        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>\\n<span class=\\"line\\"><span>        for j := 0; j &lt; i; j++ {</span></span>\\n<span class=\\"line\\"><span>            if nums[j] &gt; nums[j+1] {</span></span>\\n<span class=\\"line\\"><span>                // 交换 nums[j] 与 nums[j + 1]</span></span>\\n<span class=\\"line\\"><span>                nums[j], nums[j+1] = nums[j+1], nums[j]</span></span>\\n<span class=\\"line\\"><span>                flag = true // 记录交换元素</span></span>\\n<span class=\\"line\\"><span>            }</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        if flag == false { // 此轮“冒泡”未交换任何元素，直接跳出</span></span>\\n<span class=\\"line\\"><span>            break</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>","autoDesc":true}')},36995:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,i]of n)a[s]=i;return a}}}]);
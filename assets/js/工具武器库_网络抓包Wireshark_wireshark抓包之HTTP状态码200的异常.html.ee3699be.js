"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[52565],{36995:(n,e)=>{e.A=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},75931:(n,e,s)=>{s.r(e),s.d(e,{comp:()=>l,data:()=>t});var a=s(6254);const i={},l=(0,s(36995).A)(i,[["render",function(n,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h2 id="wireshark抓包" tabindex="-1"><a class="header-anchor" href="#wireshark抓包"><span>wireshark抓包</span></a></h2><h3 id="nginx-server-以-content-type-chunk格式返回的程序异常" tabindex="-1"><a class="header-anchor" href="#nginx-server-以-content-type-chunk格式返回的程序异常"><span>nginx server 以 content-type chunk格式返回的程序异常</span></a></h3><hr><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景：</span></a></h3><p>业务需要通过脚本跑一批数据，数据有很多条，每条数据需要进行一次数据库查询、一次OSS下载，最终才能确定该记录的输出</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输出举例：</span></span>\n<span class="line"><span>记录A： DB记录1 + OSS记录1</span></span>\n<span class="line"><span>记录B： DB记录2 + OSS记录2</span></span>\n<span class="line"><span>...</span></span>\n<span class="line"><span>记录N： DB记录N + OSS记录N</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="业务方出现的问题" tabindex="-1"><a class="header-anchor" href="#业务方出现的问题"><span>业务方出现的问题：</span></a></h3><p>在跑脚本时，使用curl命令行进行接口调用，对nginx的输出结果进行保存，但是出现报错：<code>curl: (18) transfer closed with outstanding read data remaining</code>。保存的结果文件里面记录正常。</p><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/22236647388dc056bff4a58ab963567b.png" width="80%"></p><h3 id="nginx配置" tabindex="-1"><a class="header-anchor" href="#nginx配置"><span>nginx配置</span></a></h3><div class="language-nginx.conf line-numbers-mode" data-highlighter="shiki" data-ext="nginx.conf" data-title="nginx.conf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>location = /test {</span></span>\n<span class="line"><span>    content_by_lua_block {</span></span>\n<span class="line"><span>    for i=1, 1000 do</span></span>\n<span class="line"><span>        -- 1. get result </span></span>\n<span class="line"><span>        ...</span></span>\n<span class="line"><span>        -- 2. print result</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        ngx.say(result)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        end</span></span>\n<span class="line"><span>    end</span></span>\n<span class="line"><span>    ngx.exit()</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="最终定位到原因" tabindex="-1"><a class="header-anchor" href="#最终定位到原因"><span>最终定位到原因：</span></a></h3><p>直接原因：服务端主动断开了TCP连接，导致未完整发送chunk的终止块<code>0\\r\\n\\r\\n</code>，导致客户端接收时解析协议出错。 根本原因：服务端程序出现异常中断，但是因为按照chunk格式返回时，HTTP 200的头在首个tcp包中已经发送无法修改。</p><h3 id="分析过程" tabindex="-1"><a class="header-anchor" href="#分析过程"><span>分析过程：</span></a></h3><h4 id="_1-通过tcpdump进行抓包-在wireshark中打开" tabindex="-1"><a class="header-anchor" href="#_1-通过tcpdump进行抓包-在wireshark中打开"><span>1. 通过tcpdump进行抓包，在wireshark中打开</span></a></h4><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d0a0640c241eb51617709e57acd76b73.png" width="80%"></p><h4 id="_2-解读" tabindex="-1"><a class="header-anchor" href="#_2-解读"><span>2. 解读</span></a></h4><ul><li>30号包显示，最终由服务端（10.8.4.199）主动发送FIN断开TCP连接</li><li>从30、31号包可以看出，整个挥手过程中，Seq、Ack的值都是正常的，说明TCP挥手也是正常进行的</li><li>28号包存在问题点在于：Protocol根据Info来看，应该是<code>HTTP</code>才对，但是实际展示的是<code>TCP</code></li></ul><h4 id="_3-搜索网上资料" tabindex="-1"><a class="header-anchor" href="#_3-搜索网上资料"><span>3. 搜索网上资料</span></a></h4><ul><li>在网上搜索相关资料，并结合实际代码，猜测是ngx.say导致的该问题。</li><li>初步判断：ngx.say 必须结合ngx.eof 一起使用，但是实际设置后，没有作用，问题依然存在。</li></ul><h4 id="_4-重新从协议的角度重新分析" tabindex="-1"><a class="header-anchor" href="#_4-重新从协议的角度重新分析"><span>4. 重新从协议的角度重新分析</span></a></h4><ul><li>根据以往经验，之前有一次手动设置content-length，但是因为计算错误导致的请求异常。</li><li>我们重新结合 Content-Type为 <code>application/octet-stream</code>以及Transfer-Encoding为：<span style="color:rgb(255, 76, 65);">chunked的基础知识</span>： <ul><li>当前HTTP 响应体没有Content-Length，client端无法根据字节判断tcp包什么时候结束</li><li>此时基于TCP粘包理论，此时只能通过应用层的一些特殊的结束符号来判断包的结束位置 <ul><li>查询<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Transfer-Encoding#chunked" target="_blank" rel="noopener noreferrer">MDN</a>的相关知识： <blockquote><p>[!TIP] chunked： Data is sent in a series of chunks. Content can be sent in streams of unknown size to be transferred as a sequence of length-delimited buffers, so the sender can keep a connection open, and let the recipient know when it has received the entire message. The Content-Length header must be omitted, and at the beginning of each chunk, a string of hex digits indicate the size of the chunk-data in octets, followed by \\r\\n and then the chunk itself, followed by another \\r\\n. The terminating chunk is a zero-length chunk.</p></blockquote></li><li>讲人话就是： chunk格式固定为：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[chunk size] 8字节 \\r\\n       -- 表示chunk data的实际大小</span></span>\n<span class="line"><span>[chunk data] \\r\\n            -- 实际chunk data</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><code>终止块</code>格式固定为：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0\\r\\n\\r\\n (对应16进制 30 0d 0a 0d 0a)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul></li></ul><h4 id="_5-排查wireshark中stream-是否有正确的块结束符" tabindex="-1"><a class="header-anchor" href="#_5-排查wireshark中stream-是否有正确的块结束符"><span>5. 排查wireshark中stream 是否有正确的块结束符</span></a></h4><ul><li>在wireshark中，选择对应的记录。右键 -&gt; 【Follow】-&gt; 【TCP Stream】<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  ...</span></span>\n<span class="line"><span>  00002ED4  45 36 25 41 43 25 42 45  25 45 35 25 38 37 25 41   E6%AC%BE %E5%87%A</span></span>\n<span class="line"><span>  00002EE4  44 25 45 38 25 41 46 25  38 31 26 75 73 65 72 5f   D%E8%AF% 81&amp;user_</span></span>\n<span class="line"><span>  00002EF4  69 64 3d 34 32 39 38 31  31 31 30 30 0a 0d 0a      id=42981 1100...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>末尾为0a 0d 0a，即\\n\\r\\n。第一个\\n是查询逻辑中的换行符，末尾的\\r\\n 表示，当前chunk的结束符。</li><li>最终该TCP Stream 并没有发现chunk块结束符</li></ul><h4 id="_6-基于以上的信息-得知请求要么超时、要么是发生了异常" tabindex="-1"><a class="header-anchor" href="#_6-基于以上的信息-得知请求要么超时、要么是发生了异常"><span>6. 基于以上的信息，得知请求要么超时、要么是发生了异常</span></a></h4><ul><li>超时的情况、或者发生异常时，按照常应该是由客户端或者服务端发送<code>RST</code></li><li>但是这个案例里面，缺少了chunk结束块。服务端依然正常发送FIN包结束当前的TCP连接</li></ul><h4 id="_7-带着上面疑问-进一步排查看是否nginx哪里有问题" tabindex="-1"><a class="header-anchor" href="#_7-带着上面疑问-进一步排查看是否nginx哪里有问题"><span>7. 带着上面疑问，进一步排查看是否nginx哪里有问题</span></a></h4><ul><li>查看nginx的error.log，发现存在错误：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[error] 22145#22145: *4985236 lua entry thread aborted: runtime error: .../openresty/nginx/conf/internal/xxxx-script.lua:3485: attempt to concatenate &#39;pages&#39; (a nil value)</span></span>\n<span class="line"><span>stack traceback:</span></span>\n<span class="line"><span>coroutine 0:</span></span>\n<span class="line"><span>.../openresty/nginx/conf/internal/xxxx-script.lua: in main chunk, client: 127.0.0.1, server: , request: &quot;POST /xxx/xxx?x=xxxxxxxxHTTP/1.1&quot;, host: &quot;localhost&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>可以看到因为是变量异常导致的<code>Abort</code>。这里存在一个疑问，程序abort，连接应该使用RST关闭才对，具体原因后面会使用bt trace 工具进行分析。</li><li>先排查代码，查看对应行的记录，判断对应变量在某个记录查询时，会是空值nil，导致nginx流式输出中断。</li></ul><h4 id="_8-结合已知的情况-尝试复现问题" tabindex="-1"><a class="header-anchor" href="#_8-结合已知的情况-尝试复现问题"><span>8. 结合已知的情况，尝试复现问题</span></a></h4><ul><li>使用有问题的nginx配置：<div class="language-nginx.conf line-numbers-mode" data-highlighter="shiki" data-ext="nginx.conf" data-title="nginx.conf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> location = /test {</span></span>\n<span class="line"><span>      content_by_lua_block {</span></span>\n<span class="line"><span>          for i=1, 1000 do</span></span>\n<span class="line"><span>              ngx.say(string.rep(tostring(i), i))   -- 将i重复i次，并正常打印</span></span>\n<span class="line"><span>              </span></span>\n<span class="line"><span>              -- 3. set error case</span></span>\n<span class="line"><span>              if i == 999 then</span></span>\n<span class="line"><span>              ngx.say(no_data)                    -- 故意打印不存在的变量no_data</span></span>\n<span class="line"><span>              end</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>          end</span></span>\n<span class="line"><span>          </span></span>\n<span class="line"><span>          ngx.exit()</span></span>\n<span class="line"><span>      }</span></span>\n<span class="line"><span>  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>使用curl命令复现该问题：<code>curl localhost/test</code><ul><li>问题得到复现 <code>curl: (18) transfer closed with outstanding read data remaining</code></li></ul></li></ul><h3 id="修复方案" tabindex="-1"><a class="header-anchor" href="#修复方案"><span>修复方案：</span></a></h3><ul><li>针对出现问的的pages变量，添加更健壮的代码逻辑进行判断是否为nil</li></ul><h3 id="回顾" tabindex="-1"><a class="header-anchor" href="#回顾"><span>回顾：</span></a></h3><ul><li>该问题比较隐蔽，因为curl的响应头中HTTP状态码为 200，但是出现错误，这个现象颠覆了正常的认知,所以一开始没有怀疑程序出现问题。如果能更早的查看nginx的error.log，也许可以更快的定位问题。</li><li>搜索网上的资料时，对类似的问题都是说是需要设置 ngx.eof()、ngx.fulsh()，直接误导了排查的方向</li><li>在分析抓包的结果时，很长时间都无法直接判断是哪里除了问题，因为从TCP的层面排查，所有的包都是没有任何问题的。唯一露出的马脚就是应该展示为HTTP的协议实际展示为了TCP。</li><li>该问题排查时，每次curl的结果都是一样的（因为pages为nil的就是有问题的那条记录），每次都能稳定复现。但是在测试环境，因为数据的差异，却无法直接复现问题，增加了排查的难度，尤其是测试环境构造数据进行测试时。</li></ul><h3 id="延伸" tabindex="-1"><a class="header-anchor" href="#延伸"><span>延伸：</span></a></h3><ul><li><p>问题1：nginx环境中，当请求发生异常，什么情况下会使用<code>RST</code>中断，什么时候使用<code>FIN</code>优雅中断？</p></li><li><p>问题2：为什么当前的案例，nginx使用的是FIN优雅关闭连接？</p><ul><li>FIN： <ul><li>FIN 正常关闭连接的场景： <ul><li>正常处理完请求</li><li>保活时间（TCP Keep-Alive）内没有新请求</li></ul></li><li>源码：<div class="language-src/http/ngx_http_request.c line-numbers-mode" data-highlighter="shiki" data-ext="src/http/ngx_http_request.c" data-title="src/http/ngx_http_request.c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>函数 ngx_http_close_connection</span></span>\n<span class="line"><span>// ... existing code ...</span></span>\n<span class="line"><span>if (c-&gt;read-&gt;timer_set) {</span></span>\n<span class="line"><span>    ngx_del_timer(c-&gt;read);</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>ngx_close_connection(c);</span></span>\n<span class="line"><span>// ... existing code ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>RST： <ul><li>RST 异常关闭的场景： <ul><li>客户端发送非法请求（client prematurely closed connection）</li><li>upstream异常（upstream connection error）</li><li>握手失败（SSL handshake failed）</li><li>内存崩溃、主动断开、超时等异常（connection reset by peer）</li></ul></li><li>源码：<div class="language-src/event/ngx_event.c line-numbers-mode" data-highlighter="shiki" data-ext="src/event/ngx_event.c" data-title="src/event/ngx_event.c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>函数 ngx_connection_error：</span></span>\n<span class="line"><span>// ... existing code ...</span></span>\n<span class="line"><span>if (err == NGX_ECONNRESET || err == NGX_ENOTCONN) {</span></span>\n<span class="line"><span>    c-&gt;error = 1;</span></span>\n<span class="line"><span>    ngx_close_connection(c);</span></span>\n<span class="line"><span>    return;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>// ... existing code ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>本案例的函数调用栈获取：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p>感受：在分析抓包时，使用大模型进行pcap的分析的探索遇到的问题：</p><ul><li>即使是过滤的数据，pcap文件还是比较大，大模型的上下文有限</li><li>当前的case中，大模型无法深入的分析，只停留在TCP层面，因为TCP层面都是正确的，分析不出问题</li><li>业务代码、抓包请求、环境介绍、报错信息，这些都需要使用者提供给大模型，后续wireshark是否能使用MCP的方式，由大模型自行按需读取需要的数据？</li></ul></li></ul>',36)]))}]]),t=JSON.parse('{"path":"/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHTTP%E7%8A%B6%E6%80%81%E7%A0%81200%E7%9A%84%E5%BC%82%E5%B8%B8.html","title":"wireshark抓包之HTTP状态码200的异常","lang":"zh-CN","frontmatter":{"title":"wireshark抓包之HTTP状态码200的异常","date":"2025-04-08T17:55:36.000Z","author":"Navyum","icon":"lucide-lab:shark","tags":["wireshark","抓包","chunk格式"],"categories":["wireshark","工具"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"description":"wireshark抓包 nginx server 以 content-type chunk格式返回的程序异常 背景： 业务需要通过脚本跑一批数据，数据有很多条，每条数据需要进行一次数据库查询、一次OSS下载，最终才能确定该记录的输出 业务方出现的问题： 在跑脚本时，使用curl命令行进行接口调用，对nginx的输出结果进行保存，但是出现报错：curl:...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8BHTTP%E7%8A%B6%E6%80%81%E7%A0%81200%E7%9A%84%E5%BC%82%E5%B8%B8.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"wireshark抓包之HTTP状态码200的异常"}],["meta",{"property":"og:description","content":"wireshark抓包 nginx server 以 content-type chunk格式返回的程序异常 背景： 业务需要通过脚本跑一批数据，数据有很多条，每条数据需要进行一次数据库查询、一次OSS下载，最终才能确定该记录的输出 业务方出现的问题： 在跑脚本时，使用curl命令行进行接口调用，对nginx的输出结果进行保存，但是出现报错：curl:..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"wireshark"}],["meta",{"property":"article:tag","content":"抓包"}],["meta",{"property":"article:tag","content":"chunk格式"}],["meta",{"property":"article:published_time","content":"2025-04-08T17:55:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"wireshark抓包之HTTP状态码200的异常\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-08T17:55:36.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":3,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":6.7,"words":2009},"filePathRelative":"工具武器库/网络抓包Wireshark/wireshark抓包之HTTP状态码200的异常.md","localizedDate":"2025年4月8日","excerpt":"<h2>wireshark抓包</h2>\\n<h3>nginx server 以 content-type chunk格式返回的程序异常</h3>\\n<hr>\\n<h3>背景：</h3>\\n<p>业务需要通过脚本跑一批数据，数据有很多条，每条数据需要进行一次数据库查询、一次OSS下载，最终才能确定该记录的输出</p>\\n<div class=\\"language-text line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"text\\" data-title=\\"text\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>输出举例：</span></span>\\n<span class=\\"line\\"><span>记录A： DB记录1 + OSS记录1</span></span>\\n<span class=\\"line\\"><span>记录B： DB记录2 + OSS记录2</span></span>\\n<span class=\\"line\\"><span>...</span></span>\\n<span class=\\"line\\"><span>记录N： DB记录N + OSS记录N</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);
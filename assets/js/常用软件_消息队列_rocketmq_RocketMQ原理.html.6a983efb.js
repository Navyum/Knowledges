"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[16492],{36995:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}},77670:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>o,data:()=>n});var i=t(6254);const r={},o=(0,t(36995).A)(r,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h2 id="整体架构" tabindex="-1"><a class="header-anchor" href="#整体架构"><span>整体架构：</span></a></h2><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/dd4853b7ddf4ae9a421ff728ccaad2c4.png" width="60%"><h2 id="与kafka对比" tabindex="-1"><a class="header-anchor" href="#与kafka对比"><span>与kafka对比：</span></a></h2><ul><li>和Kafka相比，RocketMQ在架构上做了<code>减法</code>，在功能上做了<code>加法</code></li></ul><h3 id="架构上的差异-做减法-对kafka做精简" tabindex="-1"><a class="header-anchor" href="#架构上的差异-做减法-对kafka做精简"><span>架构上的差异：做减法，对kafka做精简</span></a></h3><h4 id="nameserver替换zookeeper" tabindex="-1"><a class="header-anchor" href="#nameserver替换zookeeper"><span>nameserver替换zookeeper：</span></a></h4><ul><li>用一种更轻量的方式，管理消息队列的集群信息</li><li>生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现服务发现和负载均衡的效果 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/aa624423f7fc2f3d143f192230a4e034.png" width="60%"></li></ul><h4 id="queue替换partition" tabindex="-1"><a class="header-anchor" href="#queue替换partition"><span>queue替换partition：</span></a></h4><ul><li>将topic拆分成了多个分区，但换了个名字，叫 Queue，也就是&quot;队列&quot;</li><li>queue与partition相比： <ul><li>queue不存储数据，只存储offset等一些简化信息</li><li>消息完整数据则放到 <code>commitlog</code> 的文件上</li><li><code>commitlog</code> 的文件跟<code>segment文件</code>一样，都是滚动写入</li><li>查询方式跟es查询的两个阶段一样，先查索引，再查数据，都是使用数据和索引分离的方式</li><li>kafka因为数据存在partition，所以只需要查询一次 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/700f62da1fd6f71e5871b7fca8867186.png" width="60%"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/02536c5af01f1617aa5b19f79de39f24.png" width="60%"></li></ul></li></ul><h4 id="底层存储的差异" tabindex="-1"><a class="header-anchor" href="#底层存储的差异"><span>底层存储的差异：</span></a></h4><ul><li>kafka 对某个broker写数据，会找到broker上对应的topic，然后找对应的partition文件夹，然后顺序写入partition下的segment文件</li><li>rocketmq 对某个broker写数据，不需要再根据topic、partition区分文件路径，然后顺序写到同一套的commitlog <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a8ea2a26a4b8635fd647e9a43f8ed62d.png" width="60%"></li></ul><h4 id="高可用的备份差异" tabindex="-1"><a class="header-anchor" href="#高可用的备份差异"><span>高可用的备份差异：</span></a></h4><ul><li>kafka 以partition粒度，冗余多个replicas，主从同步的是segment文件</li><li>rocketmq 以broker粒度，冗余多个broker，主从同步的是commitlog文件</li><li>原因： <ul><li>因为rocketmq上不同topic的数据都是写在同一套commitlog，如果要拆细，还得对commitlog做拆分 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/33dc316a68f9e8ba502ab3b44f40ca15.png" width="60%"></li></ul></li></ul><h3 id="功能上的差异-做加法-支持更多功能" tabindex="-1"><a class="header-anchor" href="#功能上的差异-做加法-支持更多功能"><span>功能上的差异：做加法，支持更多功能</span></a></h3><h4 id="支持消息过滤" tabindex="-1"><a class="header-anchor" href="#支持消息过滤"><span>支持消息过滤：</span></a></h4><ul><li>支持给消息打<code>tag</code>，消费者能根据 tag 过滤所需要的数据</li><li>通过topic进行业务类型分类，通过tag 进行二级更细粒度的分类</li></ul><h4 id="支持更准确的事务" tabindex="-1"><a class="header-anchor" href="#支持更准确的事务"><span>支持更准确的事务：</span></a></h4><ul><li>kafka的事务只能保证多个消息同时成功或失败</li><li>rocketmq 支持生产者业务上，<code>功能逻辑</code> + <code>发消息</code>这两个操作的事务。即功能执行正常且发消息成功，则事务成功；否则事务失败，自动回滚。</li></ul><h4 id="支持延时队列" tabindex="-1"><a class="header-anchor" href="#支持延时队列"><span>支持延时队列：</span></a></h4><ul><li>让消费者一定时延后，才能成功获取到对应消息</li></ul><h4 id="支持死信队列" tabindex="-1"><a class="header-anchor" href="#支持死信队列"><span>支持死信队列：</span></a></h4><ul><li>将多次重试失败的消息放到死信队列，方便后续的人工干预</li></ul><h4 id="消息回溯" tabindex="-1"><a class="header-anchor" href="#消息回溯"><span>消息回溯：</span></a></h4><ul><li>支持继续offset回溯</li><li>额外支持基于时间回溯</li></ul>',24)]))}]]),n=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/RocketMQ%E5%8E%9F%E7%90%86.html","title":"RocketMQ原理","lang":"zh-CN","frontmatter":{"title":"RocketMQ原理","date":"2025-06-17T15:15:24.000Z","author":"Navyum","tags":["消息队列","RocketMQ"],"categories":["常用软件","消息队列"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"icon":"simple-icons:apacherocketmq","description":"整体架构： 与kafka对比： 和Kafka相比，RocketMQ在架构上做了减法，在功能上做了加法 架构上的差异：做减法，对kafka做精简 nameserver替换zookeeper： 用一种更轻量的方式，管理消息队列的集群信息 生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现服...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rocketmq/RocketMQ%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"RocketMQ原理"}],["meta",{"property":"og:description","content":"整体架构： 与kafka对比： 和Kafka相比，RocketMQ在架构上做了减法，在功能上做了加法 架构上的差异：做减法，对kafka做精简 nameserver替换zookeeper： 用一种更轻量的方式，管理消息队列的集群信息 生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现服..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-24T03:13:58.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:15:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-24T03:13:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-17T15:15:24.000Z\\",\\"dateModified\\":\\"2025-06-24T03:13:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750734838000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.33,"words":698},"filePathRelative":"常用软件/消息队列/rocketmq/RocketMQ原理.md","localizedDate":"2025年6月17日","excerpt":"<h2>整体架构：</h2>\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/dd4853b7ddf4ae9a421ff728ccaad2c4.png\\" width=\\"60%\\">\\n<h2>与kafka对比：</h2>\\n<ul>\\n<li>和Kafka相比，RocketMQ在架构上做了<code>减法</code>，在功能上做了<code>加法</code></li>\\n</ul>\\n<h3>架构上的差异：做减法，对kafka做精简</h3>\\n<h4>nameserver替换zookeeper：</h4>\\n<ul>\\n<li>用一种更轻量的方式，管理消息队列的集群信息</li>\\n<li>生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现服务发现和负载均衡的效果\\n<img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/aa624423f7fc2f3d143f192230a4e034.png\\" width=\\"60%\\"></li>\\n</ul>","autoDesc":true}')}}]);
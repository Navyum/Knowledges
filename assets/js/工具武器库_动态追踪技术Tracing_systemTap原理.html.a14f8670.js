"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[99811],{6070:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>p,data:()=>n});var s=t(6254);const r={},p=(0,t(36995).A)(r,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,a[0]||(a[0]=[(0,s.Fv)('<h2 id="systemtap原理" tabindex="-1"><a class="header-anchor" href="#systemtap原理"><span>systemTap原理</span></a></h2><ul><li>将stp文件编译为C文件，再将C文件编译为内核模块.ko文件，将.ko文件加载到内核中，最终利用内核提供的 <code>kprobes 机制</code>来设置探测点，采集数据存储到<code>probe.out</code>，从而进行系统性能分析。</li></ul><h3 id="一、systemtap运行流程" tabindex="-1"><a class="header-anchor" href="#一、systemtap运行流程"><span>一、systemTap运行流程</span></a></h3><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/031aa72127709b2fa27f4e1fda97d28a.png"></p><h4 id="_1-parse-词法语法分析" tabindex="-1"><a class="header-anchor" href="#_1-parse-词法语法分析"><span>1.Parse（词法语法分析）</span></a></h4><h4 id="_2-elaborate-语义分析" tabindex="-1"><a class="header-anchor" href="#_2-elaborate-语义分析"><span>2.Elaborate（语义分析）</span></a></h4><h4 id="_3-translate-生成-c-代码" tabindex="-1"><a class="header-anchor" href="#_3-translate-生成-c-代码"><span>3.Translate（生成 C 代码）</span></a></h4><h4 id="_4-build-编译成内核模块-ko" tabindex="-1"><a class="header-anchor" href="#_4-build-编译成内核模块-ko"><span>4.Build（编译成内核模块.ko）</span></a></h4><h4 id="_5-load-run-加载运行" tabindex="-1"><a class="header-anchor" href="#_5-load-run-加载运行"><span>5.Load/Run（加载运行）</span></a></h4><ul><li>说明： <ul><li>1~4步骤为编译.ko文件，可以在开发环境进行编译</li><li>5步骤，将编译好的.ko文件，使用<code>staprun</code>程序在待检测环境运行（注意⚠️：需要确保开发环境、检测环境的内核版本一致）</li></ul></li><li>原理： <ul><li><strong>Kprobes，kernel probes，是 linux 内核的一个重要特性，也是一个轻量级的内核调试工具</strong></li><li>systemtap 调用的 kprobe 接口函数来注册 stp 脚本中定义的探测点。当内核运行到探测点时，就会调用对应的处理函数。</li><li>kprobe 执行过程，就是利用<code>中断处理</code>，将<code>原有指令</code>扩展成为执行 <code>pre_handler</code>-&gt; 执行<code>原有指令</code> -&gt; 执行 <code>post_handler</code>（类似于 AOP面向切面编程）</li><li>其他的类似systemtap的工具：<strong>eBPF（BCC、bpftrace）</strong>、DTrace、<strong>perf</strong>、Strace</li></ul></li></ul><h4 id="_6-store-output-用户态-内核态交互-通讯" tabindex="-1"><a class="header-anchor" href="#_6-store-output-用户态-内核态交互-通讯"><span>6.Store Output（用户态 / 内核态交互，通讯）</span></a></h4><p>生成probe.out文件，用于后续分析</p><h4 id="_7-stop-unload-卸载" tabindex="-1"><a class="header-anchor" href="#_7-stop-unload-卸载"><span>7.Stop/Unload（卸载）</span></a></h4><p>通过stapio向内核发送退出信号</p><h3 id="二、systemtap关系图" tabindex="-1"><a class="header-anchor" href="#二、systemtap关系图"><span>二、systemtap关系图</span></a></h3><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/aac61ecde949c46d79919400cdf289b9.png" width="80%"></p><h3 id="三、systemtap存在的问题" tabindex="-1"><a class="header-anchor" href="#三、systemtap存在的问题"><span>三、systemtap存在的问题：</span></a></h3><ul><li>基于内核模块技术，在RHEL以外的系统上都不可靠</li><li>稳定性差。SystemTap不是内核的一部分，所以必须适配内核的改动。因为内核通常被stripped，DWARF格式调试信息被移除了，所以必须要安装对应的debuginfo包。</li><li>依赖dwarf，需要安装内核符号，<span style="color:rgb(255, 76, 65);">用户层程序则在编译时需要-g</span></li><li>因为需要编译，所以systemtap相对DTrace慢很多</li></ul><h3 id="四、systemtap优点" tabindex="-1"><a class="header-anchor" href="#四、systemtap优点"><span>四、systemtap优点：</span></a></h3><ul><li>使用的脚本语言，所以支持的特性更全（如函数偏移、循环、函数局部变量、结构体引用）</li><li>具有成熟的用户态符号自动加载，可以写比较复杂的探针处理程序</li><li>内置了大量帮助程序(tapset)，可用于检测不同的目标</li></ul>',20)]))}]]),n=JSON.parse('{"path":"/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%8E%9F%E7%90%86.html","title":"systemTap原理","lang":"zh-CN","frontmatter":{"title":"systemTap原理","date":"2025-04-03T10:32:56.000Z","author":"Navyum","tags":["SystemTap","性能分析"],"categories":["工具","性能分析","Systemtap"],"description":"systemTap原理 将stp文件编译为C文件，再将C文件编译为内核模块.ko文件，将.ko文件加载到内核中，最终利用内核提供的 kprobes 机制来设置探测点，采集数据存储到probe.out，从而进行系统性能分析。 一、systemTap运行流程 1.Parse（词法语法分析） 2.Elaborate（语义分析） 3.Translate（生成 ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AFTracing/systemTap%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"systemTap原理"}],["meta",{"property":"og:description","content":"systemTap原理 将stp文件编译为C文件，再将C文件编译为内核模块.ko文件，将.ko文件加载到内核中，最终利用内核提供的 kprobes 机制来设置探测点，采集数据存储到probe.out，从而进行系统性能分析。 一、systemTap运行流程 1.Parse（词法语法分析） 2.Elaborate（语义分析） 3.Translate（生成 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T03:50:17.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"SystemTap"}],["meta",{"property":"article:tag","content":"性能分析"}],["meta",{"property":"article:published_time","content":"2025-04-03T10:32:56.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T03:50:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"systemTap原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-03T10:32:56.000Z\\",\\"dateModified\\":\\"2025-06-17T03:50:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750132217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":2.05,"words":616},"filePathRelative":"工具武器库/动态追踪技术Tracing/systemTap原理.md","localizedDate":"2025年4月3日","excerpt":"<h2>systemTap原理</h2>\\n<ul>\\n<li>将stp文件编译为C文件，再将C文件编译为内核模块.ko文件，将.ko文件加载到内核中，最终利用内核提供的 <code>kprobes 机制</code>来设置探测点，采集数据存储到<code>probe.out</code>，从而进行系统性能分析。</li>\\n</ul>\\n<h3>一、systemTap运行流程</h3>\\n<p align=\\"center\\"><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/031aa72127709b2fa27f4e1fda97d28a.png\\"></p>","autoDesc":true}')},36995:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,s]of a)t[e]=s;return t}}}]);
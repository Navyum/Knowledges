"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[39909],{36995:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,o]of a)t[e]=o;return t}},89616:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>c,data:()=>n});var o=t(6254);const i={},c=(0,t(36995).A)(i,[["render",function(e,a){return(0,o.uX)(),(0,o.CE)("div",null,a[0]||(a[0]=[(0,o.Fv)('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><ul><li>同步调用、异步调用的说法，是<strong>对于获取数据的过程</strong>而言的。</li><li>例如发生read调用时，内核将数据从内核空间拷贝到应用程序空间。这个过程是在read函数中是<code>同步进行</code>的。如果内核实现的拷贝效率很差，read调用就会在这个同步过程中消耗比较长的时间。</li><li>IO操作分两个阶段： <ol><li>等待数据准备好 --读到内核缓存</li><li>将数据从内核读到用户空间 --读到进程空间</li></ol></li><li>一般来说过程1花费的时间远远大于过程2： <ul><li><code>BIO</code>：1上阻塞2上也阻塞的是同步阻塞IO</li><li><code>NIO</code>：1上非阻塞2阻塞的是同步非阻塞IO，Reactor就是这种模型</li><li><code>AIO</code>：1上非阻塞2上非阻塞是异步非阻塞IO，Proactor模型就是这种模型</li></ul></li></ul><h3 id="_1-阻塞i-o-bio" tabindex="-1"><a class="header-anchor" href="#_1-阻塞i-o-bio"><span>1. 阻塞I/O BIO</span></a></h3><ul><li><p>阻塞I/O发起的read请求，<code>线程会被挂起，一直等到内核数据准备好，并把数据从内核区域拷贝到应用程序的缓冲区中当拷贝过程完成，read 请求调用才返回</code>。之后应用程序可以对缓冲区的数据进行数据解析。</p></li><li><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8753e69bd11c7c4df01eb90209ebc0ff.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ul><h3 id="_2-非阻塞i-o-nio" tabindex="-1"><a class="header-anchor" href="#_2-非阻塞i-o-nio"><span>2. 非阻塞I/O NIO</span></a></h3><ul><li><p>非阻塞I/O的read请求 <code>在数据未准备好的情况下立即返回</code>。<code>应用程序可以不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲，并完成这次read调用</code>。</p></li><li><p>注意，<code>这里最后一次 read 调用获取数据的过程，是一个同步的过程</code>。这里的同步指的是内核区域的数据拷贝到缓存区这个过程</p></li><li><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/b6b3f593e0aa5c3e8e5a62682662d2d4.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ul><h3 id="_3-非阻塞i-o多路复用-nio" tabindex="-1"><a class="header-anchor" href="#_3-非阻塞i-o多路复用-nio"><span>3. 非阻塞I/O多路复用 NIO</span></a></h3><ul><li>每次让应用程序去轮询内核的 I/O 是否准备好，是一个不经济的做法，因为在轮询的过程中应用进程啥也不能干</li><li>select、poll、epoll 这样的 I/O 多路复用技术就隆重登场了。</li><li>通过<code>I/O事件分发</code>，<code>当内核数据准备好时，再通知应用程序进行操作</code>。这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。</li></ul><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a61d7af0321c15ad520343578eb1444a.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_4-异步i-o-aio" tabindex="-1"><a class="header-anchor" href="#_4-异步i-o-aio"><span>4. 异步I/O AIO</span></a></h3><ul><li><p>当我们<code>发起 aio_read 之后就立即返回</code>，<code>内核自动将数据从内核空间拷贝到应用程序空间</code>。这个拷贝过程是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。</p></li><li><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/433606a10e71cb3437619798afad7957.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ul><h3 id="_5-举例" tabindex="-1"><a class="header-anchor" href="#_5-举例"><span>5. 举例：</span></a></h3><blockquote><p>第一种阻塞 I/O 就是你去了书店，告诉老板你想要某本书，然后你就一直在那里等着，直到书店老板翻箱倒柜找到你想要的书。</p></blockquote><blockquote><p>第二种非阻塞 I/O 类似于你去了书店，问老板有没有一本书，老板告诉你没有，你就离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。</p></blockquote><blockquote><p>第三种基于非阻塞的 I/O 多路复用，你来到书店告诉老板：“老板，到货给我打电话吧，我再来付钱取书。”</p></blockquote><blockquote><p>第四种异步 I/O 就是你连去书店取书的过程也想省了，你留下地址，付了书费，让老板到货时寄给你，你直接在家里拿到就可以看了。</p></blockquote><h3 id="_6-总结" tabindex="-1"><a class="header-anchor" href="#_6-总结"><span>6. 总结：</span></a></h3><ul><li>和同步 I/O 相比，异步 I/O 的读写动作由内核自动完成。不过，在 Linux 下目前仅仅支持简单的基于本地文件的 aio 异步操作，这也使得我们在编写高性能网络程序时，首选 <code>Reactor 模式</code>，借助 epoll 这样的 I/O 分发技术完成开发；</li><li>而 Windows 下的 <code>IOCP</code> 则是一种异步 I/O 的技术，并由此产生了和 Reactor 齐名的 <code>Proactor 模式</code>。</li><li>无论是 Reactor 模式，还是 Proactor 模式，都是一种基于事件分发的网络编程模式。</li><li>Reactor 模式是基于待完成的 I/O 事件，而 Proactor 模式则是基于已完成的 I/O 事件，<strong>两者的本质，都是借由事件分发的思想</strong>，设计出可兼容、可扩展、接口友好的一套程序框架。</li></ul><h3 id="_7-reactor与proactor模型" tabindex="-1"><a class="header-anchor" href="#_7-reactor与proactor模型"><span>7. Reactor与Proactor模型：</span></a></h3><blockquote><p>1、假如我们去饭店点餐，饭店人很多，如果我们付了钱后站在收银台<code>等着饭端上来我们才离开</code>，这就成了同步阻塞了。</p></blockquote><blockquote><p>2、如果我们付了钱后给你一个号就可以离开,<code>饭好了老板会叫号，你过来取</code>。这就是Reactor模型。</p></blockquote><blockquote><p>3、如果我们付了钱后给我一个号就可以坐到坐位上该干啥干啥，<code>饭好了老板会把饭端上来</code>送给你。这就是Proactor模型了。</p></blockquote>',22)]))}]]),n=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.%E7%BD%91%E7%BB%9CIO%E6%8A%80%E6%9C%AF-%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5.html","title":"09.网络IO-阻塞、同步","lang":"zh-CN","frontmatter":{"title":"09.网络IO-阻塞、同步","date":"2024-03-29T19:33:18.000Z","author":"Navyum","tags":["IO","NIO","AIO"],"categories":["网络"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"icon":"zondicons:network","description":"简介 同步调用、异步调用的说法，是对于获取数据的过程而言的。 例如发生read调用时，内核将数据从内核空间拷贝到应用程序空间。这个过程是在read函数中是同步进行的。如果内核实现的拷贝效率很差，read调用就会在这个同步过程中消耗比较长的时间。 IO操作分两个阶段： 等待数据准备好 --读到内核缓存 将数据从内核读到用户空间 --读到进程空间 一般来说...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.%E7%BD%91%E7%BB%9CIO%E6%8A%80%E6%9C%AF-%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"09.网络IO-阻塞、同步"}],["meta",{"property":"og:description","content":"简介 同步调用、异步调用的说法，是对于获取数据的过程而言的。 例如发生read调用时，内核将数据从内核空间拷贝到应用程序空间。这个过程是在read函数中是同步进行的。如果内核实现的拷贝效率很差，read调用就会在这个同步过程中消耗比较长的时间。 IO操作分两个阶段： 等待数据准备好 --读到内核缓存 将数据从内核读到用户空间 --读到进程空间 一般来说..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8753e69bd11c7c4df01eb90209ebc0ff.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"IO"}],["meta",{"property":"article:tag","content":"NIO"}],["meta",{"property":"article:tag","content":"AIO"}],["meta",{"property":"article:published_time","content":"2024-03-29T19:33:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"09.网络IO-阻塞、同步\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/8753e69bd11c7c4df01eb90209ebc0ff.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/b6b3f593e0aa5c3e8e5a62682662d2d4.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a61d7af0321c15ad520343578eb1444a.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/433606a10e71cb3437619798afad7957.png\\"],\\"datePublished\\":\\"2024-03-29T19:33:18.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":3,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":4.28,"words":1284},"filePathRelative":"计算机网络/07.网络IO技术-阻塞、非阻塞、同步、异步.md","localizedDate":"2024年3月29日","excerpt":"<h2>简介</h2>\\n<ul>\\n<li>同步调用、异步调用的说法，是<strong>对于获取数据的过程</strong>而言的。</li>\\n<li>例如发生read调用时，内核将数据从内核空间拷贝到应用程序空间。这个过程是在read函数中是<code>同步进行</code>的。如果内核实现的拷贝效率很差，read调用就会在这个同步过程中消耗比较长的时间。</li>\\n<li>IO操作分两个阶段：\\n<ol>\\n<li>等待数据准备好 --读到内核缓存</li>\\n<li>将数据从内核读到用户空间 --读到进程空间</li>\\n</ol>\\n</li>\\n<li>一般来说过程1花费的时间远远大于过程2：\\n<ul>\\n<li><code>BIO</code>：1上阻塞2上也阻塞的是同步阻塞IO</li>\\n<li><code>NIO</code>：1上非阻塞2阻塞的是同步非阻塞IO，Reactor就是这种模型</li>\\n<li><code>AIO</code>：1上非阻塞2上非阻塞是异步非阻塞IO，Proactor模型就是这种模型</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);
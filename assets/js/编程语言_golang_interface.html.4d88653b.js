"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[87139],{11014:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var i=a(6254);const e={},l=(0,a(36995).A)(e,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<ol><li><p>接口的作用：</p><ol><li>隐藏细节：通过接口可以对对象进行必要的抽象</li><li>解耦： 通过接口，我们能够以模块化的方式构建起复杂、庞大的系统</li><li>权限控制：通过接口来控制接入方式和接入方的行为，降低安全风险</li></ol></li><li><p>使用接口的成本： a. 内存逃逸：接口的动态数据类型对应的数据大小难以预料，所以接口中使用指针来存储数据。为了方便数据被寻址，平时分配在栈中的值一旦赋值给接口后，Go 运行时会在堆区为接口开辟内存（内存逃逸意味着堆内存分配时的时间消耗）</p></li></ol><p>b. 查找接口中容纳的动态数据类型和它对应的方法的指针带来的开销</p><ol start="3"><li><p>值接收者和指针接收者：</p><ol><li>实现了接收者是值类型的方法，会隐含实现接收者是指针类型的方法；</li><li>实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法；</li><li>对于实现了接收者是值类型的方法，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；</li><li>对于实现了接收者是指针类型的方法，调用者修改的是指针指向的对象本身；</li><li>如何区分何时使用： <ol><li>类型的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。（像内置的引用类型，如 slice，map，interface声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的 ）</li><li>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code></li></ol></li></ol></li><li><p>iface和eface二者区别： iface描述的接口包含方法，而 eface则是不包含任何方法的空接口: interface{}</p></li><li><p>iface结构体说明:</p></li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type iface struct {</span></span>\n<span class="line"><span>\ttab  *itab    //接口的类型以及赋给这个接口的实体类型</span></span>\n<span class="line"><span>\tdata unsafe.Pointer //指向接口具体的值，一般而言是一个指向堆内存的指针</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type itab struct {</span></span>\n<span class="line"><span>\tinter  *interfacetype //描述了接口的类型</span></span>\n<span class="line"><span>\t_type  *_type //描述了实体的类型，包括内存对齐方式，大小等</span></span>\n<span class="line"><span>\tlink   *itab</span></span>\n<span class="line"><span>\thash   uint32 // copy of _type.hash. Used for type switches.</span></span>\n<span class="line"><span>\tbad    bool   // type does not implement interface</span></span>\n<span class="line"><span>\tinhash bool   // has this itab been added to hash?</span></span>\n<span class="line"><span>\tunused [2]byte</span></span>\n<span class="line"><span>\tfun    [1]uintptr // variable sized 放置和接口方法对应的具体数据类型的方法地址</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>type interfacetype struct {</span></span>\n<span class="line"><span>\ttyp     _type //描述 Go 语言中各种数据类型的结构体</span></span>\n<span class="line"><span>\tpkgpath name //定义了接口的包名</span></span>\n<span class="line"><span>\tmhdr    []imethod  //接口所定义的函数列表</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><p>iface内存模型： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ea9c54d9bf3b37ad38aa5543368ad439.png" alt="图片" loading="lazy"></p></li><li><p>eface结构体：</p></li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type eface struct {</span></span>\n<span class="line"><span>    _type *_type</span></span>\n<span class="line"><span>    data  unsafe.Pointer</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>接口的动态类型和动态值： <code>tab</code> 是接口表指针指向类型信息，即动态类型。</li></ol><p><code>data</code> 是数据指针指向具体的数据，即动态值。</p><ol><li>_type结构体:</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type _type struct {</span></span>\n<span class="line"><span>    // 类型大小</span></span>\n<span class="line"><span>\tsize       uintptr</span></span>\n<span class="line"><span>    ptrdata    uintptr</span></span>\n<span class="line"><span>    // 类型的 hash 值</span></span>\n<span class="line"><span>    hash       uint32</span></span>\n<span class="line"><span>    // 类型的 flag，和反射相关</span></span>\n<span class="line"><span>    tflag      tflag</span></span>\n<span class="line"><span>    // 内存对齐相关</span></span>\n<span class="line"><span>    align      uint8</span></span>\n<span class="line"><span>    fieldalign uint8</span></span>\n<span class="line"><span>    // 类型的编号，有bool, slice, struct 等等等等</span></span>\n<span class="line"><span>\tkind       uint8</span></span>\n<span class="line"><span>\talg        *typeAlg</span></span>\n<span class="line"><span>\t// gc 相关</span></span>\n<span class="line"><span>\tgcdata    *byte</span></span>\n<span class="line"><span>\tstr       nameOff</span></span>\n<span class="line"><span>\tptrToThis typeOff</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的。</li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>type arraytype struct {</span></span>\n<span class="line"><span>\ttyp   _type</span></span>\n<span class="line"><span>\telem  *_type</span></span>\n<span class="line"><span>\tslice *_type</span></span>\n<span class="line"><span>\tlen   uintptr</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>type chantype struct {</span></span>\n<span class="line"><span>\ttyp  _type</span></span>\n<span class="line"><span>\telem *_type</span></span>\n<span class="line"><span>\tdir  uintptr</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>type slicetype struct {</span></span>\n<span class="line"><span>\ttyp  _type</span></span>\n<span class="line"><span>\telem *_type</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>type structtype struct {</span></span>\n<span class="line"><span>\ttyp     _type</span></span>\n<span class="line"><span>\tpkgPath name</span></span>\n<span class="line"><span>\tfields  []structfield</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="9"><li>接口的构造过程：</li><li>接口转换的原理： <ol><li>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口(duck typing 🦆类型) <ol><li>匹配的细节：某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code></li></ol></li><li>具体代码实现：</li></ol></li></ol><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func convI2I(inter *interfacetype, i iface) (r iface) {</span></span>\n<span class="line"><span>\ttab := i.tab</span></span>\n<span class="line"><span>\tif tab == nil {</span></span>\n<span class="line"><span>\t\treturn</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>\tif tab.inter == inter {</span></span>\n<span class="line"><span>\t\tr.tab = tab</span></span>\n<span class="line"><span>\t\tr.data = i.data</span></span>\n<span class="line"><span>\t\treturn</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>\tr.tab = getitab(inter, tab._type, false)</span></span>\n<span class="line"><span>\tr.data = i.data</span></span>\n<span class="line"><span>\treturn</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。 <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以 <code>convI2I</code> 函数需要找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data。</code> 我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code></p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {</span></span>\n<span class="line"><span>\t// ……</span></span>\n<span class="line"><span>    // 根据 inter, typ 计算出 hash 值</span></span>\n<span class="line"><span>\th := itabhash(inter, typ)</span></span>\n<span class="line"><span>\t// look twice - once without lock, once with.</span></span>\n<span class="line"><span>\t// common case will be no lock contention.</span></span>\n<span class="line"><span>\tvar m *itab</span></span>\n<span class="line"><span>\tvar locked int</span></span>\n<span class="line"><span>\tfor locked = 0; locked &lt; 2; locked++ {</span></span>\n<span class="line"><span>\t\tif locked != 0 {</span></span>\n<span class="line"><span>\t\t\tlock(&amp;ifaceLock)</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        // 遍历哈希表的一个 slot</span></span>\n<span class="line"><span>\t\tfor m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != nil; m = m.link {</span></span>\n<span class="line"><span>            // 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span>\n<span class="line"><span>\t\t\tif m.inter == inter &amp;&amp; m._type == typ {</span></span>\n<span class="line"><span>                // ……</span></span>\n<span class="line"><span>                </span></span>\n<span class="line"><span>\t\t\t\tif locked != 0 {</span></span>\n<span class="line"><span>\t\t\t\t\tunlock(&amp;ifaceLock)</span></span>\n<span class="line"><span>\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t\treturn m</span></span>\n<span class="line"><span>\t\t\t}</span></span>\n<span class="line"><span>\t\t}</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>    // 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span>\n<span class="line"><span>\tm = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))</span></span>\n<span class="line"><span>\tm.inter = inter</span></span>\n<span class="line"><span>    m._type = typ</span></span>\n<span class="line"><span>    </span></span>\n<span class="line"><span>    // 添加到全局的 hash 表中</span></span>\n<span class="line"><span>\tadditab(m, true, canfail)</span></span>\n<span class="line"><span>\tunlock(&amp;ifaceLock)</span></span>\n<span class="line"><span>\tif m.bad {</span></span>\n<span class="line"><span>\t\treturn nil</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>\treturn m</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p><p>这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code> 。</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span>\n<span class="line"><span>func additab(m *itab, locked, canfail bool) {</span></span>\n<span class="line"><span>\tinter := m.inter</span></span>\n<span class="line"><span>\ttyp := m._type</span></span>\n<span class="line"><span>\tx := typ.uncommon()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>\t// both inter and typ have method sorted by name,</span></span>\n<span class="line"><span>\t// and interface names are unique,</span></span>\n<span class="line"><span>\t// so can iterate over both in lock step;</span></span>\n<span class="line"><span>    // the loop is O(ni+nt) not O(ni*nt).</span></span>\n<span class="line"><span>    // </span></span>\n<span class="line"><span>    // inter 和 typ 的方法都按方法名称进行了排序</span></span>\n<span class="line"><span>    // 并且方法名都是唯一的。所以循环的次数是固定的</span></span>\n<span class="line"><span>    // 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span>\n<span class="line"><span>\tni := len(inter.mhdr)</span></span>\n<span class="line"><span>\tnt := int(x.mcount)</span></span>\n<span class="line"><span>\txmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]</span></span>\n<span class="line"><span>\tj := 0</span></span>\n<span class="line"><span>\tfor k := 0; k &lt; ni; k++ {</span></span>\n<span class="line"><span>\t\ti := &amp;inter.mhdr[k]</span></span>\n<span class="line"><span>\t\titype := inter.typ.typeOff(i.ityp)</span></span>\n<span class="line"><span>\t\tname := inter.typ.nameOff(i.name)</span></span>\n<span class="line"><span>\t\tiname := name.name()</span></span>\n<span class="line"><span>\t\tipkg := name.pkgPath()</span></span>\n<span class="line"><span>\t\tif ipkg == &quot;&quot; {</span></span>\n<span class="line"><span>\t\t\tipkg = inter.pkgpath.name()</span></span>\n<span class="line"><span>\t\t}</span></span>\n<span class="line"><span>\t\tfor ; j &lt; nt; j++ {</span></span>\n<span class="line"><span>\t\t\tt := &amp;xmhdr[j]</span></span>\n<span class="line"><span>            tname := typ.nameOff(t.name)</span></span>\n<span class="line"><span>            // 检查方法名字是否一致</span></span>\n<span class="line"><span>\t\t\tif typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname {</span></span>\n<span class="line"><span>\t\t\t\tpkgPath := tname.pkgPath()</span></span>\n<span class="line"><span>\t\t\t\tif pkgPath == &quot;&quot; {</span></span>\n<span class="line"><span>\t\t\t\t\tpkgPath = typ.nameOff(x.pkgpath).name()</span></span>\n<span class="line"><span>\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t\tif tname.isExported() || pkgPath == ipkg {</span></span>\n<span class="line"><span>\t\t\t\t\tif m != nil {</span></span>\n<span class="line"><span>                        // 获取函数地址，并加入到itab.fun数组中</span></span>\n<span class="line"><span>\t\t\t\t\t\tifn := typ.textOff(t.ifn)</span></span>\n<span class="line"><span>\t\t\t\t\t\t*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span></span>\n<span class="line"><span>\t\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t\t\tgoto nextimethod</span></span>\n<span class="line"><span>\t\t\t\t}</span></span>\n<span class="line"><span>\t\t\t}</span></span>\n<span class="line"><span>\t\t}</span></span>\n<span class="line"><span>        // ……</span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>\t\tm.bad = true</span></span>\n<span class="line"><span>\t\tbreak</span></span>\n<span class="line"><span>\tnextimethod:</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>\tif !locked {</span></span>\n<span class="line"><span>\t\tthrow(&quot;invalid itab locking&quot;)</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 计算 hash 值</span></span>\n<span class="line"><span>    h := itabhash(inter, typ)</span></span>\n<span class="line"><span>    // 加到Hash Slot链表中</span></span>\n<span class="line"><span>\tm.link = hash[h]</span></span>\n<span class="line"><span>\tm.inhash = true</span></span>\n<span class="line"><span>\tatomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p>',20)]))}]]),p=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface.html","title":"interface","lang":"zh-CN","frontmatter":{"title":"interface","author":"navyum","date":"2025-06-21T22:24:53.000Z","article":true,"index":true,"headerDepth":2,"sticky":false,"star":false,"category":["笔记"],"tag":["笔记"],"description":"接口的作用： 隐藏细节：通过接口可以对对象进行必要的抽象 解耦： 通过接口，我们能够以模块化的方式构建起复杂、庞大的系统 权限控制：通过接口来控制接入方式和接入方的行为，降低安全风险 使用接口的成本： a. 内存逃逸：接口的动态数据类型对应的数据大小难以预料，所以接口中使用指针来存储数据。为了方便数据被寻址，平时分配在栈中的值一旦赋值给接口后，Go 运...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/interface.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"interface"}],["meta",{"property":"og:description","content":"接口的作用： 隐藏细节：通过接口可以对对象进行必要的抽象 解耦： 通过接口，我们能够以模块化的方式构建起复杂、庞大的系统 权限控制：通过接口来控制接入方式和接入方的行为，降低安全风险 使用接口的成本： a. 内存逃逸：接口的动态数据类型对应的数据大小难以预料，所以接口中使用指针来存储数据。为了方便数据被寻址，平时分配在栈中的值一旦赋值给接口后，Go 运..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ea9c54d9bf3b37ad38aa5543368ad439.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T14:30:17.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:published_time","content":"2025-06-21T22:24:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T14:30:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"interface\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ea9c54d9bf3b37ad38aa5543368ad439.png\\"],\\"datePublished\\":\\"2025-06-21T22:24:53.000Z\\",\\"dateModified\\":\\"2025-06-21T14:30:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750516217000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":2,"url":"https://github.com/Navyum"}]},"readingTime":{"minutes":7.16,"words":2147},"filePathRelative":"编程语言/golang/interface.md","localizedDate":"2025年6月21日","excerpt":"<ol>\\n<li>\\n<p>接口的作用：</p>\\n<ol>\\n<li>隐藏细节：通过接口可以对对象进行必要的抽象</li>\\n<li>解耦：      通过接口，我们能够以模块化的方式构建起复杂、庞大的系统</li>\\n<li>权限控制：通过接口来控制接入方式和接入方的行为，降低安全风险</li>\\n</ol>\\n</li>\\n<li>\\n<p>使用接口的成本：\\na. 内存逃逸：接口的动态数据类型对应的数据大小难以预料，所以接口中使用指针来存储数据。为了方便数据被寻址，平时分配在栈中的值一旦赋值给接口后，Go 运行时会在堆区为接口开辟内存（内存逃逸意味着堆内存分配时的时间消耗）</p>\\n</li>\\n</ol>","autoDesc":true}')},36995:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}}}]);
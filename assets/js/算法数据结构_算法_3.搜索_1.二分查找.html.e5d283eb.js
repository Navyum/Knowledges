"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[62629],{36995:(a,s)=>{s.A=(a,s)=>{const n=a.__vccOpts||a;for(const[a,t]of s)n[a]=t;return n}},64108:(a,s,n)=>{n.r(s),n.d(s,{comp:()=>m,data:()=>p});var t=n(6254);const e={},m=(0,n(36995).A)(e,[["render",function(a,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<h2 id="二分查找" tabindex="-1"><a class="header-anchor" href="#二分查找"><span>二分查找</span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义：</span></a></h3><ul><li>二分查找（binary search）是一种基于分治策略的高效搜索算法。</li><li>它利用数据的<code>有序性</code>，<code>每轮缩小一半搜索范围</code>，直至找到目标元素或搜索区间为空为止。</li></ul><h3 id="具体操作" tabindex="-1"><a class="header-anchor" href="#具体操作"><span>具体操作：</span></a></h3><ol><li>先初始化指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，分别指向数组首元素和尾元素，代表搜索区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li><li>计算中点索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">⌊</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">m = \\lfloor {(i + j) / 2} \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">/2</span></span><span class="mclose">⌋</span></span></span></span> （其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mtext> </mtext><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\\lfloor \\: \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mclose">⌋</span></span></span></span> 表示向下取整操作）</li><li>判断 <code>nums[m]</code> 和 <code>target</code> 的大小关系，分为以下三种情况： <ol><li>当 <code>nums[m] &lt; target</code> 时，说明 <code>target</code> 在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中，因此执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li><li>当 <code>nums[m] &gt; target</code> 时，说明 <code>target</code> 在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, m - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中，因此执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j = m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</li><li>当 <code>nums[m] = target</code> 时，说明找到 <code>target</code> ，因此返回索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 。</li></ol></li><li>重复2、3步骤，一直未找到元素，则搜索区间缩小为空。此时返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。</li><li>注意项：由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 都是 <code>int</code> 类型，<strong>因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 可能会超出 <code>int</code> 类型的取值范围</strong>。为了避免大数越界，我们通常采用公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">⌊</mo><mrow><mi>i</mi><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">m = \\lfloor {i + (j - i) / 2} \\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord">/2</span></span><span class="mclose">⌋</span></span></span></span> 来计算中点</li></ol><h3 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度"><span>复杂度：</span></a></h3><ul><li><strong>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> ：在二分循环中，区间每轮缩小一半，因此循环次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\\log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> 。</li><li><strong>空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong> ：指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 使用常数大小空间。</li></ul><h3 id="区间表示法" tabindex="-1"><a class="header-anchor" href="#区间表示法"><span>区间表示法：</span></a></h3><ul><li>&quot;双闭区间&quot;: 定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span></li><li>&quot;左闭右开区间&quot;: 定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点：</span></a></h3><ul><li><p>优点：</p><ul><li>时间效率高，空间效率高</li></ul></li><li><p>缺点：</p><ul><li>仅适用于有序数据</li><li>仅适用于数组，因为需要随机跳跃，链表只能用指针遍历</li><li>小数据量时，不如线性搜索（因为线性搜索只需要1次比较操作）</li></ul></li><li><p>代码实现：</p><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 二分查找（双闭区间） */</span></span>\n<span class="line"><span>func binarySearch(nums []int, target int) int {</span></span>\n<span class="line"><span>    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span>\n<span class="line"><span>    i, j := 0, len(nums)-1</span></span>\n<span class="line"><span>    // 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span>\n<span class="line"><span>    for i &lt;= j {</span></span>\n<span class="line"><span>        m := i + (j-i)/2      // 计算中点索引 m</span></span>\n<span class="line"><span>        if nums[m] &lt; target { // 此情况说明 target 在区间 [m+1, j] 中</span></span>\n<span class="line"><span>            i = m + 1</span></span>\n<span class="line"><span>        } else if nums[m] &gt; target { // 此情况说明 target 在区间 [i, m-1] 中</span></span>\n<span class="line"><span>            j = m - 1</span></span>\n<span class="line"><span>        } else { // 找到目标元素，返回其索引</span></span>\n<span class="line"><span>            return m</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 未找到目标元素，返回 -1</span></span>\n<span class="line"><span>    return -1</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="二分查找变种问题" tabindex="-1"><a class="header-anchor" href="#二分查找变种问题"><span>二分查找变种问题：</span></a></h3><ul><li>二分查找不仅可用于搜索目标元素，还可用于解决<code>目标元素的插入位置问题</code>，</li></ul><h4 id="二分法查找插入点" tabindex="-1"><a class="header-anchor" href="#二分法查找插入点"><span>二分法查找插入点：</span></a></h4><ul><li>问题：</li></ul><blockquote><p>给定一个长度为n的有序数组 nums 和一个元素 target ，数组不存在重复元素。 现将 target 插入数组 nums 中，并保持其有序性。 若数组中已存在元素 target，<code>则插入到其左方</code>。 请返回插入后 target 在数组中的索引。</p></blockquote><ul><li>Case1：无重复元素的数组： <ul><li>基于二分查找的思路，逼近最终查找值 <ul><li>当数组包含<code>target</code>时，插入点的索引就是该 target 的索引</li><li>当数组不包含 target 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>即插入点位置。(越界时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><code>指向首个大于target的元素</code>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><code>指向首个小于target的元素</code>)</li></ul></li><li>代码实现：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 二分查找插入点（无重复元素） */</span></span>\n<span class="line"><span>func binarySearchInsertionSimple(nums []int, target int) int {</span></span>\n<span class="line"><span>    // 初始化双闭区间 [0, n-1]</span></span>\n<span class="line"><span>    i, j := 0, len(nums)-1</span></span>\n<span class="line"><span>    for i &lt;= j {</span></span>\n<span class="line"><span>        // 计算中点索引 m</span></span>\n<span class="line"><span>        m := i + (j-i)/2</span></span>\n<span class="line"><span>        if nums[m] &lt; target {</span></span>\n<span class="line"><span>            // target 在区间 [m+1, j] 中</span></span>\n<span class="line"><span>            i = m + 1</span></span>\n<span class="line"><span>        } else if nums[m] &gt; target {</span></span>\n<span class="line"><span>            // target 在区间 [i, m-1] 中</span></span>\n<span class="line"><span>            j = m - 1</span></span>\n<span class="line"><span>        } else {</span></span>\n<span class="line"><span>            // 找到 target ，返回插入点 m</span></span>\n<span class="line"><span>            return m</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 未找到 target ，返回插入点 i</span></span>\n<span class="line"><span>    return i</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>Case2：有重复元素的数组： <ul><li>问题改动点：数组存在重复元素</li><li>基于二分查找的思路，逼近最终查找值 <ul><li>当数组包含<code>多个target</code> 时 <ul><li>方案1：使用线性搜索找到最左边的索引</li><li>方案2：采用来j=m-1缩小区间，从而使指针j向小于<code>target</code>的元素靠近。</li></ul></li><li>数组不包含target时： <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>即插入点位置,(越界时，<code>$i$指向首个大于target的元素,$j$指向首个小于target的元素</code>)</li></ul></li></ul></li><li>代码实现：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    /* 二分查找插入点（存在重复元素） */</span></span>\n<span class="line"><span>    func binarySearchInsertion(nums []int, target int) int {</span></span>\n<span class="line"><span>        // 初始化双闭区间 [0, n-1]</span></span>\n<span class="line"><span>        i, j := 0, len(nums)-1</span></span>\n<span class="line"><span>        for i &lt;= j {</span></span>\n<span class="line"><span>            // 计算中点索引 m</span></span>\n<span class="line"><span>            m := i + (j-i)/2</span></span>\n<span class="line"><span>            if nums[m] &lt; target {</span></span>\n<span class="line"><span>                // target 在区间 [m+1, j] 中</span></span>\n<span class="line"><span>                i = m + 1</span></span>\n<span class="line"><span>            } else if nums[m] &gt; target {</span></span>\n<span class="line"><span>                // target 在区间 [i, m-1] 中</span></span>\n<span class="line"><span>                j = m - 1</span></span>\n<span class="line"><span>            } else {</span></span>\n<span class="line"><span>                // 首个小于 target 的元素在区间 [i, m-1] 中</span></span>\n<span class="line"><span>                j = m - 1</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 返回插入点 i</span></span>\n<span class="line"><span>        return i</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h4 id="二分法查找边界" tabindex="-1"><a class="header-anchor" href="#二分法查找边界"><span>二分法查找边界：</span></a></h4><ul><li>问题：</li></ul><blockquote><p>给定一个长度为n的有序数组 nums ，其中可能包含重复元素。 请返回数组中最左一个元素 target 的索引(左边界)。 若数组中不包含该元素，则返回 -1。</p></blockquote><ul><li>思路： <ul><li>找左边界，移动j，使得i无限逼近小于<code>target</code>的位置</li><li>找右边界，移动i，使得j无限逼近大于<code>target</code>的位置</li></ul></li><li>代码实现：<div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/* 二分查找最左一个 target */</span></span>\n<span class="line"><span>func binarySearchLeftEdge(nums []int, target int) int {</span></span>\n<span class="line"><span>    // 等价于查找 target 的插入点</span></span>\n<span class="line"><span>    i := binarySearchInsertion(nums, target)</span></span>\n<span class="line"><span>    // 未找到 target ，返回 -1</span></span>\n<span class="line"><span>    if i == len(nums) || nums[i] != target {</span></span>\n<span class="line"><span>        return -1</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    // 找到 target ，返回索引 i</span></span>\n<span class="line"><span>    return i</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>',21)]))}]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","title":"1.二分查找","lang":"zh-CN","frontmatter":{"title":"1.二分查找","author":"navyum","date":"2025-06-15T00:00:00.000Z","order":-1,"article":true,"headerDepth":2,"sticky":true,"star":true,"category":["算法","搜索算法"],"tag":["算法","二分查找"],"description":"二分查找 定义： 二分查找（binary search）是一种基于分治策略的高效搜索算法。 它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。 具体操作： 先初始化指针 i=0 和 j=n−1 ，分别指向数组首元素和尾元素，代表搜索区间 [0,n−1] 计算中点索引 m=⌊(i+j)/2⌋ （其中 ⌊⌋ 表示向下取整操作） ...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"1.二分查找"}],["meta",{"property":"og:description","content":"二分查找 定义： 二分查找（binary search）是一种基于分治策略的高效搜索算法。 它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。 具体操作： 先初始化指针 i=0 和 j=n−1 ，分别指向数组首元素和尾元素，代表搜索区间 [0,n−1] 计算中点索引 m=⌊(i+j)/2⌋ （其中 ⌊⌋ 表示向下取整操作） ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T07:42:14.000Z"}],["meta",{"property":"article:author","content":"navyum"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"二分查找"}],["meta",{"property":"article:published_time","content":"2025-06-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T07:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.二分查找\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T07:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750146134000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":1,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":4.69,"words":1408},"filePathRelative":"算法数据结构/算法/3.搜索/1.二分查找.md","localizedDate":"2025年6月15日","excerpt":"<h2>二分查找</h2>\\n<h3>定义：</h3>\\n<ul>\\n<li>二分查找（binary search）是一种基于分治策略的高效搜索算法。</li>\\n<li>它利用数据的<code>有序性</code>，<code>每轮缩小一半搜索范围</code>，直至找到目标元素或搜索区间为空为止。</li>\\n</ul>\\n<h3>具体操作：</h3>\\n<ol>\\n<li>先初始化指针 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\\"application/x-tex\\">i = 0</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6595em;\\"></span><span class=\\"mord mathnormal\\">i</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">0</span></span></span></span> 和 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">j = n - 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.854em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> ，分别指向数组首元素和尾元素，代表搜索区间 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">[</mo><mn>0</mn><mo separator=\\"true\\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\\"false\\">]</mo></mrow><annotation encoding=\\"application/x-tex\\">[0, n - 1]</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">[</span><span class=\\"mord\\">0</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mclose\\">]</span></span></span></span></li>\\n<li>计算中点索引 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy=\\"false\\">⌊</mo><mrow><mo stretchy=\\"false\\">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy=\\"false\\">)</mo><mi mathvariant=\\"normal\\">/</mi><mn>2</mn></mrow><mo stretchy=\\"false\\">⌋</mo></mrow><annotation encoding=\\"application/x-tex\\">m = \\\\lfloor {(i + j) / 2} \\\\rfloor</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">⌊</span><span class=\\"mord\\"><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">i</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span><span class=\\"mclose\\">)</span><span class=\\"mord\\">/2</span></span><span class=\\"mclose\\">⌋</span></span></span></span> （其中 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">⌊</mo><mtext> </mtext><mo stretchy=\\"false\\">⌋</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\lfloor \\\\: \\\\rfloor</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">⌊</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mclose\\">⌋</span></span></span></span> 表示向下取整操作）</li>\\n<li>判断 <code>nums[m]</code> 和 <code>target</code> 的大小关系，分为以下三种情况：\\n<ol>\\n<li>当 <code>nums[m] &lt; target</code> 时，说明 <code>target</code> 在区间 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator=\\"true\\">,</mo><mi>j</mi><mo stretchy=\\"false\\">]</mo></mrow><annotation encoding=\\"application/x-tex\\">[m + 1, j]</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span><span class=\\"mclose\\">]</span></span></span></span> 中，因此执行 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>i</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">i = m + 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6595em;\\"></span><span class=\\"mord mathnormal\\">i</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> 。</li>\\n<li>当 <code>nums[m] &gt; target</code> 时，说明 <code>target</code> 在区间 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">[</mo><mi>i</mi><mo separator=\\"true\\">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\\"false\\">]</mo></mrow><annotation encoding=\\"application/x-tex\\">[i, m - 1]</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\">i</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mclose\\">]</span></span></span></span> 中，因此执行 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>j</mi><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">j = m - 1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.854em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> 。</li>\\n<li>当 <code>nums[m] = target</code> 时，说明找到 <code>target</code> ，因此返回索引 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\\"application/x-tex\\">m</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">m</span></span></span></span> 。</li>\\n</ol>\\n</li>\\n<li>重复2、3步骤，一直未找到元素，则搜索区间缩小为空。此时返回 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">-1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7278em;vertical-align:-0.0833em;\\"></span><span class=\\"mord\\">−</span><span class=\\"mord\\">1</span></span></span></span> 。</li>\\n<li>注意项：由于 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\"application/x-tex\\">i</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6595em;\\"></span><span class=\\"mord mathnormal\\">i</span></span></span></span> 和 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\\"application/x-tex\\">j</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.854em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span></span></span></span> 都是 <code>int</code> 类型，<strong>因此 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding=\\"application/x-tex\\">i + j</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7429em;vertical-align:-0.0833em;\\"></span><span class=\\"mord mathnormal\\">i</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.854em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span></span></span></span> 可能会超出 <code>int</code> 类型的取值范围</strong>。为了避免大数越界，我们通常采用公式 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy=\\"false\\">⌊</mo><mrow><mi>i</mi><mo>+</mo><mo stretchy=\\"false\\">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy=\\"false\\">)</mo><mi mathvariant=\\"normal\\">/</mi><mn>2</mn></mrow><mo stretchy=\\"false\\">⌋</mo></mrow><annotation encoding=\\"application/x-tex\\">m = \\\\lfloor {i + (j - i) / 2} \\\\rfloor</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">m</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">⌊</span><span class=\\"mord\\"><span class=\\"mord mathnormal\\">i</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.05724em;\\">j</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mord mathnormal\\">i</span><span class=\\"mclose\\">)</span><span class=\\"mord\\">/2</span></span><span class=\\"mclose\\">⌋</span></span></span></span> 来计算中点</li>\\n</ol>","autoDesc":true}')}}]);
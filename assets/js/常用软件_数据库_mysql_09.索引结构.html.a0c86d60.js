"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[29898],{36995:(e,d)=>{d.A=(e,d)=>{const c=e.__vccOpts||e;for(const[e,i]of d)c[e]=i;return c}},84368:(e,d,c)=>{c.r(d),c.d(d,{comp:()=>t,data:()=>l});var i=c(6254);const o={},t=(0,c(36995).A)(o,[["render",function(e,d){return(0,i.uX)(),(0,i.CE)("div",null,d[0]||(d[0]=[(0,i.Fv)('<h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础：</span></a></h3><ol><li>索引中的数据页的编号不一定连续，也就是说这些页在存储空间里可能并不挨着</li><li>B+树中<code>相同层次</code>的数据页通过页结构的File Header 中的FIL_PAGE_PREV和FIL_PAGE_NEXT，组成双向循环链表</li><li>每个数据页内部会维护<code>页目录</code>，通过分组的方式将所有用户记录分组</li><li>每个数据页内部记录之间通过next_record连接，next_record记录的是下一个记录的偏移位置</li><li>存储用户记录的页和存储索引的页结构FIL_PAGE_TYPE都是&quot;FIL_PAGE_INDEX&quot;</li><li>存储索引的页里面的记录叫做<code>目录项记录</code>，即索引的非叶子结点</li><li>存储用户记录的页里面的记录做<code>用户记录</code>，即索引的叶子节点</li><li>存储<code>目录项记录</code>页中的主键值最小的那个记录的<code>min_rec_mask</code>值为<code>1</code></li></ol><h3 id="索引页的组织结构" tabindex="-1"><a class="header-anchor" href="#索引页的组织结构"><span>索引页的组织结构：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/71f78b44ba9aa1057249f28149069458.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>从图中可以看出： <ul><li>每个索引页最多存储4个，叶子节点最多存储3个记录（不包含infimum、supremum）</li><li>索引页比数据页存的记录肯定要多很多</li><li>数据插入： <ul><li>先找到最底层的复合条件的数据页，如果有空间，直接插入；如果没有空间，此时会发生页分裂。</li></ul></li><li>页分裂过程： <ul><li>创建新页：InnoDB会创建一个新的叶子节点页。</li><li>重新分配记录：将当前页中的一半记录移动到新页中，确保两个页的空间使用均衡。</li><li>更新双向循环指针：同层级前后页的指针进行调整</li><li>更新父节点：在父节点中插入一个新的目录项记录，指向新创建的页，并更新原有页的目录项记录。</li><li>递归处理：如果父节点也已满，页分裂会递归向上进行，直到根节点。如果根节点也需要分裂，会创建一个新的根节点，树的高度增加。</li></ul></li><li>页分裂举例： <ul><li>插入（101，0，x）</li><li>定位到应该放在页9 中，但页9 满了，发生页分裂，将（100，9，x）和（101，0，x）放到新申请的页38中（同时需要更新页9 的NEXT和页20 的PREV指针）</li><li>更新父节点页30，插入一条目录项记录（100，38），因为父节点也满了，此时父节点也进行页分裂，申请新 页49，将一半的目录项记录移动到新页中</li><li>新的页49此时含有（100，38）、（209，20），更新页30的NEXT指针和页32的PREV指针</li></ul></li></ul></li></ul><h3 id="叶子结点的页内结构" tabindex="-1"><a class="header-anchor" href="#叶子结点的页内结构"><span>叶子结点的页内结构：</span></a></h3><ul><li>record_type=0</li><li>存储：索引列、用户数据，构成一条用户记录 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e04c0c52c052b5d0af6e6fc9de314561.png" alt="图片" loading="lazy"></li></ul><h3 id="非叶子结点的页内结构" tabindex="-1"><a class="header-anchor" href="#非叶子结点的页内结构"><span>非叶子结点的页内结构：</span></a></h3><ul><li>record_type = 1</li><li>存储：索引列、页中最小记录的主键值、对应主键所在页号，构成一条目录项记录 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/93bef03e8991198d729e3a446585fc56.png" alt="图片" loading="lazy"></li></ul><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引"><span>聚簇索引：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6257b9b2ff45df3060c65eb1f8161cb9.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>横向：根据<code>主键值的大小</code>进行页内记录排序、页间排序 <ol><li>页内的记录是按照<code>主键大小</code>顺序排成<code>单向链表</code></li><li>存放<code>用户记录的页</code>根据页中用户记录的<code>主键大小</code>顺序排成一个双向链表</li><li>存放<code>目录项记录的页</code>分为不同的层次，<code>在同一层次中的页</code>也是根据页中目录项记录的<code>主键大小</code>顺序排成一个<code>双向链表</code></li></ol></li><li>竖向： <ol><li><code>目录项记录页</code>中记录下一层级的<code>目录项记录页号</code>或者<code>用户记录的页号</code></li></ol></li><li>聚簇索引的叶子节点存储的是<code>完整的用户记录</code>，包括<code>隐藏列</code></li><li>聚簇索引的非叶子结点存储的是<code>主键+页号</code></li><li>聚簇索引就是innodb数据的存储方式，如果没有定义主键，则会使用<code>其他的唯一非空索引</code>或者<code>row_id</code>创建聚簇索引</li></ul><h3 id="二级索引-索引列c2" tabindex="-1"><a class="header-anchor" href="#二级索引-索引列c2"><span>二级索引（索引列c2）：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/eaf67d501183f3421ce82e9ba257666c.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>横向：根据<code>索引列的值大小</code>进行页内记录排序、页间排序 <ol><li>页内的记录是按照<code>索引列c2</code>顺序排成<code>单向链表</code></li><li>存放<code>用户记录的页</code>根据页内用户记录的<code>索引列c2</code>顺序排成一个双向链表</li><li>存放<code>目录项记录的页</code>分为不同的层次，<code>在同一层次中的页</code>也是根据页中目录项记录的<code>索引列c2</code>顺序排成一个<code>双向链表</code></li></ol></li><li>竖向： <ol><li><code>目录项记录页</code>中记录下一层级的<code>目录项记录页号</code>或者<code>含有主键信息的页号</code></li></ol></li><li>二级索引的叶子节点存储的是<code>索引列c2</code>和<code>主键值</code></li><li>二级索引的非叶子结点中存储的是<code>索引列c2+页号</code>（实际上如果是非唯一索引，为了保证每个目录项记录的唯一性，还会存储<code>主键值</code>）</li><li>通过<code>二级索引</code>找到符合条件的<code>主键值</code>，需要再到<code>聚簇索引</code>中继续查找用户记录，这个过程称为<code>回表</code></li></ul><h3 id="联合索引-索引列c2、c3" tabindex="-1"><a class="header-anchor" href="#联合索引-索引列c2、c3"><span>联合索引（索引列c2、c3）：</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e7fedfdfeb66366d5d36aa1b4ff394f5.png" alt="Img" tabindex="0" loading="lazy"><figcaption>Img</figcaption></figure><ul><li>联合索引也是二级索引</li><li>横向：根据<code>索引列的值大小</code>进行页内记录排序、页间排序 <ol><li>记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序</li><li>其他同二级索引</li></ol></li><li>竖向： <ol><li><code>目录项记录页</code>中记录下一层级的<code>目录项记录页号</code>或者<code>含主键信息的页号</code></li></ol></li><li>连接规则同二级索引</li><li>叶子节点节点存储的是<code>c2</code>、<code>c3</code>和主键<code>c1</code></li><li>非叶子结点中存储的是<code>索引列c2、c3 + 页号</code></li></ul><h3 id="innodb的b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#innodb的b-树索引的注意事项"><span>InnoDB的B+树索引的注意事项：</span></a></h3><ol><li>根页面创建后万年不变： <ul><li>B+树创建过程： <ol><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不一定需要人为创建）的时候，都会为这个索引创建一个<code>根节点</code>页</li><li>最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>页既没有用户记录，也没有目录项记录</li><li>随后向表中插入用户记录时，<strong>先把用户记录存储到这个<code>根节点</code>页</strong></li><li>当<code>根节点</code>中的可用空间<code>Free space</code>用完，如果继续插入记录，此时会发生<code>页分裂</code>，将<code>根节点</code>中的所有记录复制到一个新分配的页。这时新插入的记录根据索引列的大小（聚簇索引的主键，二级索引的索引列）就会被分配到新的页中，而**<code>根节点</code>便升级为存储目录项记录的页**</li><li>特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。<strong>只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录数据字典</strong>，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从<code>数据字典</code>取出根节点的页号，从而来访问这个索引。</li></ol></li></ul></li><li>内节点（非叶子结点）中的目录项记录需要唯一性保证： <ul><li>为了确保去除<code>页号</code>后的唯一性，非唯一索引的<code>目录项记录</code>存储了<code>索引列</code>、主键值、<code>页号</code></li><li>如果不唯一，则可能会存在插入记录时多个页都可选： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e5a7e2a226d2d80d34dffba6bba492b5.png" alt="图片" loading="lazy"></li><li>页3实际存储的是（1，1，4）、（1，7，5）</li></ul></li><li>一个页面最少存储2条记录：</li></ol><h3 id="关于myisam" tabindex="-1"><a class="header-anchor" href="#关于myisam"><span>关于MyISAM：</span></a></h3><ol><li><p>索引特点：</p><ul><li>MyISAM的索引方案也使用<code>B+树</code>，但是却将索引和数据<code>分开存储</code>，属于非聚簇索引</li><li>把用户记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>，文件包含<code>行号</code>+<code>用户数据</code>； <ul><li>数据文件都是时间序，区别于innodb按照主键排序</li></ul></li><li>把索引信息存储到另一个称为<code>索引文件</code>的文件中，文件包含<code>主键值 + 行号/数据偏移位置</code></li></ul></li><li><p>查找过程：</p><ul><li>先通过<code>索引文件</code>中的索引找到对应的<code>行号</code>，再通过<code>行号</code>去<code>数据文件</code>找对应的记录</li><li><code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code></li></ul></li><li><p>MyISAM 数据文件： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/109230d40cc4dd387d544f8ccc5cb4e6.png" alt="图片" loading="lazy"></p></li><li><p>对比：</p><ol><li>回表： <ul><li>Innodb从<code>二级索引</code>找到<code>主键</code>，再通过<code>聚簇索引</code>找到对应用户记录</li><li>MyISAM从<code>索引文件</code>找到记录的偏移位置，再通过<code>数据文件</code>找到对应用户记录</li></ul></li><li>数据： <ul><li>InnoDB中的索引即数据，数据即索引（<code>聚簇索引</code>）</li><li>而MyISAM中却是索引是索引、数据是数据</li></ul></li></ol></li><li><p>适用于读多写少的场合、全文索引支持、支持压缩（偏向于ck）</p></li></ol><h3 id="其他存储引擎" tabindex="-1"><a class="header-anchor" href="#其他存储引擎"><span>其他存储引擎：</span></a></h3><table><thead><tr><th>引擎</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Innodb</td><td>支持事务</td><td>最常用</td></tr><tr><td>Myisam</td><td>支持压缩和全文索引</td><td>读多写少的大数据场合，更新效率低</td></tr><tr><td>Memory</td><td></td><td></td></tr><tr><td>RocksDB</td><td>高吞吐量和低延迟的读写操作，适合高并发和高性能</td><td>高性能键值存储的场景</td></tr><tr><td>TokuDB</td><td>高效的写入和压缩性能</td><td>适用于大数据量、高写入负载的应用</td></tr><tr><td>NDB</td><td>用于MySQL Cluster，提供高可用性和高可扩展性</td><td>高可用性和高扩展性的分布式系统</td></tr><tr><td>Archive</td><td></td><td></td></tr></tbody></table>',24)]))}]]),l=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/09.%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html","title":"09.索引结构","lang":"zh-CN","frontmatter":{"title":"09.索引结构","date":"2025-06-17T15:21:20.000Z","author":"Navyum","icon":"fontisto:mysql","tags":["Mysql","索引"],"categories":["Mysql"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"基础： 索引中的数据页的编号不一定连续，也就是说这些页在存储空间里可能并不挨着 B+树中相同层次的数据页通过页结构的File Header 中的FIL_PAGE_PREV和FIL_PAGE_NEXT，组成双向循环链表 每个数据页内部会维护页目录，通过分组的方式将所有用户记录分组 每个数据页内部记录之间通过next_record连接，next_recor...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/09.%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"09.索引结构"}],["meta",{"property":"og:description","content":"基础： 索引中的数据页的编号不一定连续，也就是说这些页在存储空间里可能并不挨着 B+树中相同层次的数据页通过页结构的File Header 中的FIL_PAGE_PREV和FIL_PAGE_NEXT，组成双向循环链表 每个数据页内部会维护页目录，通过分组的方式将所有用户记录分组 每个数据页内部记录之间通过next_record连接，next_recor..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/71f78b44ba9aa1057249f28149069458.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:tag","content":"索引"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:21:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"09.索引结构\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/71f78b44ba9aa1057249f28149069458.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e04c0c52c052b5d0af6e6fc9de314561.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/93bef03e8991198d729e3a446585fc56.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6257b9b2ff45df3060c65eb1f8161cb9.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/eaf67d501183f3421ce82e9ba257666c.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e7fedfdfeb66366d5d36aa1b4ff394f5.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/e5a7e2a226d2d80d34dffba6bba492b5.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/109230d40cc4dd387d544f8ccc5cb4e6.png\\"],\\"datePublished\\":\\"2025-06-17T15:21:20.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":8.04,"words":2411},"filePathRelative":"常用软件/数据库/mysql/09.索引结构.md","localizedDate":"2025年6月17日","excerpt":"<h3>基础：</h3>\\n<ol>\\n<li>索引中的数据页的编号不一定连续，也就是说这些页在存储空间里可能并不挨着</li>\\n<li>B+树中<code>相同层次</code>的数据页通过页结构的File Header 中的FIL_PAGE_PREV和FIL_PAGE_NEXT，组成双向循环链表</li>\\n<li>每个数据页内部会维护<code>页目录</code>，通过分组的方式将所有用户记录分组</li>\\n<li>每个数据页内部记录之间通过next_record连接，next_record记录的是下一个记录的偏移位置</li>\\n<li>存储用户记录的页和存储索引的页结构FIL_PAGE_TYPE都是\\"FIL_PAGE_INDEX\\"</li>\\n<li>存储索引的页里面的记录叫做<code>目录项记录</code>，即索引的非叶子结点</li>\\n<li>存储用户记录的页里面的记录做<code>用户记录</code>，即索引的叶子节点</li>\\n<li>存储<code>目录项记录</code>页中的主键值最小的那个记录的<code>min_rec_mask</code>值为<code>1</code></li>\\n</ol>","autoDesc":true}')}}]);
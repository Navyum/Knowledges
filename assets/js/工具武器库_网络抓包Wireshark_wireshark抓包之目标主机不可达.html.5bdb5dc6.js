"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[19849],{36995:(i,e)=>{e.A=(i,e)=>{const a=i.__vccOpts||i;for(const[i,s]of e)a[i]=s;return a}},74089:(i,e,a)=>{a.r(e),a.d(e,{comp:()=>l,data:()=>n});var s=a(6254);const t={},l=(0,a(36995).A)(t,[["render",function(i,e){return(0,s.uX)(),(0,s.CE)("div",null,e[0]||(e[0]=[(0,s.Fv)('<h2 id="wireshark抓包" tabindex="-1"><a class="header-anchor" href="#wireshark抓包"><span>wireshark抓包</span></a></h2><h3 id="wireshark抓包之目标主机不可达-destination-unreachable-3" tabindex="-1"><a class="header-anchor" href="#wireshark抓包之目标主机不可达-destination-unreachable-3"><span>wireshark抓包之目标主机不可达 Destination unreachable (3)</span></a></h3><hr><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景：</span></a></h3><p>最近自己新购买了一台虚拟机，想要搭建一些web服务到这台机器上并通过互联网访问</p><h3 id="出现问题" tabindex="-1"><a class="header-anchor" href="#出现问题"><span>出现问题：</span></a></h3><p>机器购买后，添加了nginx对应的web服务，本地测试curl &#39;localhost&#39; 正常，但是通过互联网的公网IP访问curl &#39;server-ip&#39;则请求一直Pending直到超时。 另外该服务器上还有一个不依赖nginx直接暴露8000端口在公网的docker镜像服务，使用curl &#39;server-ip:8000/route&#39;可以正常访问。</p><h3 id="最终定位到原因" tabindex="-1"><a class="header-anchor" href="#最终定位到原因"><span>最终定位到原因：</span></a></h3><p>直接原因：服务器网络存在无法访问的问题 根本原因：服务器的一些特定端口没有开放，存在默认的防火墙策略</p><h3 id="分析过程" tabindex="-1"><a class="header-anchor" href="#分析过程"><span>分析过程：</span></a></h3><ol><li><p>复现问题：</p><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/3883d164aa2c9ecf45af56d4ebd05973.png" width="80%"></p></li><li><p>因为服务本身3000端口正常，直接ping测试网络，网络连接正常。</p><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/5d2b987afda1677b00a4e044f1c3e109.png" width="80%"></p></li><li><p>此刻我已经蚌住了。只能采用tcpdump进行抓包，在wireshark中打开分析协议<a href="firewall.pcap">firewall.pcap</a></p><ul><li>wireshark解析结果：<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/0ecf9df6125bc5e61d81d4e678e0c5e9.png" width="80%"></p></li><li>错误信息：<p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/6b8ea5d9a4ba674e9857f68d898b7a99.png" width="80%"></p></li></ul></li><li><p>解析抓包结果：</p><ol><li><p>总共获取到两个包，1号包为客户端尝试TCP握手包（Seq=0），2号包为ICMP包。</p></li><li><p>根据常识，客户端TCP握手，你服务端应该给我返回TCP包，完成三次握手然后建立连接啊。</p></li><li><p>然后根据返回的错误信息，查询ICMP协议（互联网控制报文协议），这服务端网络不可达啊。从Host administratively prohibited可以猜测出，这感觉是个权限问题。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Type:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Destination</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> unreachable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (3)</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Code:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (Host </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">administratively</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> prohibited</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>因为3000端口正常，此时我第一个就是怀疑是不是网络链路上存在限制导致的80端口无法访问。再次使用traceroute进行检查</p><p align="center"><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/a4f3281b16efce5b97fe969da75a7d78.png" width="80%"></p></li><li><p>为了保持和curl中错误的一致性，所以我强制使用ICMP协议进行链路检测（备注：traceroute默认是使用UDP协议的）。结果证明，整个链路没有任何问题，抓包获取到的ICMP错误就是服务器返回的。此刻已经定位到出现问题的来源了。（备注：命令行中指定的80端口其实不生效，因为ICMP协议本身没有Port这个概念，这个和TCP、UDP不一样，指定ICMP时，命令自动忽略-p选项）</p></li><li><p>查找ICMP官方RFC资料</p><p>相关资料：<a href="https://www.rfc-editor.org/rfc/rfc1122.html" target="_blank" rel="noopener noreferrer">rfc1122 官方文档</a></p><blockquote><p>3.2.2.1 Destination Unreachable: RFC-792 ... <strong>10 = communication with destination host administratively prohibited</strong></p><p>A Destination Unreachable message that is received MUST be reported to the transport layer. The transport layer SHOULD use the information appropriately; for example, see Sections 4.1.3.3, 4.2.3.9, and 4.2.4 below. A transport protocol that has its own mechanism for notifying the sender that a port is unreachable (e.g., TCP, which sends RST segments) MUST nevertheless accept an ICMP Port Unreachable for the same purpose.</p></blockquote></li><li><p>排查服务器防火墙，发现安装的是firewall-cmd，查询得知firewall-cmd默认关闭了所有的1～1023的端口（很多默认服务的端口）。而8000端口不属于这个范围内，默认是放开状态。（好坑爹啊）。另外firewall默认使用的是public这个zone <a href="https://docs.redhat.com/zh-cn/documentation/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/controlling-network-traffic-using-firewalld_using-and-configuring-firewalld" target="_blank" rel="noopener noreferrer">官方文档</a></p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --get-services</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         # 获取所有知名服务</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --query-service=http</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # 获取http服务的开放状态</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>两种解决方案，选择其一：</p><ul><li>通过services方式，对已定义的服务http、https，添加开放策略（对服务端协议理解一般的，直接开放http、https更省心）<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-service=http</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  --permanent</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 永久开放http服务（即80端口）</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-service=https</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --permanent</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 永久开放https服务（即443端口）</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --reload</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                               # 重启后生效</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --list-all</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                             # 查看services字段，http、https是否有开放成功</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>通过ports方式，对指定协议+端口号方式，开放80、443端口（对动手强的更推荐这个方式，更透明些）<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-port=80/tcp</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  --permanent</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --add-port=443/tcp</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --permanent</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --reload</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                               # 重启后生效</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> firewall-cmd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --list-all</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                             # 查看ports字段，http、https是否有开放成功</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><h3 id="延伸" tabindex="-1"><a class="header-anchor" href="#延伸"><span>延伸：</span></a></h3><h4 id="关于icmp协议" tabindex="-1"><a class="header-anchor" href="#关于icmp协议"><span>关于ICMP协议</span></a></h4><ul><li><p>即 Internet Control Message Protocol，互联网控制报文协议 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f0bf192a1cf0f08545024033e15b4ed5.png" alt="Img" loading="lazy"></p></li><li><p>查询报文类型：</p><ul><li>8：主动查询</li><li>0：主动查询回显</li></ul></li><li><p>差错报文类型（Type）：</p><ul><li>3：终点不可达（地址不可达，本次抓包定位到的问题大类）</li><li>4：源抑制（让源站放慢发送速度）</li><li>5：重定向（让下次发给另一个路由器）</li><li>11：超时（也就是超过网络包的生存时间还是没到）</li></ul></li><li><p>具体应用：</p><ul><li><code>ping</code>：主动发送查询报文，获得查询回显报文</li><li><code>traceroute</code>：默认发送udp数据包（也可指定其他类型），做网络探测： <ol><li>探测沿途的路由（超时类型）： <ul><li>使用特殊的TTL，将TTL逐个累增，逐个获取链路上的路由器 IP</li></ul></li><li>探测目的主机（不可达类型）： <ul><li>使用不可能UDP端口号，收到端口不可达回应，则表示成功到达目的主机</li></ul></li><li>确定整条路径的MTU（分片错误类型）： <ul><li>故意设置为不分片，每次收到该差错报文，则调小MTU，直到到达目的主机</li></ul></li></ol></li></ul></li></ul>',14)]))}]]),n=JSON.parse('{"path":"/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE.html","title":"wireshark抓包之目标主机不可达","lang":"zh-CN","frontmatter":{"title":"wireshark抓包之目标主机不可达","date":"2025-10-15T15:11:11.000Z","author":"Navyum","icon":"lucide-lab:shark","tags":["wireshark","抓包","icmp"],"categories":["wireshark","工具"],"article":true,"index":true,"headerDepth":2,"sticky":true,"star":true,"description":"wireshark抓包 wireshark抓包之目标主机不可达 Destination unreachable (3) 背景： 最近自己新购买了一台虚拟机，想要搭建一些web服务到这台机器上并通过互联网访问 出现问题： 机器购买后，添加了nginx对应的web服务，本地测试curl \'localhost\' 正常，但是通过互联网的公网IP访问curl \'...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B7%A5%E5%85%B7%E6%AD%A6%E5%99%A8%E5%BA%93/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Wireshark/wireshark%E6%8A%93%E5%8C%85%E4%B9%8B%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"wireshark抓包之目标主机不可达"}],["meta",{"property":"og:description","content":"wireshark抓包 wireshark抓包之目标主机不可达 Destination unreachable (3) 背景： 最近自己新购买了一台虚拟机，想要搭建一些web服务到这台机器上并通过互联网访问 出现问题： 机器购买后，添加了nginx对应的web服务，本地测试curl \'localhost\' 正常，但是通过互联网的公网IP访问curl \'..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f0bf192a1cf0f08545024033e15b4ed5.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-15T08:56:54.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"wireshark"}],["meta",{"property":"article:tag","content":"抓包"}],["meta",{"property":"article:tag","content":"icmp"}],["meta",{"property":"article:published_time","content":"2025-10-15T15:11:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-15T08:56:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"wireshark抓包之目标主机不可达\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/f0bf192a1cf0f08545024033e15b4ed5.png\\"],\\"datePublished\\":\\"2025-10-15T15:11:11.000Z\\",\\"dateModified\\":\\"2025-10-15T08:56:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1760518614000,"updatedTime":1760518614000,"contributors":[{"name":"navyum","username":"navyum","email":"navyum","commits":1,"url":"https://github.com/navyum"}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"工具武器库/网络抓包Wireshark/wireshark抓包之目标主机不可达.md","localizedDate":"2025年10月15日","excerpt":"<h2>wireshark抓包</h2>\\n<h3>wireshark抓包之目标主机不可达 Destination unreachable (3)</h3>\\n<hr>\\n<h3>背景：</h3>\\n<p>最近自己新购买了一台虚拟机，想要搭建一些web服务到这台机器上并通过互联网访问</p>\\n<h3>出现问题：</h3>\\n<p>机器购买后，添加了nginx对应的web服务，本地测试curl \'localhost\' 正常，但是通过互联网的公网IP访问curl \'server-ip\'则请求一直Pending直到超时。\\n另外该服务器上还有一个不依赖nginx直接暴露8000端口在公网的docker镜像服务，使用curl \'server-ip:8000/route\'可以正常访问。</p>","autoDesc":true}')}}]);
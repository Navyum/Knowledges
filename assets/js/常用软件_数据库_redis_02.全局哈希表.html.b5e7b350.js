"use strict";(self.webpackChunknavyum_blog=self.webpackChunknavyum_blog||[]).push([[59704],{36995:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},92914:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>r,data:()=>c});var i=a(6254);const n={},r=(0,a(36995).A)(n,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h3 id="使用全局哈希表存储所有键值对" tabindex="-1"><a class="header-anchor" href="#使用全局哈希表存储所有键值对"><span>使用全局哈希表存储所有键值对</span></a></h3><figure><img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/687eba5e392ba487e475247ed1244460.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>哈希表的优点： <ul><li>用 O(1) 的时间复杂度来快速查找到键值对</li><li>只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</li></ul></li></ul><h3 id="如何解决冲突问题-链表法、开放地址法、再哈希" tabindex="-1"><a class="header-anchor" href="#如何解决冲突问题-链表法、开放地址法、再哈希"><span>如何解决冲突问题（链表法、开放地址法、再哈希）</span></a></h3><ul><li><p>redis使用链表法： <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d6f00f11504acd88afc39698050bb4f2.png" alt="图片" loading="lazy"></p></li><li><p>防止单个hash桶元素过多，当哈希冲突链过长时（负载因子），还使用了渐进式rehash</p></li><li><p>redis默认有两个全局hash表：dictht[0]、dictht[1]</p></li><li><p>哈希表扩容：</p><ol><li>给<code>哈希表2 dictht[1]</code> 分配更大的空间，例如是当前<code>哈希表1 dictht[0]</code>大小的两倍；</li><li>把<code>哈希表1 dictht[0]</code> 中的数据重新映射并拷贝到<code>哈希表2 dictht[1]</code> 中，此过程是渐进式的； <ul><li>具体操作：每处理一个请求时，从<code>哈希表 1</code> 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到<code>哈希表 2</code> 中；等处理下一个请求时，再顺带拷贝<code>哈希表 1</code> 中的下一个索引位置的 entries）</li></ul></li><li>释放<code>哈希表 1</code> 的空间 <img src="https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7e91394f24163be8a19e793d47ad9272.png" alt="图片" loading="lazy"></li></ol></li></ul>',5)]))}]]),c=JSON.parse('{"path":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02.%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.html","title":"02.全局哈希表","lang":"zh-CN","frontmatter":{"title":"02.全局哈希表","date":"2025-06-17T15:37:51.000Z","author":"Navyum","icon":"devicon-plain:redis","tags":["Redis","全局哈希表","键值对结构"],"categories":["Redis"],"article":true,"index":true,"headerDepth":2,"sticky":false,"star":true,"description":"使用全局哈希表存储所有键值对 图片图片 哈希表的优点： 用 O(1) 的时间复杂度来快速查找到键值对 只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素 如何解决冲突问题（链表法、开放地址法、再哈希） redis使用链表法： 图片 防止单个hash桶元素过多，当哈希冲突链过长时（负载因子），还使用了渐进式reh...","head":[["meta",{"property":"og:url","content":"https://myblog.camscanner.top/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02.%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"Navyum\'s Blog"}],["meta",{"property":"og:title","content":"02.全局哈希表"}],["meta",{"property":"og:description","content":"使用全局哈希表存储所有键值对 图片图片 哈希表的优点： 用 O(1) 的时间复杂度来快速查找到键值对 只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素 如何解决冲突问题（链表法、开放地址法、再哈希） redis使用链表法： 图片 防止单个hash桶元素过多，当哈希冲突链过长时（负载因子），还使用了渐进式reh..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/687eba5e392ba487e475247ed1244460.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-23T09:35:21.000Z"}],["meta",{"property":"article:author","content":"Navyum"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"全局哈希表"}],["meta",{"property":"article:tag","content":"键值对结构"}],["meta",{"property":"article:published_time","content":"2025-06-17T15:37:51.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-23T09:35:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02.全局哈希表\\",\\"image\\":[\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/687eba5e392ba487e475247ed1244460.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/d6f00f11504acd88afc39698050bb4f2.png\\",\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/7e91394f24163be8a19e793d47ad9272.png\\"],\\"datePublished\\":\\"2025-06-17T15:37:51.000Z\\",\\"dateModified\\":\\"2025-06-23T09:35:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Navyum\\"}]}"]]},"git":{"createdTime":1749983452000,"updatedTime":1750671321000,"contributors":[{"name":"Navyum","username":"Navyum","email":"36869790+Navyum@users.noreply.github.com","commits":1,"url":"https://github.com/Navyum"},{"name":"haijun_yang","username":"haijun_yang","email":"haijun_yang@intsig.net","commits":2,"url":"https://github.com/haijun_yang"}]},"readingTime":{"minutes":1.21,"words":363},"filePathRelative":"常用软件/数据库/redis/02.全局哈希表.md","localizedDate":"2025年6月17日","excerpt":"<h3>使用全局哈希表存储所有键值对</h3>\\n<figure><img src=\\"https://raw.staticdn.net/Navyum/imgbed/pic/IMG/687eba5e392ba487e475247ed1244460.png\\" alt=\\"图片\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>图片</figcaption></figure>\\n<ul>\\n<li>哈希表的优点：\\n<ul>\\n<li>用 O(1) 的时间复杂度来快速查找到键值对</li>\\n<li>只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);